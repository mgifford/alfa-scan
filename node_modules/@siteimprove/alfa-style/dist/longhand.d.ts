import type { Token } from "@siteimprove/alfa-css";
import { Keyword } from "@siteimprove/alfa-css";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Slice } from "@siteimprove/alfa-slice";
import * as parser from "@siteimprove/alfa-parser";
import type { Style } from "./style.js";
import type { Value } from "./value.js";
/**
 * @internal
 *
 * @remarks
 * The parameter name SPECIFIED is somewhat ill-named. This type does not
 * contain the default keywords that are handled globally. The actual type of
 * specified values does include them.
 */
export declare class Longhand<SPECIFIED = unknown, COMPUTED = SPECIFIED, USED = COMPUTED> {
    static of<SPECIFIED, COMPUTED = SPECIFIED, USED = COMPUTED>(initial: COMPUTED, parse: parser.Parser<Slice<Token>, SPECIFIED, string>, compute: Mapper<Value<SPECIFIED>, Value<COMPUTED>, [style: Style]>, options?: Partial<Longhand.Options<COMPUTED, USED>>): Longhand<SPECIFIED, COMPUTED, USED>;
    static extend<SPECIFIED, COMPUTED = SPECIFIED, USED = COMPUTED>(property: Longhand<SPECIFIED, COMPUTED, USED>, overrides?: {
        initial?: COMPUTED;
        parse?: parser.Parser<Slice<Token>, SPECIFIED, string>;
        compute?: Mapper<Value<SPECIFIED>, Value<COMPUTED>, [style: Style]>;
        inherits?: boolean;
        use?: Mapper<Value<COMPUTED>, Value<USED>, [style: Style]>;
    }): Longhand<SPECIFIED, COMPUTED, USED>;
    private readonly _initial;
    private readonly _parseBase;
    private readonly _parse;
    private readonly _compute;
    private readonly _inherits;
    private readonly _use;
    protected constructor(initial: COMPUTED, parseBase: parser.Parser<Slice<Token>, SPECIFIED, string>, compute: Mapper<Value<SPECIFIED>, Value<COMPUTED>, [style: Style]>, inherits: boolean, use: Mapper<Value<COMPUTED>, Value<USED>, [style: Style]>);
    get initial(): COMPUTED;
    get parse(): Longhand.Parser<SPECIFIED>;
    /**
     * Return the base parser of the property, which does not parse the global
     * default values. This is often useful when building parsers for shorthands.
     *
     * @internal
     */
    get parseBase(): parser.Parser<Slice<Token>, SPECIFIED, string>;
    get compute(): Mapper<Value<SPECIFIED>, Value<COMPUTED>, [style: Style]>;
    get inherits(): boolean;
    get use(): Mapper<Value<COMPUTED>, Value<USED>, [style: Style]>;
}
/**
 * @internal
 */
export declare namespace Longhand {
    interface Options<COMPUTED, USED = COMPUTED> {
        readonly inherits: boolean;
        readonly use: Mapper<Value<COMPUTED>, Value<USED>, [style: Style]>;
    }
    type Parser<SPECIFIED> = parser.Parser<Slice<Token>, Default | SPECIFIED, string>;
    /**
     * Extracts the parsed type of a property.
     *
     * @remarks
     * The parsed type differs from the declared type in that the parsed type
     * must not include the defaulting keywords as these are handled globally
     * rather than individually.
     *
     * @remarks
     * The parsed type doesn't really exist in CSS. It is an artefact on how we
     * handle the default keywords. It is incorrectly called SPECIFIED in the
     * class definition.
     *
     * @remarks
     * This is a convenience type for building shorthands.
     *
     * @internal
     */
    type Parsed<T> = T extends Longhand<infer S, infer _C, infer _U> ? S : never;
    /**
     * Extracts the computed type of a property.
     *
     * @remarks
     * This is a convenience type for building shorthands.
     *
     * {@link https://drafts.csswg.org/css-cascade/#computed}
     *
     * @internal
     */
    type Computed<T> = T extends Longhand<infer _S, infer C, infer _U> ? C : never;
    /**
     * Extracts the used type of a property.
     *
     * @remarks
     * This is a convenience type for building shorthands.
     *
     * {@link https://drafts.csswg.org/css-cascade/#used}
     *
     * @internal
     */
    type Used<T> = T extends Longhand<infer _S, infer _C, infer U> ? U : never;
    /**
     * The default keywords recognised by all properties.
     */
    type Default = Keyword<"initial"> | Keyword<"inherit"> | Keyword<"revert"> | Keyword<"unset">;
    const parseDefaults: import("@siteimprove/alfa-css").Parser<Keyword.ToKeywords<"initial" | "inherit" | "revert" | "unset">>;
    /**
     * Utility function for longhands whose value can only be a list of keywords.
     *
     * @internal
     */
    function fromKeywords<K extends string, USED = Keyword.ToKeywords<K>>(options: Partial<Options<Keyword.ToKeywords<K>, USED>>, initial: K, ...other: Array<K>): Longhand<Keyword.ToKeywords<K>, Keyword.ToKeywords<K>, USED>;
}
//# sourceMappingURL=longhand.d.ts.map