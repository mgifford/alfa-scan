import { Array } from "@siteimprove/alfa-array";
import { Origin } from "@siteimprove/alfa-cascade";
import { Token } from "@siteimprove/alfa-css";
import { Device } from "@siteimprove/alfa-device";
import { type Declaration, Element } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import type * as json from "@siteimprove/alfa-json";
import type { Serializable } from "@siteimprove/alfa-json";
import { Map } from "@siteimprove/alfa-map";
import { Option } from "@siteimprove/alfa-option";
import { Context } from "@siteimprove/alfa-selector";
import type { Slice } from "@siteimprove/alfa-slice";
import * as element from "./element/element.js";
import * as node from "./node/node.js";
import * as predicates from "./predicate/index.js";
import * as text from "./text/text.js";
import { Longhands } from "./longhands.js";
import { Value } from "./value.js";
type Name = Longhands.Name;
/**
 * @public
 */
export declare class Style implements Serializable<Style.JSON> {
    /**
     * Build a style from a list of declarations.
     *
     * @remarks
     * Declarations must be pre-sorted in decreasing Cascade order.
     * Prefer using Style.from(), which has fewer assumptions.
     */
    static of(styleDeclarations: Iterable<[Declaration, Origin]>, device: Device, parent?: Option<Style>, owner?: Option<Element>): Style;
    private static _empty;
    static empty(): Style;
    private readonly _owner;
    private readonly _device;
    private readonly _parent;
    private readonly _variables;
    private readonly _properties;
    private _computed;
    protected constructor(owner: Option<Element>, device: Device, parent: Option<Style>, variables: Map<string, Value<Slice<Token>>>, properties: Map<Name, Value>);
    get owner(): Option<Element>;
    get device(): Device;
    get parent(): Style;
    get variables(): Map<string, Value<Slice<Token>>>;
    get properties(): Map<string, Value>;
    root(): Style;
    /**
     * {@link https://www.w3.org/TR/css-cascade/#cascaded}
     */
    cascaded<N extends Name>(name: N): Option<Value<Style.Cascaded<N>>>;
    /**
     * {@link https://www.w3.org/TR/css-cascade/#specified}
     */
    specified<N extends Name>(name: N): Value<Style.Specified<N>>;
    /**
     * {@link https://www.w3.org/TR/css-cascade/#computed}
     */
    computed<N extends Name>(name: N): Value<Style.Computed<N>>;
    /**
     * {@link https://www.w3.org/TR/css-cascade/#used}
     *
     * @remarks
     * In our case, we do not resolve further (e.g., `width: auto`).
     * However, we filter out properties that do not apply to certain elements.
     */
    used<N extends Name>(name: N): Value<Style.Used<N>>;
    initial<N extends Name>(name: N, source?: Option<Declaration>): Value<Style.Initial<N>>;
    inherited<N extends Name>(name: N): Value<Style.Inherited<N>>;
    toJSON(): Style.JSON;
}
/**
 * @public
 */
export declare namespace Style {
    interface JSON {
        [key: string]: json.JSON;
        device: Device.JSON;
        variables: Array<[string, Value.JSON]>;
        properties: Array<[string, Value.JSON]>;
    }
    /**
     * Build the style of an element.
     *
     * @remarks
     * This gather all style declarations that apply to the element, in decreasing
     * precedence (according to cascade sort order) and delegate the rest of the
     * work to `Style.of`.
     */
    function from(element: Element, device: Device, context?: Context): Style;
    type Declared<N extends Name> = Longhands.Declared<N>;
    type Cascaded<N extends Name> = Longhands.Cascaded<N>;
    type Specified<N extends Name> = Longhands.Specified<N>;
    type Computed<N extends Name> = Longhands.Computed<N>;
    type Used<N extends Name> = Longhands.Used<N>;
    type Initial<N extends Name> = Longhands.Initial<N>;
    type Inherited<N extends Name> = Longhands.Inherited<N>;
    const getOffsetParent: typeof element.getOffsetParent, getPositioningParent: typeof element.getPositioningParent, hasBorder: typeof element.hasBorder, hasBoxShadow: typeof element.hasBoxShadow, hasCascadedStyle: typeof element.hasCascadedStyle, hasComputedStyle: typeof element.hasComputedStyle, hasInitialComputedStyle: typeof element.hasInitialComputedStyle, hasPositioningParent: typeof element.hasPositioningParent, hasOutline: typeof element.hasOutline, hasSpecifiedStyle: typeof element.hasSpecifiedStyle, hasTextDecoration: typeof element.hasTextDecoration, hasTransparentBackground: typeof element.hasTransparentBackground, hasUsedStyle: typeof element.hasUsedStyle, isFlexOrGridChild: typeof element.isFlexOrGridChild, isFocusable: typeof element.isFocusable, isImportant: typeof element.isImportant, isInert: (device: Device) => import("@siteimprove/alfa-predicate").Predicate<Element<string>, []>, isPositioned: typeof element.isPositioned, isTabbable: typeof element.isTabbable, isVisibleShadow: typeof element.isVisibleShadow;
    const innerText: (device: Device, isAcceptable?: (device: Device) => import("@siteimprove/alfa-predicate").Predicate<import("@siteimprove/alfa-dom").Text>) => (element: Element) => string, isRendered: typeof node.isRendered, isVisible: typeof node.isVisible, isScrolledBehind: typeof node.isScrolledBehind;
    const isBlockContainer: typeof predicates.isBlockContainer, isFlexContainer: typeof predicates.isFlexContainer, isGridContainer: typeof predicates.isGridContainer;
    const hasHyphenationOpportunity: typeof text.hasHyphenationOpportunity, hasSoftWrapOpportunity: typeof text.hasSoftWrapOpportunity;
}
export {};
//# sourceMappingURL=style.d.ts.map