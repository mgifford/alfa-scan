import { Keyword, List, Token } from "@siteimprove/alfa-css";
import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Longhand } from "../longhand.js";
const { either } = Parser;
/**
 * @internal
 */
export const parseCommon = Keyword.parse("common-ligatures", "no-common-ligatures");
/**
 * @internal
 */
export const parseDiscretionary = Keyword.parse("discretionary-ligatures", "no-discretionary-ligatures");
/**
 * @internal
 */
export const parseHistorical = Keyword.parse("historical-ligatures", "no-historical-ligatures");
/**
 * @internal
 */
export const parseContextual = Keyword.parse("contextual", "no-contextual");
/**
 * @internal
 */
const parseLigature = (input) => {
    let common;
    let discretionary;
    let historical;
    let contextual;
    while (true) {
        for (const [remainder] of Token.parseWhitespace(input)) {
            input = remainder;
        }
        if (common === undefined) {
            const result = parseCommon(input);
            if (result.isOk()) {
                [input, common] = result.get();
                continue;
            }
        }
        if (discretionary === undefined) {
            const result = parseDiscretionary(input);
            if (result.isOk()) {
                [input, discretionary] = result.get();
                continue;
            }
        }
        if (historical === undefined) {
            const result = parseHistorical(input);
            if (result.isOk()) {
                [input, historical] = result.get();
                continue;
            }
        }
        if (contextual === undefined) {
            const result = parseContextual(input);
            if (result.isOk()) {
                [input, contextual] = result.get();
                continue;
            }
        }
        break;
    }
    if (common === undefined &&
        discretionary === undefined &&
        historical === undefined &&
        contextual === undefined) {
        return Err.of("At least one ligature value must be provided");
    }
    return Result.of([
        input,
        List.of([common, discretionary, historical, contextual].filter((value) => value !== undefined), " "),
    ]);
};
const parse = either(Keyword.parse("none", "normal"), parseLigature);
/**
 * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-ligatures}
 * @internal
 */
export default Longhand.of(Keyword.of("normal"), parse, (ligatures) => ligatures, { inherits: true });
//# sourceMappingURL=font-variant-ligatures.js.map