import type { Applicative } from "@siteimprove/alfa-applicative";
import type { Resolvable, Value as CSSValue } from "@siteimprove/alfa-css";
import type { Declaration } from "@siteimprove/alfa-dom";
import { Equatable } from "@siteimprove/alfa-equatable";
import type { Functor } from "@siteimprove/alfa-functor";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Monad } from "@siteimprove/alfa-monad";
import type { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type * as json from "@siteimprove/alfa-json";
/**
 * @public
 */
export declare class Value<T = unknown> implements Functor<T>, Applicative<T>, Monad<T>, Iterable<T>, Equatable, Serializable<Value.JSON<T>> {
    static of<T>(value: T, source?: Option<Declaration>): Value<T>;
    private readonly _value;
    private readonly _source;
    protected constructor(value: T, source: Option<Declaration>);
    get value(): T;
    get source(): Option<Declaration>;
    map<U>(mapper: Mapper<T, U, [source: Option<Declaration>]>): Value<U>;
    resolve<T extends CSSValue>(this: Value<T>, resolver?: Resolvable.Resolver<T>): Value<Resolvable.Resolved<T>>;
    apply<U>(mapper: Value<Mapper<T, U>>): Value<U>;
    flatMap<U>(mapper: Mapper<T, Value<U>, [source: Option<Declaration>]>): Value<U>;
    flatten<T>(this: Value<Value<T>>): Value<T>;
    includes(value: T): boolean;
    some(predicate: Predicate<T, [source: Option<Declaration>]>): boolean;
    none(predicate: Predicate<T, [source: Option<Declaration>]>): boolean;
    equals(value: Value): boolean;
    equals(value: unknown): value is this;
    [Symbol.iterator](): Iterator<T>;
    toJSON(): Value.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Value {
    interface JSON<T = unknown> {
        [key: string]: json.JSON;
        value: Serializable.ToJSON<T>;
        source: Declaration.JSON | null;
    }
}
//# sourceMappingURL=value.d.ts.map