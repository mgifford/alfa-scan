import { Keyword } from "@siteimprove/alfa-css";
import * as parser from "@siteimprove/alfa-parser";
const { left, either, end } = parser.Parser;
/**
 * @internal
 *
 * @remarks
 * The parameter name SPECIFIED is somewhat ill-named. This type does not
 * contain the default keywords that are handled globally. The actual type of
 * specified values does include them.
 */
export class Longhand {
    static of(initial, parse, compute, options = {}) {
        const { inherits = false, use = (value) => value } = options;
        return new Longhand(initial, parse, compute, inherits, 
        // If `use` is not provided, we default to `Option.of`. But in this case,
        // `USED` also has no value and default to `COMPUTED`, so the assertion is
        // OK. The only bad case would be forcing the type of `USED` with, e.g.
        // `const options: Options<string, number> = {}`.
        use);
    }
    static extend(property, overrides = {}) {
        const { initial = property._initial, parse = property._parseBase, compute = property._compute, inherits = property._inherits, use = property._use, } = overrides;
        return new Longhand(initial, parse, compute, inherits, use);
    }
    _initial;
    _parseBase;
    _parse;
    _compute;
    _inherits;
    _use;
    constructor(initial, parseBase, compute, inherits, use) {
        this._initial = initial;
        this._parseBase = parseBase;
        this._parse = left(either(Longhand.parseDefaults, parseBase), end(() => "Expected end of input"));
        this._compute = compute;
        this._inherits = inherits;
        this._use = use;
    }
    get initial() {
        return this._initial;
    }
    get parse() {
        return this._parse;
    }
    /**
     * Return the base parser of the property, which does not parse the global
     * default values. This is often useful when building parsers for shorthands.
     *
     * @internal
     */
    get parseBase() {
        return this._parseBase;
    }
    get compute() {
        return this._compute;
    }
    get inherits() {
        return this._inherits;
    }
    get use() {
        return this._use;
    }
}
/**
 * @internal
 */
(function (Longhand) {
    Longhand.parseDefaults = Keyword.parse("initial", "inherit", "revert", "unset");
    /**
     * Utility function for longhands whose value can only be a list of keywords.
     *
     * @internal
     */
    function fromKeywords(options, initial, ...other) {
        return Longhand.of(Keyword.of(initial), Keyword.parse(initial, ...other), (value) => value, options);
    }
    Longhand.fromKeywords = fromKeywords;
})(Longhand || (Longhand = {}));
//# sourceMappingURL=longhand.js.map