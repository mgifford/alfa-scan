import { Array } from "@siteimprove/alfa-array";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Collection } from "@siteimprove/alfa-collection";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type { Node } from "./node.js";
/**
 * @public
 */
export declare class Map<K, V> implements Collection.Keyed<K, V> {
    static of<K, V>(...entries: Array<readonly [K, V]>): Map<K, V>;
    private static _empty;
    static empty<K = never, V = never>(): Map<K, V>;
    private readonly _root;
    private readonly _size;
    protected constructor(root: Node<K, V>, size: number);
    get size(): number;
    isEmpty(): this is Map<K, never>;
    forEach(callback: Callback<V, void, [key: K]>): void;
    map<U>(mapper: Mapper<V, U, [key: K]>): Map<K, U>;
    /**
     * Apply a map of functions to each corresponding value of this map.
     *
     * @remarks
     * Keys without a corresponding function or value are dropped from the
     * resulting map.
     *
     * @example
     * ```ts
     * Map.of(["a", 1], ["b", 2])
     *   .apply(Map.of(["a", (x) => x + 1], ["b", (x) => x * 2]))
     *   .toArray();
     * // => [["a", 2], ["b", 4]]
     * ```
     */
    apply<U>(mapper: Map<K, Mapper<V, U>>): Map<K, U>;
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatMap<L, U>(mapper: Mapper<V, Map<L, U>, [key: K]>): Map<L, U>;
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatten<K, V>(this: Map<K, Map<K, V>>): Map<K, V>;
    reduce<R>(reducer: Reducer<V, R, [key: K]>, accumulator: R): R;
    filter<U extends V>(refinement: Refinement<V, U, [key: K]>): Map<K, U>;
    filter(predicate: Predicate<V, [key: K]>): Map<K, V>;
    reject<U extends V>(refinement: Refinement<V, U, [key: K]>): Map<K, Exclude<V, U>>;
    reject(predicate: Predicate<V, [key: K]>): Map<K, V>;
    find<U extends V>(refinement: Refinement<V, U, [key: K]>): Option<U>;
    find(predicate: Predicate<V, [key: K]>): Option<V>;
    includes(value: V): boolean;
    collect<U>(mapper: Mapper<V, Option<U>, [key: K]>): Map<K, U>;
    collectFirst<U>(mapper: Mapper<V, Option<U>, [key: K]>): Option<U>;
    some(predicate: Predicate<V, [key: K]>): boolean;
    none(predicate: Predicate<V, [key: K]>): boolean;
    every(predicate: Predicate<V, [key: K]>): boolean;
    count(predicate: Predicate<V, [key: K]>): number;
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate values are encountered.
     */
    distinct(): Map<K, V>;
    get(key: K): Option<V>;
    has(key: K): boolean;
    set(key: K, value: V): Map<K, V>;
    delete(key: K): Map<K, V>;
    concat(iterable: Iterable<readonly [K, V]>): Map<K, V>;
    subtract(iterable: Iterable<readonly [K, V]>): Map<K, V>;
    intersect(iterable: Iterable<readonly [K, V]>): Map<K, V>;
    tee<A extends Array<unknown> = []>(callback: Callback<this, void, [...args: A]>, ...args: A): this;
    equals<K, V>(value: Map<K, V>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    keys(): Iterable<K>;
    values(): Iterable<V>;
    iterator(): Iterator<[K, V]>;
    [Symbol.iterator](): Iterator<[K, V]>;
    toArray(): Array<[K, V]>;
    toJSON(options?: Serializable.Options): Map.JSON<K, V>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Map {
    type JSON<K, V> = Collection.Keyed.JSON<K, V>;
    function isMap<K, V>(value: Iterable<readonly [K, V]>): value is Map<K, V>;
    function isMap<K, V>(value: unknown): value is Map<K, V>;
    function from<K, V>(iterable: Iterable<readonly [K, V]>): Map<K, V>;
    function fromArray<K, V>(array: ReadonlyArray<readonly [K, V]>): Map<K, V>;
    function fromIterable<K, V>(iterable: Iterable<readonly [K, V]>): Map<K, V>;
}
//# sourceMappingURL=map.d.ts.map