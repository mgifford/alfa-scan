import { Equatable } from "@siteimprove/alfa-equatable";
import type { Functor } from "@siteimprove/alfa-functor";
import type { Iterable } from "@siteimprove/alfa-iterable";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Status } from "./status.js";
/**
 * Maps are stored as an hash-table of keys.
 * The hash-table is stored as a tree where each internal node is a partial
 * match of the hashes of its subtree.
 *
 * Nodes in the tree can be:
 * * empty;
 * * a Leaf, containing one single key;
 * * a Collision, containing several keys with the same hash, this is
 *   effectively a leaf of the tree, even though it actually has several Leaf
 *   children (but no other kind);
 * * a Sparse, which is an internal node. Sparses have masks and all hashes in
 *   this subtree share the same mask (partial hash collision). The matching of
 *   masks is done with a shift, which essentially take slices of n (=5) bits
 *   of the hash. The shift is automatically increased when looking down the
 *   tree, hence the same mask cannot be used at another level of a tree.
 */
/**
 * @internal
 */
export interface Node<K, V> extends Functor<V>, Iterable<[K, V]>, Equatable {
    isEmpty(): this is Empty;
    isLeaf(): this is Leaf<K, V>;
    get(key: K, hash: number, shift: number): Option<V>;
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
    delete(key: K, hash: number, shift: number): Status<Node<K, V>>;
    map<U>(mapper: Mapper<V, U, [K]>): Node<K, U>;
}
/**
 * @internal
 */
export declare namespace Node {
    const Bits = 5;
    function fragment(hash: number, shift: number): number;
    function index(fragment: number, mask: number): number;
}
/**
 * @internal
 */
export interface Empty extends Node<never, never> {
}
/**
 * @internal
 */
export declare const Empty: Empty;
/**
 * @internal
 */
export declare class Leaf<K, V> implements Node<K, V> {
    static of<K, V>(hash: number, key: K, value: V): Leaf<K, V>;
    private readonly _hash;
    private readonly _key;
    private readonly _value;
    protected constructor(hash: number, key: K, value: V);
    get key(): K;
    get value(): V;
    isEmpty(): this is Empty;
    isLeaf(): this is Leaf<K, V>;
    get(key: K, hash: number, shift: number): Option<V>;
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
    delete(key: K, hash: number): Status<Node<K, V>>;
    map<U>(mapper: Mapper<V, U, [K]>): Leaf<K, U>;
    equals(value: unknown): value is this;
    [Symbol.iterator](): Iterator<[K, V]>;
}
/**
 * @internal
 */
export declare class Collision<K, V> implements Node<K, V> {
    static of<K, V>(hash: number, nodes: Array<Leaf<K, V>>): Collision<K, V>;
    private readonly _hash;
    private readonly _nodes;
    protected constructor(hash: number, nodes: Array<Leaf<K, V>>);
    isEmpty(): this is Empty;
    isLeaf(): this is Leaf<K, V>;
    get(key: K, hash: number, shift: number): Option<V>;
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
    delete(key: K, hash: number): Status<Node<K, V>>;
    map<U>(mapper: Mapper<V, U, [K]>): Collision<K, U>;
    equals(value: unknown): value is this;
    [Symbol.iterator](): Iterator<[K, V]>;
}
/**
 * @internal
 */
export declare class Sparse<K, V> implements Node<K, V> {
    static of<K, V>(mask: number, nodes: Array<Node<K, V>>): Sparse<K, V>;
    private readonly _mask;
    private readonly _nodes;
    protected constructor(mask: number, nodes: Array<Node<K, V>>);
    isEmpty(): this is Empty;
    isLeaf(): this is Leaf<K, V>;
    get(key: K, hash: number, shift: number): Option<V>;
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
    delete(key: K, hash: number, shift: number): Status<Node<K, V>>;
    map<U>(mapper: Mapper<V, U, [K]>): Sparse<K, U>;
    equals(value: unknown): value is this;
    [Symbol.iterator](): Iterator<[K, V]>;
}
//# sourceMappingURL=node.d.ts.map