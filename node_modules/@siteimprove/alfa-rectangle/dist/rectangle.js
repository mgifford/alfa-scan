import { Comparable } from "@siteimprove/alfa-comparable";
import { Sequence } from "@siteimprove/alfa-sequence";
const { max, min } = Math;
/**
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMRect}
 *
 * @remarks
 * The y axis in the coordinate system on the HTML canvas is inverted so that
 * the y coordinates gets bigger further down the page.
 *
 * @public
 */
export class Rectangle {
    static of(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    }
    static _empty = new Rectangle(Infinity, Infinity, 0, 0);
    static empty() {
        return this._empty;
    }
    static _full = new Rectangle(-Infinity, -Infinity, Infinity, Infinity);
    static full() {
        return this._full;
    }
    _x;
    _y;
    _width;
    _height;
    constructor(x, y, width, height) {
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get top() {
        // Infinity - Infinity is NaN, but here we want it to be -Infinity
        if (this._y === Infinity && this._height === -Infinity) {
            return -Infinity;
        }
        return this._height > 0 ? this._y : this._y + this._height;
    }
    get right() {
        // -Infinity + Infinity is NaN, but here we want it to be Infinity
        if (this._x === -Infinity && this._width === Infinity) {
            return Infinity;
        }
        return this._width > 0 ? this._x + this._width : this._x;
    }
    get bottom() {
        // -Infinity + Infinity is NaN, but here we want it to be Infinity
        if (this._y === -Infinity && this._height === Infinity) {
            return Infinity;
        }
        return this._height > 0 ? this._y + this._height : this._y;
    }
    get left() {
        // Infinity - Infinity is NaN, but here we want it to be -Infinity
        if (this._x === Infinity && this._width === -Infinity) {
            return -Infinity;
        }
        return this._width > 0 ? this._x : this._x + this._width;
    }
    get center() {
        // TODO: How to handle infinite rectangles?
        return {
            x: this._x + this._width / 2,
            y: this._y + this._height / 2,
        };
    }
    get area() {
        return this._width * this._height;
    }
    isEmpty() {
        return this.equals(Rectangle.empty());
    }
    isFull() {
        return this.equals(Rectangle.full());
    }
    contains(other) {
        if (other.isEmpty() || this.isFull()) {
            return true;
        }
        return (this.left <= other.left &&
            this.top <= other.top &&
            other.right <= this.right &&
            other.bottom <= this.bottom);
    }
    intersects(other) {
        return (other.left <= this.right &&
            other.top <= this.bottom &&
            other.right >= this.left &&
            other.bottom >= this.top);
    }
    union(other) {
        if (this.contains(other)) {
            return this;
        }
        if (other.contains(this)) {
            return other;
        }
        const minLeft = min(this.left, other.left);
        const minTop = min(this.top, other.top);
        const maxRight = max(this.right, other.right);
        const maxBottom = max(this.bottom, other.bottom);
        return Rectangle.of(minLeft, minTop, maxRight - minLeft, maxBottom - minTop);
    }
    intersection(other) {
        if (!this.intersects(other)) {
            return Rectangle.empty();
        }
        if (this.contains(other)) {
            return other;
        }
        if (other.contains(this)) {
            return this;
        }
        const maxLeft = max(this.left, other.left);
        const maxTop = max(this.top, other.top);
        const minRight = min(this.right, other.right);
        const minBottom = min(this.bottom, other.bottom);
        return Rectangle.of(maxLeft, maxTop, minRight - maxLeft, minBottom - maxTop);
    }
    /**
     * Subtracts one or more rectangles. The result is a collection of smaller
     * rectangles covering the part of the original rectangle which didn't overlap
     * the rectangles that was subtracted. The smaller rectangles will have the
     * maximal possible width and height and for each subtraction between 0 and 4
     * smaller rectangles will be produced to cover the difference.
     *
     * In the following example, the rectangles overlap in such a way that the
     * difference will consist of two narrow overlapping rectangles to the right
     * and below, overlapping in the bottom right corner:
     *
     * @remarks
     * When doing repeated subtraction, we need to limit the size of the result
     * as it can otherwise explode. The limit is hard coded to 256.
     *
     *       +---------------------------------------+
     *       |                                       |
     *       |                                       |
     *       |     +- - - - - - - - - - - - - - - - -+-------+
     *       |     |                                 |\\\\\\\|
     *       |                                       |\\\\\\\|
     *       |     |                                 |\\\\\\\|
     *       |                                       |\\\\\\\|
     *       |     |                                 |\\\\\\\|
     *       |                                       |\\\\\\\|
     *       |     |                                 |\\\\\\\|
     *       |                                       |\\\\\\\|
     *       +-----+---------------------------------+-------+
     *             |/////////////////////////////////|XXXXXXX|
     *             |/////////////////////////////////|XXXXXXX|
     *             +---------------------------------+-------+
     */
    subtract(...others) {
        // Sort by intersection area descending so that the biggest chunks are removed first.
        others.sort((a, b) => Comparable.compare(b.intersection(this).area, a.intersection(this).area));
        let result = [this];
        for (const other of others) {
            result = result.flatMap((rect) => rect._subtract(other));
            // The result grows by a factor of at most 4 for every repeated subtraction.
            // In some cases this can become too big to fit in an array.
            // We limit the result to avoid running out of memory and we set the limit fairly low
            // to avoid degrading the performance when the result is later processed.
            // The assumption is that by ordering the rectangles as we do above so that the most intersecting rectangles are subtracted first,
            // limiting the result will still provide a good approximation.
            // We should consider if there is a better way to represent the result of subtraction using rectilinear polygons:
            // https://en.wikipedia.org/wiki/Rectilinear_polygon
            if (result.length >= 256) {
                return Sequence.from(result);
            }
            // If the difference becomes empty, there is no need to keep subtracting.
            if (result.length === 0) {
                return Sequence.empty();
            }
        }
        return Sequence.from(result);
    }
    _subtract(other) {
        if (!this.intersects(other)) {
            return [this];
        }
        const result = [];
        if (this.top < other.top) {
            result.push(Rectangle.of(this.left, this.top, this.width, other.top - this.top));
        }
        if (this.left < other.left) {
            result.push(Rectangle.of(this.left, this.top, other.left - this.left, this.height));
        }
        if (other.bottom < this.bottom) {
            result.push(Rectangle.of(this.left, other.bottom, this.width, this.bottom - other.bottom));
        }
        if (other.right < this.right) {
            result.push(Rectangle.of(other.right, this.top, this.right - other.right, this.height));
        }
        return result;
    }
    /**
     * Checks if the rectangle intersects a given circle.
     *
     * @remarks
     * @see ../docs/circle-rectangle-intersection.png for a visual explanation of the case
     * where the circle center lies in one of the corners of the padded rectangle.
     *
     * @privateRemarks
     * To check intersection, we pad the rectangle by the radius of the circle and divide the problem into three cases:
     *
     * 1. The circle center is outside the padded rectangle.
     * 2. The circle center is inside the padded rectangle, but not in one of the corners.
     * 3. The circle center lies in one of the corners of the padded rectangle in which case we need to compute the distance to the corner
     *
     *                 r
     *              +-------+-------------------------+-------+
     *              |       |                         |       |
     *     1        |       |                         |       |
     *              +-------+-------------------------+-------+
     *              |       |                         |       |
     *              |       |                         |       |
     *              |       |                         |       |
     *              |       |                         |       |
     *              |       |                         |       |
     *              +-------+-------------------------+-------+
     *              |       |            2            |       |
     *              | 3     |                         |       |
     *              +-------+-------------------------+-------+
     */
    intersectsCircle(cx, cy, r) {
        const center = this.center;
        const halfWidth = this.width / 2;
        const halfHeight = this.height / 2;
        const dx = Math.abs(cx - center.x);
        const dy = Math.abs(cy - center.y);
        if (dx > halfWidth + r || dy > halfHeight + r) {
            // 1. The circle center is outside the padded rectangle
            return false;
        }
        // The circle center is inside the padded rectangle
        if (dx <= halfWidth || dy <= halfHeight) {
            // 2. The circle lies at most a radius away from the rectangle in the x or y directions
            return true;
        }
        // 3. The circle center lies in one of the corners of the padded rectangle.
        // If the distance from the circle center to the closest corner of the rectangle
        // is less than the radius of the circle, the circle intersects the rectangle.
        return (dx - halfWidth) ** 2 + (dy - halfHeight) ** 2 <= r ** 2;
    }
    /**
     * Computes the squared distance between the centers of two rectangles.
     *
     * @remarks
     * The squared distance is used to avoid the expensive square root operation.
     * If the actual distance is needed, the square root of the squared distance can be taken.
     */
    distanceSquared(other) {
        const c1 = this.center;
        const c2 = other.center;
        return (c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2;
    }
    equals(value) {
        return (value === this ||
            (value instanceof Rectangle &&
                value.top === this.top &&
                value.left === this.left &&
                value.bottom === this.bottom &&
                value.right === this.right));
    }
    hash(hash) {
        hash
            .writeNumber(this._x)
            .writeNumber(this._y)
            .writeNumber(this._width)
            .writeNumber(this._height);
    }
    toString() {
        return `Rectangle { x: ${this._x}, y: ${this._y}, width: ${this._width}, height: ${this._height} }`;
    }
    toJSON() {
        return {
            type: "rectangle",
            x: this._x,
            y: this._y,
            width: this._width,
            height: this._height,
        };
    }
}
/**
 * @public
 */
(function (Rectangle) {
    function from(json) {
        return Rectangle.of(json.x, json.y, json.width, json.height);
    }
    Rectangle.from = from;
    function isRectangle(value) {
        return value instanceof Rectangle;
    }
    Rectangle.isRectangle = isRectangle;
    function union(...rectangles) {
        return rectangles.reduce((previous, current) => previous.union(current), Rectangle.empty());
    }
    Rectangle.union = union;
    function intersection(...rectangles) {
        return rectangles.reduce((previous, current) => previous.intersection(current), Rectangle.full());
    }
    Rectangle.intersection = intersection;
})(Rectangle || (Rectangle = {}));
//# sourceMappingURL=rectangle.js.map