import type { Callback } from "@siteimprove/alfa-callback";
import { Serializable } from "@siteimprove/alfa-json";
import type * as json from "@siteimprove/alfa-json";
/**
 * @public
 */
export declare class Performance<T> implements AsyncIterable<Performance.Entry<T>>, Serializable<Performance.JSON> {
    static of<T = string>(): Performance<T>;
    private readonly _epoch;
    private readonly _emitter;
    protected constructor();
    get epoch(): number;
    now(): number;
    elapsed(now?: number): number;
    mark(data: T, start?: Performance.Entry<T> | number): Performance.Mark<T>;
    measure(data: T, start?: Performance.Entry<T> | number, end?: Performance.Entry<T> | number): Performance.Measure<T>;
    on(listener: Callback<Performance.Entry<T>>): this;
    once(): Promise<Performance.Entry<T>>;
    once(listener: Callback<Performance.Entry<T>>): this;
    off(listener: Callback<Performance.Entry<T>>): this;
    asyncIterator(): AsyncIterator<Performance.Entry<T>>;
    [Symbol.asyncIterator](): AsyncIterator<Performance.Entry<T>>;
    toJSON(): Performance.JSON;
    private _emit;
}
/**
 * @public
 */
export declare namespace Performance {
    interface JSON {
        [key: string]: json.JSON;
    }
    function isPerformance<T>(value: unknown): value is Performance<T>;
    type Entry<T> = Mark<T> | Measure<T>;
    namespace Entry {
        type JSON<T> = Mark.JSON<T> | Measure.JSON<T>;
    }
    class Mark<T> implements Serializable<Mark.JSON<T>> {
        static of<T>(data: T, start: number): Mark<T>;
        private readonly _data;
        private readonly _start;
        protected constructor(data: T, start: number);
        get type(): "mark";
        get data(): T;
        get start(): number;
        toJSON(): Mark.JSON<T>;
    }
    namespace Mark {
        interface JSON<T> {
            [key: string]: json.JSON | undefined;
            type: "mark";
            data: Serializable.ToJSON<T>;
            start: number;
        }
        function isMark<T>(value: unknown | Entry<T>): value is Mark<T>;
    }
    const mark: typeof Mark.of, isMark: typeof Mark.isMark;
    class Measure<T> implements Serializable<Measure.JSON<T>> {
        static of<T>(data: T, start: number, duration: number): Measure<T>;
        private readonly _data;
        private readonly _start;
        private readonly _duration;
        protected constructor(data: T, start: number, duration: number);
        get type(): "measure";
        get data(): T;
        get start(): number;
        get duration(): number;
        toJSON(): Measure.JSON<T>;
    }
    namespace Measure {
        interface JSON<T> {
            [key: string]: json.JSON | undefined;
            type: "measure";
            data: Serializable.ToJSON<T>;
            start: number;
            duration: number;
        }
        function isMeasure<T>(value: unknown | Entry<T>): value is Measure<T>;
    }
    const measure: typeof Measure.of, isMeasure: typeof Measure.isMeasure;
}
//# sourceMappingURL=performance.d.ts.map