import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Err, Result } from "@siteimprove/alfa-result";
import { Sequence } from "@siteimprove/alfa-sequence";
import * as builtin from "./builtin.js";
const { isEmpty } = Iterable;
/**
 * {@link https://url.spec.whatwg.org/}
 *
 * @public
 */
export class URL {
    static of(scheme, username = None, password = None, host = None, port = None, path = [], query = None, fragment = None, cannotBeABase = false) {
        return new URL(scheme, username, password, host, port, Sequence.from(path), query, fragment, cannotBeABase);
    }
    /**
     * {@link https://tools.ietf.org/html/rfc2606#section-3}
     */
    static example() {
        // this is a valid URL
        return URL.parse("https://example.com").getUnsafe();
    }
    /**
     * {@link https://tools.ietf.org/html/rfc6694#section-3}
     */
    static blank() {
        // this is a valid URL
        return URL.parse("about:blank").getUnsafe();
    }
    _scheme;
    _username;
    _password;
    _host;
    _port;
    _path;
    _query;
    _fragment;
    _cannotBeABase;
    constructor(scheme, username, password, host, port, path, query, fragment, cannotBeABase) {
        this._scheme = scheme;
        this._username = username;
        this._password = password;
        this._host = host;
        this._port = port;
        this._path = path;
        this._query = query;
        this._fragment = fragment;
        this._cannotBeABase = cannotBeABase;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-scheme}
     */
    get scheme() {
        return this._scheme;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-username}
     */
    get username() {
        return this._username;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-password}
     */
    get password() {
        return this._password;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-host}
     */
    get host() {
        return this._host;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-port}
     */
    get port() {
        return this._port;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-path}
     */
    get path() {
        return this._path;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-query}
     */
    get query() {
        return this._query;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-fragment}
     */
    get fragment() {
        return this._fragment;
    }
    /**
     * {@link https://url.spec.whatwg.org/#url-cannot-be-a-base-url-flag}
     */
    get cannotBeABase() {
        return this._cannotBeABase;
    }
    /**
     * {@link https://url.spec.whatwg.org/#is-special}
     */
    isSpecial() {
        return URL.isSpecialScheme(this._scheme);
    }
    /**
     * {@link https://url.spec.whatwg.org/#include-credentials}
     */
    hasCredentials() {
        return this._username.isSome() || this._password.isSome();
    }
    /**
     * Remove the fragment portion of this URL.
     *
     * @remarks
     * This method is useful for contexts in which the fragment portion of the URL,
     * which isn't passed from client to server, is of no interest.
     */
    withoutFragment() {
        if (this._fragment.isNone()) {
            return this;
        }
        return new URL(this._scheme, this._username, this._password, this._host, this._port, this._path, this._query, None, this._cannotBeABase);
    }
    equals(value) {
        return (value instanceof URL &&
            value._scheme === this._scheme &&
            value._username.equals(this._username) &&
            value._password.equals(this._password) &&
            value._host.equals(this._host) &&
            value._port.equals(this._port) &&
            value._path.equals(this._path) &&
            value._query.equals(this._query) &&
            value._fragment.equals(this._fragment) &&
            value._cannotBeABase === this._cannotBeABase);
    }
    hash(hash) {
        hash
            .writeString(this._scheme)
            .writeHashable(this._username)
            .writeHashable(this._password)
            .writeHashable(this._host)
            .writeHashable(this._port)
            .writeHashable(this._path)
            .writeHashable(this._query)
            .writeHashable(this._fragment)
            .writeBoolean(this._cannotBeABase);
    }
    toJSON() {
        return {
            scheme: this._scheme,
            username: this._username.getOr(null),
            password: this._password.getOr(null),
            host: this._host.getOr(null),
            port: this._port.getOr(null),
            path: this._path.toArray(),
            query: this._query.getOr(null),
            fragment: this._fragment.getOr(null),
            cannotBeABase: this._cannotBeABase,
        };
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-serializer}
     */
    toString() {
        let output = this._scheme + ":";
        for (const host of this._host) {
            output += "//";
            if (this.hasCredentials()) {
                for (const username of this._username) {
                    output += username;
                }
                for (const password of this._password) {
                    output += ":" + password;
                }
                output += "@";
            }
            output += host;
            for (const port of this._port) {
                output += ":" + port.toString(10);
            }
        }
        if (this._cannotBeABase) {
            output += this._path.get(0).getOr("");
        }
        else {
            if (this._host.isNone() &&
                this._path.size > 1 &&
                this._path.first().includes("")) {
                output += "/.";
            }
            for (const segment of this._path) {
                output += "/" + segment;
            }
        }
        for (const query of this._query) {
            output += "?" + query;
        }
        for (const fragment of this._fragment) {
            output += "#" + fragment;
        }
        return output;
    }
}
/**
 * @public
 */
(function (URL) {
    function from(json) {
        return URL.of(json.scheme, Option.from(json.username), Option.from(json.password), Option.from(json.host), Option.from(json.port), json.path, Option.from(json.query), Option.from(json.fragment));
    }
    URL.from = from;
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-parser}
     *
     * @remarks
     * Parsing URLs is tricky business and so this function relies on the presence
     * of a globally available WHATWG URL class. This API is available in both
     * browsers, Node.js, and Deno.
     */
    function parse(url, base) {
        if (typeof base === "string") {
            const result = parse(base);
            if (!result.isOk()) {
                return result;
            }
            base = result.get();
        }
        try {
            const { 
            // https://url.spec.whatwg.org/#dom-url-protocol
            protocol, 
            // https://url.spec.whatwg.org/#dom-url-username
            username, 
            // https://url.spec.whatwg.org/#dom-url-password
            password, 
            // https://url.spec.whatwg.org/#dom-url-hostname
            hostname, 
            // https://url.spec.whatwg.org/#dom-url-port
            port, 
            // https://url.spec.whatwg.org/#dom-url-pathname
            pathname, 
            // https://url.spec.whatwg.org/#dom-url-search
            search, 
            // https://url.spec.whatwg.org/#dom-url-hash
            hash, } = new builtin.URL(url, base?.toString());
            // `URL#protocol` appends a ":" to the scheme which we need to remove.
            const scheme = protocol.replace(/:$/, "");
            return Result.of(URL.of(scheme, 
            // `URL#username` `URL#password` expose the username and password
            // as-is and so the only thing we need to do is reject them when
            // empty.
            Option.of(username).reject(isEmpty), Option.of(password).reject(isEmpty), 
            // `URL#hostname` exposes the host as an empty string if the host is
            // `null`. For the `file` scheme, however, the empty string is
            // significant and we therefore don't translate it into `None`.
            scheme === "file"
                ? Option.of(hostname)
                : Option.of(hostname).reject(isEmpty), 
            // `URL#port` exposes the port number as a string to we convert it to
            // a number.
            Option.of(port).reject(isEmpty).map(Number), 
            // `URL#pathname` exposes the path segments with a leading "/" and
            // joins the segments with "/". We therefore remove the leading "/"
            // and split the segments by "/" into an array.
            pathname.replace(/^\//, "").split("/"), 
            // `URL#search` exposes the query portion of the URL with a leading
            // "?" which we need to remove.
            Option.of(search)
                .reject(isEmpty)
                .map((search) => search.replace(/^\?/, "")), 
            // `URL#hash` exposes the fragment portion of the URL with a leading
            // "#" which we need to remove.
            Option.of(hash)
                .reject(isEmpty)
                .map((hash) => hash.replace(/^#/, "")), 
            // The URL cannot be used as a base URL when the scheme isn't
            // special and the pathname doesn't start with a leading "/".
            !isSpecialScheme(scheme) && pathname[0] !== "/"));
        }
        catch (err) {
            if (err instanceof Error) {
                return Err.of(err.message);
            }
            else {
                return Err.of(`${err}`);
            }
        }
    }
    URL.parse = parse;
    /**
     * {@link https://url.spec.whatwg.org/#special-scheme}
     */
    function isSpecialScheme(scheme) {
        switch (scheme) {
            case "ftp":
            case "file":
            case "http":
            case "https":
            case "ws":
            case "wss":
                return true;
            default:
                return false;
        }
    }
    URL.isSpecialScheme = isSpecialScheme;
})(URL || (URL = {}));
//# sourceMappingURL=url.js.map