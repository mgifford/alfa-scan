/**
 * A factory for simple RNG. This creates a functorial factory where results can
 * be further mapped; once the #create() method is called the RNG is frozen and
 * cannot be mapped anymore; before it cannot be called.
 *
 * @remarks
 * The core of the RNG is taken from
 * {@link https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript}
 * {@link https://gist.github.com/tommyettinger/46a874533244883189143505d203312c}
 *
 * This is not a crypto-safe RNG. Use only for low-security needs.
 *
 * The RNG seed and iterations count can be inspected, this allows to reproduce
 * any sequence of random numbers by using the same seed and number of
 * iterations. This is notably intended to allow for deterministic debugging.
 *
 * Per nature of the goal we have here, the RNG class **dose not** respect
 * Alfa's Architecture Decision 6: Use pure functions, avoid hidden side effects.
 * {@link https://github.com/Siteimprove/alfa/blob/main/docs/architecture/decisions/adr-006.md}
 * The RNG has an internal state and works by side effect, it does not have referential transparency.
 *
 * @public
 */
export class RNGFactory {
    /**
     * Create a RNG that returns a number between 0 and 1.
     */
    static of(seed = (Math.random() * 2 ** 32) >>> 0) {
        const rng = RNGFactory.seedableRNG(seed);
        return new RNGFactory(seed, rng);
    }
    _rng;
    _seed;
    constructor(seed, rng) {
        this._seed = seed;
        this._rng = rng;
    }
    /**
     * What was the seed used to initialize the RNG.
     */
    get seed() {
        return this._seed;
    }
    map(mapper) {
        return new RNGFactory(this._seed, () => mapper(this._rng()));
    }
    group(size) {
        return new RNGFactory(this._seed, () => {
            const group = [];
            for (let i = 0; i < size; i++) {
                group.push(this._rng());
            }
            return group;
        });
    }
    zip(other) {
        return new RNGFactory(this._seed, () => {
            const arrayA = this._rng();
            const arrayB = other._rng();
            const result = [];
            // We can't use Array.zip here as it would prevent us from using the RNG
            // in alfa-array tests…
            for (let i = 0; i < Math.min(arrayA.length, arrayB.length); i++) {
                result.push([arrayA[i], arrayB[i]]);
            }
            return result;
        });
    }
    create() {
        return RNG.of(this._seed, this._rng);
    }
    /**
     * Mulberry32 PRNG taken from
     * {@link https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript}
     */
    static seedableRNG(seed) {
        return function rng() {
            let t = (seed += 0x6d2b79f5);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }
}
/**
 * A simple static RNG.
 *
 * @remarks
 * Use the RNGFactory class to create the RNG, piling up any transformations
 * needed to produce the result.
 *
 * @public
 */
export class RNG {
    /**
     * Create a RNG.
     *
     * @remarks
     * Do not use, prefer using RNGFactory#create().
     */
    static of(seed, rng) {
        // Burning through some iterations improves the entropy of the RNG on sparse
        // seeds and similar seeds. See linked Stack Overflow article.
        for (let i = 0; i < 20; i++) {
            rng();
        }
        return new RNG(seed, rng);
    }
    _rand;
    _seed;
    _iterations;
    constructor(seed, rng) {
        this._seed = seed;
        this._iterations = 0;
        this._rand = () => {
            this._iterations++;
            return rng();
        };
    }
    /**
     * Generate a random number.
     *
     * @privateRemarks
     * This is a getter return a 0-arity function. So, it is used as `rng.rand()`
     * which matches the syntax of usual `rand()` functions.
     */
    get rand() {
        return this._rand;
    }
    /**
     * What was the seed used to initialize the RNG.
     */
    get seed() {
        return this._seed;
    }
    /**
     * How many times the RNG has been called so far
     */
    get iterations() {
        return this._iterations;
    }
}
/**
 * @public
 */
(function (RNG) {
    /**
     * Seedable RNG returning a number between 0 (included) and 1 (excluded).
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function standard(seed) {
        return RNGFactory.of(seed);
    }
    RNG.standard = standard;
    /**
     * @remarks
     * Must have 0 ⩽ value \< 1.
     * Result will be 0 ⩽ value \< max.
     *
     * @internal
     */
    function toInteger(max = Number.MAX_SAFE_INTEGER) {
        return (value) => Math.floor(value * max);
    }
    /**
     * Seedable RNG returning an integer between 0 (included) and max (excluded).
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function integer(max = Number.MAX_SAFE_INTEGER, seed) {
        return RNGFactory.of(seed).map(toInteger(max));
    }
    RNG.integer = integer;
    function toHex(value) {
        return value.toString(16);
    }
    /**
     * Seedable RNG returning a hex string of a given length.
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function hexString(length, seed) {
        return RNGFactory.of(seed)
            .map(toInteger(16))
            .map(toHex)
            .group(length)
            .map((group) => group.join(""));
    }
    RNG.hexString = hexString;
})(RNG || (RNG = {}));
//# sourceMappingURL=rng.js.map