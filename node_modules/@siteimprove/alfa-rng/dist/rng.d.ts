import type { Functor } from "@siteimprove/alfa-functor";
import type { Mapper } from "@siteimprove/alfa-mapper";
/**
 * A factory for simple RNG. This creates a functorial factory where results can
 * be further mapped; once the #create() method is called the RNG is frozen and
 * cannot be mapped anymore; before it cannot be called.
 *
 * @remarks
 * The core of the RNG is taken from
 * {@link https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript}
 * {@link https://gist.github.com/tommyettinger/46a874533244883189143505d203312c}
 *
 * This is not a crypto-safe RNG. Use only for low-security needs.
 *
 * The RNG seed and iterations count can be inspected, this allows to reproduce
 * any sequence of random numbers by using the same seed and number of
 * iterations. This is notably intended to allow for deterministic debugging.
 *
 * Per nature of the goal we have here, the RNG class **dose not** respect
 * Alfa's Architecture Decision 6: Use pure functions, avoid hidden side effects.
 * {@link https://github.com/Siteimprove/alfa/blob/main/docs/architecture/decisions/adr-006.md}
 * The RNG has an internal state and works by side effect, it does not have referential transparency.
 *
 * @public
 */
export declare class RNGFactory<T = number> implements Functor<T> {
    /**
     * Create a RNG that returns a number between 0 and 1.
     */
    static of(seed?: number): RNGFactory;
    private readonly _rng;
    private readonly _seed;
    protected constructor(seed: number, rng: () => T);
    /**
     * What was the seed used to initialize the RNG.
     */
    get seed(): number;
    map<U>(mapper: Mapper<T, U>): RNGFactory<U>;
    group(size: number): RNGFactory<Array<T>>;
    zip<U, V>(this: RNGFactory<Array<U>>, other: RNGFactory<Array<V>>): RNGFactory<Array<[U, V]>>;
    create(): RNG<T>;
    /**
     * Mulberry32 PRNG taken from
     * {@link https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript}
     */
    private static seedableRNG;
}
/**
 * A simple static RNG.
 *
 * @remarks
 * Use the RNGFactory class to create the RNG, piling up any transformations
 * needed to produce the result.
 *
 * @public
 */
export declare class RNG<T = number> {
    /**
     * Create a RNG.
     *
     * @remarks
     * Do not use, prefer using RNGFactory#create().
     */
    static of<T = number>(seed: number, rng: () => T): RNG<T>;
    private readonly _rand;
    private readonly _seed;
    private _iterations;
    protected constructor(seed: number, rng: () => T);
    /**
     * Generate a random number.
     *
     * @privateRemarks
     * This is a getter return a 0-arity function. So, it is used as `rng.rand()`
     * which matches the syntax of usual `rand()` functions.
     */
    get rand(): () => T;
    /**
     * What was the seed used to initialize the RNG.
     */
    get seed(): number;
    /**
     * How many times the RNG has been called so far
     */
    get iterations(): number;
}
/**
 * @public
 */
export declare namespace RNG {
    /**
     * Seedable RNG returning a number between 0 (included) and 1 (excluded).
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function standard(seed?: number): RNGFactory<number>;
    /**
     * Seedable RNG returning an integer between 0 (included) and max (excluded).
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function integer(max?: number, seed?: number): RNGFactory<number>;
    /**
     * Seedable RNG returning a hex string of a given length.
     *
     * @remarks
     * This RNG is decent but not crypto-safe.
     */
    function hexString(length: number, seed?: number): RNGFactory<string>;
}
//# sourceMappingURL=rng.d.ts.map