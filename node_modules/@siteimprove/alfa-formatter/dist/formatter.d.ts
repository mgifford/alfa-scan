import type { Outcome, Question, Rule } from "@siteimprove/alfa-act";
import type { Future } from "@siteimprove/alfa-future";
import type { Hashable } from "@siteimprove/alfa-hash";
import { Result } from "@siteimprove/alfa-result";
/**
 * @public
 */
export type Formatter<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> = (input: I, rules: Iterable<Rule<I, T, Q, S>>, outcomes: Iterable<Outcome<I, T, Q, S>>) => Future.Maybe<string>;
/**
 * @public
 */
export declare namespace Formatter {
    function load<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(name: string, defaultScope?: string): Promise<Result<Formatter<I, T, Q, S>, string>>;
}
//# sourceMappingURL=formatter.d.ts.map