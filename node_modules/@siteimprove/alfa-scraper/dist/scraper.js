/// <reference lib="dom" preserve="true" />
import * as fs from "fs";
import { Device } from "@siteimprove/alfa-device";
import { Header, Headers, Request, Response } from "@siteimprove/alfa-http";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Puppeteer } from "@siteimprove/alfa-puppeteer";
import { Result, Err } from "@siteimprove/alfa-result";
import { Timeout } from "@siteimprove/alfa-time";
import { URL } from "@siteimprove/alfa-url";
import { Page } from "@siteimprove/alfa-web";
import * as puppeteer from "puppeteer";
import { Archive } from "./archive.js";
import { Awaiter } from "./awaiter.js";
const { entries } = Object;
const { ceil } = Math;
/**
 * @public
 */
export class Scraper {
    static async of(browser = puppeteer.launch({
        headless: true,
        args: [
            "--no-sandbox",
            // In order to be able to access external style sheets through CSSOM, we
            // have to disable CORS restrictions in Chromium.
            "--disable-web-security",
        ],
    })) {
        return new Scraper(await browser);
    }
    static async with(mapper, browser) {
        const scraper = await this.of(browser);
        try {
            return await mapper(scraper);
        }
        finally {
            await scraper.close();
        }
    }
    _browser;
    constructor(browser) {
        this._browser = browser;
    }
    /**
     * Scrape the specified URL.
     */
    async scrape(url, options = {}) {
        if (typeof url === "string") {
            const result = URL.parse(url);
            if (!result.isOk()) {
                return result;
            }
            url = result.get();
        }
        const scheme = url.scheme;
        const { timeout = Timeout.of(10000), awaiter = Awaiter.loaded(), device = Device.standard(), credentials = null, screenshot = null, archive = null, headers = [], cookies = [], fit = true, } = options;
        const { viewport, viewport: { width, height }, display: { resolution }, scripting, } = device;
        let page;
        try {
            page = await this._browser.newPage();
            const client = await page.target().createCDPSession();
            await page.emulateMediaType(device.type === Device.Type.Print ? "print" : "screen");
            // Puppeteer doesn't yet support all available media features and so might
            // throw if passed an unsupported feature. Catch these errors and pass
            // them on to the caller to deal with.
            try {
                await page.emulateMediaFeatures([
                    ...Iterable.map(device.preferences, (preference) => preference.toJSON()),
                ]);
            }
            catch (err) {
                if (err instanceof Error) {
                    return Err.of(err.message);
                }
                else {
                    return Err.of(`${err}`);
                }
            }
            await page.setViewport({
                width,
                height,
                deviceScaleFactor: resolution,
                isLandscape: viewport.isLandscape(),
            });
            await page.setJavaScriptEnabled(scripting.enabled);
            if (credentials !== null) {
                await page.authenticate(credentials);
            }
            await page.setExtraHTTPHeaders(Iterable.reduce(headers, (headers, header) => {
                headers[header.name] = header.value;
                return headers;
            }, {}));
            if (scheme === "http" || scheme === "https") {
                await page.setCookie(...Iterable.map(cookies, (cookie) => {
                    return {
                        name: cookie.name,
                        value: cookie.value,
                        url: url.toString(),
                    };
                }));
            }
            let origin = url.toString();
            while (true) {
                try {
                    // Navigate to the origin with what remains of the timeout. We wait
                    // for the `DOMContentLoaded` event as this is the earliest stage at
                    // which Puppeteer will consider the page loaded.
                    const response = page.goto(origin, {
                        timeout: timeout.remaining(),
                        waitUntil: "domcontentloaded",
                    });
                    // Grab the request from the resulting response as soon as possible.
                    // In event of navigation away from the origin, such as redirects, the
                    // response context will be destroyed. If we attempt to grab the
                    // request after this, things will go haywire.
                    const request = response.then((response) => response?.request());
                    // When the response has settled, fit the viewport to the contents of
                    // the page if requested to do so. This is done by requesting the
                    // layout metrics of the page and setting the viewport accordingly.
                    const resize = response.then(async () => {
                        if (fit) {
                            const { contentSize: { width, height }, } = await client.send("Page.getLayoutMetrics");
                            await page?.setViewport({
                                width: ceil(width),
                                height: ceil(height),
                            });
                        }
                    });
                    const load = awaiter(page, timeout);
                    // Await both the response, request, and resize promise at the same
                    // time to avoid any exceptions being dropped on the floor. At the
                    // very least, we need all of these settled before we parse the
                    // document.
                    await Promise.all([response, request, resize]);
                    for (const error of await load) {
                        return Err.of(error);
                    }
                    const alfaPage = await parsePage(page, options);
                    if (screenshot !== null) {
                        await captureScreenshot(page, screenshot);
                    }
                    if (archive !== null) {
                        await captureArchive(client, archive);
                    }
                    const req = await request;
                    const res = await response;
                    if (req === undefined) {
                        return Err.of("No request found in response");
                    }
                    if (res === null) {
                        return Err.of("No response received");
                    }
                    return Result.of(Page.of(parseRequest(req), await parseResponse(res), alfaPage.document, alfaPage.device));
                }
                catch (err) {
                    // If the timeout was exceeded while navigating to the page, bail out
                    // with an error.
                    if (err instanceof Error && err.name === "TimeoutError") {
                        return Err.of(`Timeout exceeded while navigating to the page`);
                    }
                    // Otherwise, attempt to navigate to the page again, changing its
                    // origin in case a redirect was performed.
                    else {
                        origin = page.url();
                    }
                }
            }
        }
        finally {
            if (page !== undefined) {
                await page.close();
            }
        }
    }
    /**
     * Close the scraper and its associated browser.
     */
    async close() {
        await this._browser.close();
    }
}
function parseRequest(request) {
    return Request.of(request.method(), URL.parse(request.url()).getUnsafe(), Headers.of(entries(request.headers()).map(([name, value]) => Header.of(name, value))));
}
// This is suboptimal as it recreates the buffer. There seems to be something
// going on with Puppeteer's response.buffer() returning a Buffer<ArrayBufferLike>
// even though it might actually always be a Buffer<ArrayBuffer>, and Ndoe/TS
// started picking this up.
// See https://stackoverflow.com/questions/79345535/how-to-convert-bufferarraybufferlike-to-arraybuffer-in-typescript-5-7
// for related discussion.
function bufferToArrayBuffer(buffer) {
    return new Uint8Array(buffer).buffer;
}
async function parseResponse(response) {
    return Response.of(URL.parse(response.url()).getUnsafe(), response.status(), Headers.of(entries(response.headers()).map(([name, value]) => Header.of(name, value))), response.ok()
        ? bufferToArrayBuffer(await response.buffer())
        : new ArrayBuffer(0));
}
async function parsePage(page, options) {
    return Puppeteer.toPage(await page.evaluateHandle(() => window.document), options);
}
async function captureScreenshot(page, screenshot) {
    switch (screenshot.type.type) {
        case "png":
            await page.screenshot({
                path: screenshot.path,
                type: "png",
                omitBackground: !screenshot.type.background,
                fullPage: true,
                encoding: "binary",
            });
            break;
        case "jpeg":
            await page.screenshot({
                path: screenshot.path,
                type: "jpeg",
                quality: screenshot.type.quality,
                fullPage: true,
                encoding: "binary",
            });
    }
}
async function captureArchive(client, archive) {
    switch (archive.format) {
        case Archive.Format.MHTML: {
            const { data } = await client.send("Page.captureSnapshot", {
                format: "mhtml",
            });
            await new Promise((resolve, reject) => fs.writeFile(archive.path, data, "utf-8", (err) => err ? reject(err) : resolve()));
        }
    }
}
//# sourceMappingURL=scraper.js.map