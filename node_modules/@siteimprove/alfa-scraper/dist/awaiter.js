/// <reference lib="dom" />
import { Array } from "@siteimprove/alfa-array";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Option, None } from "@siteimprove/alfa-option";
import { Promise } from "@siteimprove/alfa-promise";
/**
 * @public
 */
export var Awaiter;
(function (Awaiter) {
    /**
     * Wait for any of the given awaiters.
     */
    function any(awaiters) {
        return async (page, timeout) => Promise.any(...Iterable.map(awaiters, (awaiter) => awaiter(page, timeout)));
    }
    Awaiter.any = any;
    /**
     * Wait for all of the given awaiters.
     */
    function all(awaiters) {
        return async (page, timeout) => Promise.all(...Iterable.map(awaiters, (awaiter) => awaiter(page, timeout))).then((errors) => Array.collectFirst(errors, (error) => error));
    }
    Awaiter.all = all;
    /**
     * Wait for the `DOMContentLoaded` event to fire.
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event}
     */
    function ready() {
        return async (page, timeout) => {
            try {
                await page.waitForNavigation({
                    waitUntil: "domcontentloaded",
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for the document to be ready`);
            }
        };
    }
    Awaiter.ready = ready;
    /**
     * Wait for the `load` event.
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event}
     */
    function loaded() {
        return async (page, timeout) => {
            try {
                await page.waitForNavigation({
                    waitUntil: "load",
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for the document to load`);
            }
        };
    }
    Awaiter.loaded = loaded;
    /**
     * Wait for the network to be idle, i.e. have no requests inflight.
     */
    function idle() {
        return async (page, timeout) => {
            try {
                await page.waitForNavigation({
                    waitUntil: "networkidle0",
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for the network to be idle`);
            }
        };
    }
    Awaiter.idle = idle;
    /**
     * Wait for a fixed duration after another awaiter has finished.
     */
    function duration(duration, after = loaded()) {
        return async (page, timeout) => {
            const error = await after(page, timeout);
            if (error.isNone()) {
                await new globalThis.Promise(function (resolve) {
                    setTimeout(resolve, duration);
                });
            }
            return error;
        };
    }
    Awaiter.duration = duration;
    /**
     * Wait for an element matching the given selector to be present and visible.
     */
    function selector(selector) {
        return async (page, timeout) => {
            try {
                await page.waitForSelector(selector, {
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for the selector "${selector}"`);
            }
        };
    }
    Awaiter.selector = selector;
    /**
     * Wait for an element matching the given expression to be present and visible.
     */
    function xpath(expression) {
        return async (page, timeout) => {
            try {
                await page.waitForSelector("xpath/" + expression, {
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for the expression "${selector}"`);
            }
        };
    }
    Awaiter.xpath = xpath;
    /**
     * Wait for all animations to end after another awaiter has finished.
     *
     * @remarks
     * For animations that loop infinitely, this awaiter will never resolve.
     */
    function animations(after = loaded()) {
        return async (page, timeout) => {
            try {
                const error = await after(page, timeout);
                if (error.isSome()) {
                    return error;
                }
                await page.waitForFunction(() => document
                    .getAnimations()
                    .every((animation) => animation.playState !== "running"), {
                    timeout: timeout.remaining(),
                });
                return None;
            }
            catch {
                return Option.of(`Timeout exceeded while waiting for animations to end`);
            }
        };
    }
    Awaiter.animations = animations;
})(Awaiter || (Awaiter = {}));
//# sourceMappingURL=awaiter.js.map