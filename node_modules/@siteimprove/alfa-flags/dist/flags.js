import { Array } from "@siteimprove/alfa-array";
import { Map } from "@siteimprove/alfa-map";
/**
 * Class for modelling set of boolean flags.
 * Prefer using `Flags.named` where possible.
 *
 * @remarks
 * Flags are stored as bits in a single number. Due to Javascript limitation
 * on bitwise operations, this means that a maximum of 32 flags can be handled.
 * We currently limit the class at a maximum of 8 flags since it fits our needs.
 *
 * @public
 */
export class Flags {
    /**
     * A compact representation of the set of flags as a number
     *
     * @privateRemarks
     * We usually have protected fields and getters for these cases. However,
     * this makes TS unhappy about the class factory `named`.
     * {@link https://github.com/microsoft/TypeScript/issues/17744}
     * We could (should?) craft the correct type of the class for the factory to
     * return. However, given the dynamic nature of it (with the named fields),
     * this gets very tricky. Given that this field is just a number, it is easier
     * to make it public and forgo the getter.
     */
    value;
    // Same here, should be `protected`, with a getter.
    kind;
    constructor(kind, value) {
        this.kind = kind;
        this.value = value;
    }
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    has(flag) {
        // If the flag is 0, we are testing for the absence of any flag.
        // Otherwise, we are testing for the presence of the flag.
        return flag === 0 ? this.value === 0 : (this.value & flag) === flag;
    }
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    isSet = this.has;
    /**
     * Adds a list of flags to the set, and return a new one.
     */
    add(...flags) {
        return new this.constructor(this.kind, this.value | Flags.reduce(...flags));
    }
    /**
     * Adds a list of flags to the set (aka sets the flags), and return a new one.
     */
    set = this.add;
    /**
     * Removes a list of flags from the set, and return a new one.
     */
    remove(...flags) {
        return new this.constructor(this.kind, this.value & ~Flags.reduce(...flags));
    }
    /**
     * Removes a list of flags to the set (aka unsets the flags), and return a
     * new one.
     */
    unset = this.remove;
    /**
     * Test whether a set of flags exactly contains the listed flags.
     */
    is(...flags) {
        return this.value === Flags.reduce(...flags);
    }
    equals(value) {
        return (value instanceof Flags &&
            this.kind === value.kind &&
            this.value === value.value);
    }
    toJSON() {
        return { type: "flags", kind: this.kind, value: this.value };
    }
}
/**
 * @public
 */
(function (Flags) {
    /**
     * Reduces a list of flags into a single number representing all of them
     * (with only the corresponding bits set to 1).
     *
     * @internal
     */
    function reduce(...flags) {
        return Array.reduce(flags, (prev, cur) => prev | cur, 0);
    }
    Flags.reduce = reduce;
    /**
     * Individual flags are numbers with at most one bit set to 1, i.e. powers of
     * two.
     * Since we do not currently need more than 8 flags, we can safely restrict
     * this union.
     */
    const allFlagsArray = [1, 2, 4, 8, 16, 32, 64, 128];
    const maxFlag = allFlagsArray.length;
    function named(kind, ...flags) {
        /************* Prepping the flags *************/
        // How many flags do we actually have?
        const totalFlags = Math.min(flags.length, maxFlag);
        const lastFlag = 2 ** (totalFlags - 1);
        /********************** ***********************/
        /************** Prepping the (flag -> value) map */
        const flagValues = allFlagsArray
            .slice(0, totalFlags)
            .map((_, i) => [
            flags[i],
            allFlagsArray[i],
        ]);
        const namesMap = Map.of(...flagValues);
        const flagsMap = Map.of(...flagValues.map(([k, v]) => [v, k]));
        function toFlag(flag) {
            return typeof flag === "string"
                ? namesMap.get(flag).getOr(0)
                : flag > lastFlag
                    ? 0
                    : flag;
        }
        /********************** ***********************/
        function reduceNamed(...flags) {
            return reduce(...flags.map(toFlag));
        }
        /**
         * A set of named flags.
         *
         * @remarks
         * The flags are accessible both by name and by number.
         */
        class Named extends Flags {
            static of(...flags) {
                return new Named(kind, reduceNamed(...flags));
            }
            // Every flags set always has 0 for the "no flag" value.
            // Again, these should be private, with a getter.
            static none = 0;
            static empty = new Named(kind, Named.none);
            static allFlags = allFlagsArray.slice(0, totalFlags);
            /**
             * Returns the name of a flag.
             */
            static nameOf(flag) {
                return flagsMap
                    .get(flag)
                    .getUnsafe(`Flag ${flag} not found in ${kind} / ${flags}`);
            }
            /* Rewrite the base clas methods to allow for names in addition of values. */
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            has(flag) {
                return super.has(toFlag(flag));
            }
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            isSet = this.has;
            /**
             * Adds a list of flags to the set, and return a new one.
             */
            add(...flags) {
                return new Named(kind, this.value | reduceNamed(...flags));
            }
            /**
             * Adds a list of flags to the set (aka sets the flags), and return a new one.
             */
            set = this.add;
            /**
             * Removes a list of flags from the set, and return a new one.
             */
            remove(...flags) {
                return new Named(kind, this.value & ~reduceNamed(...flags));
            }
            /**
             * Removes a list of flags to the set (aka unsets the flags), and return a
             * new one.
             */
            unset = this.remove;
            /**
             * Test whether a set of flags exactly contains the listed flags.
             */
            is(...flags) {
                return super.is(...flags.map(toFlag));
            }
            equals(value) {
                return value instanceof Named && super.equals(value);
            }
            toString() {
                return Named.allFlags
                    .filter(this.has.bind(this))
                    .map(Named.nameOf)
                    .join(" ");
            }
            toJSON() {
                let res = super.toJSON();
                for (let i = 0; i < totalFlags; i++) {
                    res[flags[i]] = this.has(flags[i]);
                }
                return res;
            }
        }
        /* Now we start to do some dark magic to add direct accessors by the names */
        // This adds static Named.x, Named.y, etc. for each name in `flags`.
        // The value is the corresponding flag, i.e. a power of 2.
        for (let i = 0; i < totalFlags; i++) {
            Object.defineProperty(Named, flags[i], {
                value: allFlagsArray[i],
                writable: false,
            });
        }
        // This adds instance getters Named#x, Named#y, etc. for each name in `flags`.
        // The value is a boolean, whether the flag is set on that specific instance.
        for (let i = 0; i < totalFlags; i++) {
            Object.defineProperty(Named.prototype, flags[i], {
                get: function () {
                    return this.has(flags[i]);
                },
            });
        }
        /* Dark magic ends here */
        return Named;
    }
    Flags.named = named;
})(Flags || (Flags = {}));
//# sourceMappingURL=flags.js.map