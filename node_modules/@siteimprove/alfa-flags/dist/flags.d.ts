import { Array } from "@siteimprove/alfa-array";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type * as json from "@siteimprove/alfa-json";
/**
 * Class for modelling set of boolean flags.
 * Prefer using `Flags.named` where possible.
 *
 * @remarks
 * Flags are stored as bits in a single number. Due to Javascript limitation
 * on bitwise operations, this means that a maximum of 32 flags can be handled.
 * We currently limit the class at a maximum of 8 flags since it fits our needs.
 *
 * @public
 */
export declare class Flags<K extends string = string, F extends Flags.allFlags = Flags.allFlags> implements Equatable, json.Serializable<Flags.JSON<K>> {
    /**
     * A compact representation of the set of flags as a number
     *
     * @privateRemarks
     * We usually have protected fields and getters for these cases. However,
     * this makes TS unhappy about the class factory `named`.
     * {@link https://github.com/microsoft/TypeScript/issues/17744}
     * We could (should?) craft the correct type of the class for the factory to
     * return. However, given the dynamic nature of it (with the named fields),
     * this gets very tricky. Given that this field is just a number, it is easier
     * to make it public and forgo the getter.
     */
    readonly value: number;
    readonly kind: K;
    protected constructor(kind: K, value: number);
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    has(flag: F): boolean;
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    isSet: (flag: F) => boolean;
    /**
     * Adds a list of flags to the set, and return a new one.
     */
    add(...flags: Array<F>): this;
    /**
     * Adds a list of flags to the set (aka sets the flags), and return a new one.
     */
    set: (...flags: Array<F>) => this;
    /**
     * Removes a list of flags from the set, and return a new one.
     */
    remove(...flags: Array<F>): this;
    /**
     * Removes a list of flags to the set (aka unsets the flags), and return a
     * new one.
     */
    unset: (...flags: Array<F>) => this;
    /**
     * Test whether a set of flags exactly contains the listed flags.
     */
    is(...flags: Array<F>): boolean;
    equals(value: Flags): boolean;
    equals(value: unknown): value is this;
    toJSON(): Flags.JSON<K>;
}
/**
 * @public
 */
export declare namespace Flags {
    /**
     * Reduces a list of flags into a single number representing all of them
     * (with only the corresponding bits set to 1).
     *
     * @internal
     */
    export function reduce(...flags: Array<number>): number;
    export interface JSON<K extends string = string> {
        [key: string]: json.JSON;
        type: "flags";
        kind: K;
        value: number;
    }
    /**
     * Individual flags are numbers with at most one bit set to 1, i.e. powers of
     * two.
     * Since we do not currently need more than 8 flags, we can safely restrict
     * this union.
     */
    const allFlagsArray: readonly [1, 2, 4, 8, 16, 32, 64, 128];
    type NonZeroFlags = [1, 2, 4, 8, 16, 32, 64, 128];
    /**
     * @internal
     */
    export type allFlags = 0 | (typeof allFlagsArray)[number];
    /**
     * Turns ["a", "b", "c"] into \{ a: X; b: X; c: X \}
     */
    type KeyedByArray<A extends Array<string>, X> = {
        [key in A[number]]: X;
    };
    /**
     * Keep the first Bound.length types in A (or all if less).
     * Using an array for the bound just makes the type easier since there is no
     * arithmetic on the `number` type.
     * This effectively treats Bound as a unary number.
     */
    type Shorten<T, A extends ReadonlyArray<T>, Bound extends ReadonlyArray<any>> = A extends [infer AHead, ...infer ATail extends ReadonlyArray<T>] ? Bound extends [any, ...infer BTail extends ReadonlyArray<any>] ? [AHead, ...Shorten<T, ATail, BTail>] : [] : [];
    type ReplaceFactories<T extends {
        of: any;
        empty: any;
    }, Name extends string, F extends allFlags, Instance> = {
        [key in keyof T]: key extends "of" ? (...flags: Array<F | Name>) => Instance : key extends "empty" ? Instance : T[key];
    };
    export function named<K extends string, A extends Array<string>>(kind: K, ...flags: A): ReplaceFactories<{
        new (kind: K, value: number): {
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            has(flag: Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])): boolean;
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            isSet: (flag: Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])) => boolean;
            /**
             * Adds a list of flags to the set, and return a new one.
             */
            add(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Adds a list of flags to the set (aka sets the flags), and return a new one.
             */
            set: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Removes a list of flags from the set, and return a new one.
             */
            remove(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Removes a list of flags to the set (aka unsets the flags), and return a
             * new one.
             */
            unset: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Test whether a set of flags exactly contains the listed flags.
             */
            is(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): boolean;
            equals(value: /*elided*/ any): boolean;
            equals(value: unknown): value is /*elided*/ any;
            toString(): string;
            toJSON(): Flags.JSON<K> & KeyedByArray<A, boolean>;
            /**
             * A compact representation of the set of flags as a number
             *
             * @privateRemarks
             * We usually have protected fields and getters for these cases. However,
             * this makes TS unhappy about the class factory `named`.
             * {@link https://github.com/microsoft/TypeScript/issues/17744}
             * We could (should?) craft the correct type of the class for the factory to
             * return. However, given the dynamic nature of it (with the named fields),
             * this gets very tricky. Given that this field is just a number, it is easier
             * to make it public and forgo the getter.
             */
            readonly value: number;
            readonly kind: K;
        };
        of(...flags: Array<(0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]>): {
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            has(flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]): boolean;
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            isSet: (flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]) => boolean;
            /**
             * Adds a list of flags to the set, and return a new one.
             */
            add(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Adds a list of flags to the set (aka sets the flags), and return a new one.
             */
            set: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Removes a list of flags from the set, and return a new one.
             */
            remove(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Removes a list of flags to the set (aka unsets the flags), and return a
             * new one.
             */
            unset: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Test whether a set of flags exactly contains the listed flags.
             */
            is(...flags: Array<(0 | (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]>): boolean;
            equals(value: /*elided*/ any): boolean;
            equals(value: unknown): value is /*elided*/ any;
            toString(): string;
            toJSON(): Flags.JSON<K> & KeyedByArray<A, boolean>;
            /**
             * A compact representation of the set of flags as a number
             *
             * @privateRemarks
             * We usually have protected fields and getters for these cases. However,
             * this makes TS unhappy about the class factory `named`.
             * {@link https://github.com/microsoft/TypeScript/issues/17744}
             * We could (should?) craft the correct type of the class for the factory to
             * return. However, given the dynamic nature of it (with the named fields),
             * this gets very tricky. Given that this field is just a number, it is easier
             * to make it public and forgo the getter.
             */
            readonly value: number;
            readonly kind: K;
        };
        readonly none: 0;
        readonly empty: {
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            has(flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]): boolean;
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            isSet: (flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]) => boolean;
            /**
             * Adds a list of flags to the set, and return a new one.
             */
            add(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Adds a list of flags to the set (aka sets the flags), and return a new one.
             */
            set: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Removes a list of flags from the set, and return a new one.
             */
            remove(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Removes a list of flags to the set (aka unsets the flags), and return a
             * new one.
             */
            unset: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Test whether a set of flags exactly contains the listed flags.
             */
            is(...flags: Array<(0 | (Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]>): boolean;
            equals(value: /*elided*/ any): boolean;
            equals(value: unknown): value is /*elided*/ any;
            toString(): string;
            toJSON(): Flags.JSON<K> & KeyedByArray<A, boolean>;
            /**
             * A compact representation of the set of flags as a number
             *
             * @privateRemarks
             * We usually have protected fields and getters for these cases. However,
             * this makes TS unhappy about the class factory `named`.
             * {@link https://github.com/microsoft/TypeScript/issues/17744}
             * We could (should?) craft the correct type of the class for the factory to
             * return. However, given the dynamic nature of it (with the named fields),
             * this gets very tricky. Given that this field is just a number, it is easier
             * to make it public and forgo the getter.
             */
            readonly value: number;
            readonly kind: K;
        };
        readonly allFlags: Shorten<string, A, NonZeroFlags> extends infer T ? T extends Shorten<string, A, NonZeroFlags> ? T extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never;
        /**
         * Returns the name of a flag.
         */
        nameOf(flag: (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]): Shorten<string, A, NonZeroFlags>[number];
        /**
         * Reduces a list of flags into a single number representing all of them
         * (with only the corresponding bits set to 1).
         *
         * @internal
         */
        reduce(...flags: Array<number>): number;
        named<K extends string, A extends Array<string>>(kind: K, ...flags: A): ReplaceFactories</*elided*/ any & KeyedByArray<Shorten<string, A, NonZeroFlags>, (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]>, Shorten<string, A, NonZeroFlags>[number], 0 | (Shorten<string, A, NonZeroFlags> extends infer T_2 ? T_2 extends Shorten<string, A, NonZeroFlags> ? T_2 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number], {
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            has(flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]): boolean;
            /**
             * Test whether a given flag is present (or set) in the set of flags
             */
            isSet: (flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]) => boolean;
            /**
             * Adds a list of flags to the set, and return a new one.
             */
            add(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Adds a list of flags to the set (aka sets the flags), and return a new one.
             */
            set: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Removes a list of flags from the set, and return a new one.
             */
            remove(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
            /**
             * Removes a list of flags to the set (aka unsets the flags), and return a
             * new one.
             */
            unset: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
            /**
             * Test whether a set of flags exactly contains the listed flags.
             */
            is(...flags: Array<(0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]>): boolean;
            equals(value: /*elided*/ any): boolean;
            equals(value: unknown): value is /*elided*/ any;
            toString(): string;
            toJSON(): Flags.JSON<K> & KeyedByArray<A, boolean>;
            /**
             * A compact representation of the set of flags as a number
             *
             * @privateRemarks
             * We usually have protected fields and getters for these cases. However,
             * this makes TS unhappy about the class factory `named`.
             * {@link https://github.com/microsoft/TypeScript/issues/17744}
             * We could (should?) craft the correct type of the class for the factory to
             * return. However, given the dynamic nature of it (with the named fields),
             * this gets very tricky. Given that this field is just a number, it is easier
             * to make it public and forgo the getter.
             */
            readonly value: number;
            readonly kind: K;
        } & KeyedByArray<Shorten<string, A, NonZeroFlags>, boolean>>;
    } & KeyedByArray<Shorten<string, A, NonZeroFlags>, (Shorten<string, A, NonZeroFlags> extends infer T_1 ? T_1 extends Shorten<string, A, NonZeroFlags> ? T_1 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]>, Shorten<string, A, NonZeroFlags>[number], 0 | (Shorten<string, A, NonZeroFlags> extends infer T_2 ? T_2 extends Shorten<string, A, NonZeroFlags> ? T_2 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number], {
        /**
         * Test whether a given flag is present (or set) in the set of flags
         */
        has(flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]): boolean;
        /**
         * Test whether a given flag is present (or set) in the set of flags
         */
        isSet: (flag: (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]) => boolean;
        /**
         * Adds a list of flags to the set, and return a new one.
         */
        add(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
        /**
         * Adds a list of flags to the set (aka sets the flags), and return a new one.
         */
        set: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
        /**
         * Removes a list of flags from the set, and return a new one.
         */
        remove(...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>): /*elided*/ any;
        /**
         * Removes a list of flags to the set (aka unsets the flags), and return a
         * new one.
         */
        unset: (...flags: Array<Shorten<string, A, NonZeroFlags>[number] | (0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number])>) => /*elided*/ any;
        /**
         * Test whether a set of flags exactly contains the listed flags.
         */
        is(...flags: Array<(0 | (Shorten<string, A, NonZeroFlags> extends infer T_3 ? T_3 extends Shorten<string, A, NonZeroFlags> ? T_3 extends [any, ...infer BTail extends readonly any[]] ? [1, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [2, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [4, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [8, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [16, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [32, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [64, ...BTail extends [any, ...infer BTail extends readonly any[]] ? [128] : []] : []] : []] : []] : []] : []] : []] : [] : never : never)[number]) | Shorten<string, A, NonZeroFlags>[number]>): boolean;
        equals(value: /*elided*/ any): boolean;
        equals(value: unknown): value is /*elided*/ any;
        toString(): string;
        toJSON(): Flags.JSON<K> & KeyedByArray<A, boolean>;
        /**
         * A compact representation of the set of flags as a number
         *
         * @privateRemarks
         * We usually have protected fields and getters for these cases. However,
         * this makes TS unhappy about the class factory `named`.
         * {@link https://github.com/microsoft/TypeScript/issues/17744}
         * We could (should?) craft the correct type of the class for the factory to
         * return. However, given the dynamic nature of it (with the named fields),
         * this gets very tricky. Given that this field is just a number, it is easier
         * to make it public and forgo the getter.
         */
        readonly value: number;
        readonly kind: K;
    } & KeyedByArray<Shorten<string, A, NonZeroFlags>, boolean>>;
    export {};
}
//# sourceMappingURL=flags.d.ts.map