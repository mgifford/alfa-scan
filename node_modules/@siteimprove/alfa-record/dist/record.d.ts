import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Foldable } from "@siteimprove/alfa-foldable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { List } from "@siteimprove/alfa-list";
import type { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
/**
 * @public
 */
export declare class Record<T> implements Foldable<Record.Value<T>>, Iterable<Record.Entry<T>>, Equatable, Serializable<Record.JSON<T>> {
    static of<T>(properties: T): Record<T>;
    private readonly _indices;
    private readonly _keys;
    private readonly _values;
    protected constructor(indices: ReadonlyMap<string, number>, keys: ReadonlyArray<Record.Key<T>>, values: List<T[Record.Key<T>]>);
    has(key: string): key is Record.Key<T>;
    get<K extends Record.Key<T>>(key: K): Option<T[K]>;
    set<K extends Record.Key<T>>(key: K, value: T[K]): Record<T>;
    reduce<R>(reducer: Reducer<Record.Value<T>, R, [Record.Key<T>]>, accumulator: R): R;
    some(predicate: Predicate<Record.Value<T>, [Record.Key<T>]>): boolean;
    every(predicate: Predicate<Record.Value<T>, [Record.Key<T>]>): boolean;
    equals(value: Record<T>): boolean;
    equals(value: unknown): value is this;
    keys(): Iterable<Record.Key<T>>;
    values(): Iterable<Record.Value<T>>;
    entries(): Iterable<Record.Entry<T>>;
    [Symbol.iterator](): Iterator<Record.Entry<T>>;
    toArray(): Array<Record.Entry<T>>;
    toJSON(options?: Serializable.Options): Record.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Record {
    type Key<T> = Extract<keyof T, string>;
    type Value<T> = T[Key<T>];
    type Entry<T> = {
        [K in Key<T>]: [K, T[K]];
    }[Key<T>];
    type JSON<T> = {
        [K in Key<T>]: Serializable.ToJSON<T[K]>;
    };
    function isRecord<T>(value: unknown): value is Record<T>;
    function from<T>(entries: Iterable<Entry<T>>): Record<T>;
}
//# sourceMappingURL=record.d.ts.map