import type { Callback } from "@siteimprove/alfa-callback";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { None, Option } from "@siteimprove/alfa-option";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type * as json from "@siteimprove/alfa-json";
import type { Either } from "./either.js";
import type { Left } from "./left.js";
/**
 * @public
 */
export declare class Right<R> implements Either<never, R> {
    static of<R>(value: R): Right<R>;
    private readonly _value;
    protected constructor(value: R);
    isLeft(): this is Left<never>;
    isRight(): this is Right<R>;
    map<T>(mapper: Mapper<R, T>): Right<T>;
    apply<L, T>(mapper: Either<L, Mapper<R, T>>): Either<L, T>;
    flatMap<L, T>(mapper: Mapper<R, Either<L, T>>): Either<L, T>;
    flatten<L, R>(this: Right<Either<L, R>>): Either<L, R>;
    reduce<T>(reducer: Reducer<R, T>, accumulator: T): T;
    either<T>(left: unknown, right: Mapper<R, T>): T;
    get(): R;
    left(): None;
    right(): Option<R>;
    teeLeft(): Right<R>;
    teeRight(callback: Callback<R>): Right<R>;
    equals<R>(value: Right<R>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Iterator<R>;
    toJSON(): Right.JSON<R>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Right {
    interface JSON<R> {
        [key: string]: json.JSON;
        type: "right";
        value: Serializable.ToJSON<R>;
    }
    function isRight<R>(value: Iterable<R>): value is Right<R>;
    function isRight<R>(value: unknown): value is Right<R>;
}
//# sourceMappingURL=right.d.ts.map