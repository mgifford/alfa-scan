import type { Callback } from "@siteimprove/alfa-callback";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { None, Option } from "@siteimprove/alfa-option";
import type * as json from "@siteimprove/alfa-json";
import type { Either } from "./either.js";
import type { Right } from "./right.js";
/**
 * @public
 */
export declare class Left<L> implements Either<L, never> {
    static of<L>(value: L): Left<L>;
    private readonly _value;
    protected constructor(value: L);
    isLeft(): this is Left<L>;
    isRight(): this is Right<never>;
    map(): Left<L>;
    apply(): Left<L>;
    flatMap(): Left<L>;
    flatten<L, R>(this: Either<L, never>): Either<L, R>;
    reduce<T>(reducer: unknown, accumulator: T): T;
    either<T>(left: Mapper<L, T>): T;
    get(): L;
    left(): Option<L>;
    right(): None;
    teeLeft(callback: Callback<L>): Left<L>;
    teeRight(): Left<L>;
    equals<L>(value: Left<L>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Iterator<L>;
    toJSON(): Left.JSON<L>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Left {
    interface JSON<L> {
        [key: string]: json.JSON;
        type: "left";
        value: Serializable.ToJSON<L>;
    }
    function isLeft<L>(value: Iterable<L>): value is Left<L>;
    function isLeft<L>(value: unknown): value is Left<L>;
}
//# sourceMappingURL=left.d.ts.map