import type { Applicative } from "@siteimprove/alfa-applicative";
import type { Functor } from "@siteimprove/alfa-functor";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Monad } from "@siteimprove/alfa-monad";
import { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Result } from "@siteimprove/alfa-result";
import type * as json from "@siteimprove/alfa-json";
import { Diagnostic } from "./diagnostic.js";
/**
 * @public
 * * TYPE is a (JavaScript manipulable) representation of the expected type of
 *   answers. It allows oracles and such to act on it. It can be an Enum, an ID,
 *   a union of string literals, â€¦
 * * SUBJECT is the subject of the question.
 * * CONTEXT is the context, some extra info added to help the subject make sense.
 *   By convention, the context is *always* the test target (or potential test
 *   target when questions are asked in Applicability).
 * * ANSWER is the expected type of the answer.
 * * T is the final result of the question, after transformation. This gives a
 *   monadic structure to the question and allow manipulation of the answer
 *   without breaking the Question structure.
 * * URI is a unique identifier for the question.
 */
export declare class Question<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string> implements Functor<T>, Applicative<T>, Monad<T>, Serializable<Question.JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI>> {
    static of<TYPE, SUBJECT, CONTEXT, ANSWER, URI extends string = string>(type: TYPE, uri: URI, message: string, subject: SUBJECT, context: CONTEXT, options?: Question.Options<ANSWER>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, ANSWER, URI>;
    protected readonly _type: TYPE;
    protected readonly _uri: URI;
    protected readonly _message: string;
    protected readonly _diagnostic: Diagnostic;
    protected readonly _fallback: Option<ANSWER>;
    protected readonly _subject: SUBJECT;
    protected readonly _context: CONTEXT;
    protected readonly _quester: Mapper<ANSWER, T>;
    protected constructor(type: TYPE, uri: URI, message: string, diagnostic: Diagnostic, fallback: Option<ANSWER>, subject: SUBJECT, context: CONTEXT, quester: Mapper<ANSWER, T>);
    get type(): TYPE;
    get uri(): URI;
    get message(): string;
    get diagnostic(): Diagnostic;
    get fallback(): Option<ANSWER>;
    get subject(): SUBJECT;
    get context(): CONTEXT;
    isRhetorical(): this is Question.Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, T>;
    answer(answer: ANSWER): T;
    answerIf(condition: boolean, answer: ANSWER): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    answerIf(predicate: Predicate<SUBJECT, [context: CONTEXT]>, answer: ANSWER): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    answerIf(answer: Option<ANSWER>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    answerIf(answer: Result<ANSWER, Diagnostic>, merger?: Mapper<Diagnostic, Diagnostic, [Diagnostic]>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    answerIf(answer: Result<ANSWER, unknown>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    map<U>(mapper: Mapper<T, U>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    apply<U>(mapper: Question<TYPE, SUBJECT, CONTEXT, ANSWER, Mapper<T, U>, URI>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    flatMap<U>(mapper: Mapper<T, Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    flatten<TYPE, SUBJECT, CONTEXT, ANSWER, T>(this: Question<TYPE, SUBJECT, CONTEXT, ANSWER, Question<TYPE, SUBJECT, CONTEXT, ANSWER, T>>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T>;
    toJSON(options?: Serializable.Options): Question.JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI>;
}
/**
 * @public
 */
export declare namespace Question {
    interface JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI extends string = string> {
        [key: string]: json.JSON;
        type: Serializable.ToJSON<TYPE>;
        uri: URI;
        message: string;
        diagnostic: Diagnostic.JSON;
        fallback: Option.JSON<ANSWER>;
        subject: Serializable.ToJSON<SUBJECT>;
        context: Serializable.ToJSON<CONTEXT>;
    }
    type Metadata = {
        [uri: string]: [unknown, unknown];
    };
    function isQuestion<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string>(value: unknown): value is Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    /**
     * A rhetorical question is a special type of question in which the answer is
     * part of the question itself. This is useful for cases where the answer to
     * a question may optionally be given by the entity asking the question. This
     * means that a question can be conditionally answered while still retaining
     * its monadic structure as the question isn't unwrapped to its answer.
     *
     * @internal
     */
    class Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string> extends Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI> {
        private readonly _answer;
        constructor(type: TYPE, uri: URI, message: string, diagnostic: Diagnostic, subject: SUBJECT, context: CONTEXT, answer: T);
        answer(): T;
        /**
         * @remarks
         * Overriding {@link (Question:class).map} ensures that the answer to a
         * rhetorical question is not lost as the question is transformed.
         */
        map<U>(mapper: Mapper<T, U>): Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    }
    interface Options<A> {
        readonly fallback?: Option<A>;
        readonly diagnostic?: Diagnostic;
    }
}
//# sourceMappingURL=question.d.ts.map