import { Array } from "@siteimprove/alfa-array";
import { Left, Right } from "@siteimprove/alfa-either";
import { Future } from "@siteimprove/alfa-future";
import { Iterable } from "@siteimprove/alfa-iterable";
import { List } from "@siteimprove/alfa-list";
import { Maybe, None } from "@siteimprove/alfa-option";
import { Record } from "@siteimprove/alfa-record";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Tuple } from "@siteimprove/alfa-tuple";
import * as json from "@siteimprove/alfa-json";
import { Cache } from "./cache.js";
import { Interview } from "./interview.js";
import { Outcome } from "./outcome.js";
import { Requirement } from "./requirement.js";
import { Tag } from "./tag.js";
const { flatten, reduce } = Iterable;
/**
 * @public
 * * I: type of Input for the rule
 * * T: type of the test targets
 * * Q: questions' metadata type
 * * S: possible types of questions' subject.
 */
export class Rule {
    _uri;
    _requirements;
    _tags;
    _evaluate;
    constructor(uri, requirements, tags, evaluator) {
        this._uri = uri;
        this._requirements = requirements;
        this._tags = tags;
        this._evaluate = evaluator;
    }
    get uri() {
        return this._uri;
    }
    get requirements() {
        return this._requirements;
    }
    get tags() {
        return this._tags;
    }
    hasRequirement(requirementOrPredicate) {
        const predicate = Requirement.isRequirement(requirementOrPredicate)
            ? (requirement) => requirementOrPredicate.equals(requirement)
            : requirementOrPredicate;
        return Array.some(this._requirements, predicate);
    }
    hasTag(tagOrPredicate) {
        const predicate = Tag.isTag(tagOrPredicate)
            ? (tag) => tagOrPredicate.equals(tag)
            : tagOrPredicate;
        return Array.some(this._tags, predicate);
    }
    evaluate(input, 
    // A rule asking no questions, never calls its oracle, so it can be anything
    oracle = () => Future.now(None), outcomes = Cache.empty(), performance) {
        return this._evaluate(input, oracle, outcomes, performance);
    }
    equals(value) {
        return value instanceof Rule && value._uri === this._uri;
    }
    hash(hash) {
        hash.writeString(this._uri);
    }
    toEARL() {
        return {
            "@context": {
                earl: "http://www.w3.org/ns/earl#",
                dct: "http://purl.org/dc/terms/",
            },
            "@type": ["earl:TestCriterion", "earl:TestCase"],
            "@id": this._uri,
            "dct:isPartOf": {
                "@set": this._requirements.map((requirement) => requirement.toEARL()),
            },
        };
    }
    toSARIF() {
        return {
            id: this._uri,
            helpUri: this._uri,
        };
    }
}
/**
 * @public
 */
(function (Rule) {
    const { Applicable } = Outcome;
    function isRule(value) {
        return value instanceof Rule;
    }
    Rule.isRule = isRule;
    class Atomic extends Rule {
        static of(properties) {
            return new Atomic(properties.uri, Array.from(properties.requirements ?? []), Array.from(properties.tags ?? []), properties.evaluate);
        }
        constructor(uri, requirements, tags, evaluate) {
            super(uri, requirements, tags, (input, oracle, outcomes, performance) => outcomes.get(this, () => {
                const startRule = performance?.mark(Event.start(this)).start;
                // In the evaluate function in Atomic.of, "this" is not yet build.
                // So we need a helper to wrap it…
                const rulePerformance = performance !== undefined
                    ? {
                        mark: (name) => performance?.mark(Event.start(this, name)),
                        measure: (name, start) => performance?.measure(Event.end(this, name), start),
                    }
                    : undefined;
                const { applicability, expectations } = evaluate(input, rulePerformance);
                const startApplicability = performance?.mark(Event.startApplicability(this)).start;
                let startExpectation;
                return Future.traverse(applicability(), (interview) => Interview.conduct(interview, this, oracle).map((target) => target.either(
                // We have a target, wrap it properly and return it.
                ([target, oracleUsed]) => Tuple.of(Maybe.toOption(target), oracleUsed), 
                // We have an unanswered question and return None
                ([_, oracleUsed]) => Tuple.of(None, oracleUsed))))
                    .map((targets) => 
                // We both need to keep with each target whether the oracle was used,
                // and with the global sequence whether it was used at all.
                // The second case is needed to decide whether the oracle was used
                // when producing an Inapplicable result (empty sequence).
                // None are cleared from the sequence, and Some are opened to only
                // keep the targets.
                //
                // For efficiency, we prepend the targets and reverse the full
                // sequence later to conserve the order.
                // This result in a O(n) rather than O(n²) process.
                Sequence.from(targets).reduce(([acc, wasUsed], [cur, isUsed]) => Tuple.of(cur.isSome()
                    ? acc.prepend(Tuple.of(cur.get(), isUsed))
                    : acc, wasUsed || isUsed), Tuple.of(Sequence.empty(), false)))
                    .tee(() => {
                    performance?.measure(Event.endApplicability(this), startApplicability);
                    startExpectation = performance?.mark(Event.startExpectation(this)).start;
                })
                    .flatMap(([targets, oracleUsed]) => {
                    if (targets.isEmpty()) {
                        return Future.now([
                            Outcome.Inapplicable.of(this, getMode(oracleUsed)),
                        ]);
                    }
                    return Future.traverse(
                    // Since targets were prepended when Applicability was processed,
                    // we now need to reverse the sequence to restore initial order.
                    targets.reverse(), ([target, oracleUsedInApplicability]) => resolve(target, Record.of(expectations(target)), this, oracle, oracleUsedInApplicability)).tee(() => {
                        performance?.measure(Event.endExpectation(this), startExpectation);
                    });
                })
                    .tee(() => {
                    performance?.measure(Event.end(this), startRule);
                });
            }));
        }
        toJSON(options) {
            return options?.verbosity === json.Serializable.Verbosity.Minimal
                ? { uri: this._uri }
                : {
                    type: "atomic",
                    uri: this._uri,
                    requirements: this._requirements.map((requirement) => requirement.toJSON()),
                    tags: this._tags.map((tag) => tag.toJSON()),
                };
        }
    }
    Rule.Atomic = Atomic;
    (function (Atomic) {
        function isAtomic(value) {
            return value instanceof Atomic;
        }
        Atomic.isAtomic = isAtomic;
    })(Atomic = Rule.Atomic || (Rule.Atomic = {}));
    Rule.isAtomic = Atomic.isAtomic;
    class Composite extends Rule {
        static of(properties) {
            return new Composite(properties.uri, Array.from(properties.requirements ?? []), Array.from(properties.tags ?? []), Array.from(properties.composes), properties.evaluate);
        }
        _composes;
        constructor(uri, requirements, tags, composes, evaluate) {
            super(uri, requirements, tags, (input, oracle, outcomes, performance) => outcomes.get(this, () => {
                const startRule = performance?.mark(Event.start(this)).start;
                // In the evaluate function in Atomic.of, "this" is not yet build.
                // So we need a helper to wrap it…
                const rulePerformance = performance !== undefined
                    ? {
                        mark: (name) => performance?.mark(Event.start(this, name)),
                        measure: (name, start) => performance?.measure(Event.end(this, name), start),
                    }
                    : undefined;
                return Future.traverse(this._composes, (rule) => rule.evaluate(input, oracle, outcomes, performance))
                    .map((outcomes) => 
                // We both need to keep with each outcome whether the oracle was used,
                // and with the global sequence whether it was used at all.
                // The second case is needed to decide whether the oracle was used
                // when producing an Inapplicable result (empty sequence).
                // Inapplicable outcomes one are cleared from the sequence.
                //
                // For efficiency, we prepend the targets and reverse the full
                // sequence later to conserve the order.
                // This result in a O(n) rather than O(n²) process.
                Sequence.from(flatten(outcomes)).reduce(([acc, wasUsed], outcome) => Tuple.of(Applicable.isApplicable(outcome)
                    ? acc.prepend(outcome)
                    : acc, wasUsed || outcome.isSemiAuto), Tuple.of(Sequence.empty(), false)))
                    .flatMap(([targets, oracleUsed]) => {
                    if (targets.isEmpty()) {
                        return Future.now([
                            Outcome.Inapplicable.of(this, getMode(oracleUsed)),
                        ]);
                    }
                    const { expectations } = evaluate(input, rulePerformance);
                    return Future.traverse(
                    // Since targets were prepended when Applicability was processed,
                    // we now need to reverse the sequence to restore initial order.
                    targets.reverse().groupBy((outcome) => outcome.target), ([target, outcomes]) => resolve(target, Record.of(expectations(outcomes)), this, oracle, oracleUsed));
                })
                    .tee(() => {
                    performance?.measure(Event.end(this), startRule);
                });
            }));
            this._composes = composes;
        }
        get composes() {
            return this._composes;
        }
        toJSON(options) {
            return options?.verbosity === json.Serializable.Verbosity.Minimal
                ? { uri: this._uri }
                : {
                    type: "composite",
                    uri: this._uri,
                    requirements: this._requirements.map((requirement) => requirement.toJSON()),
                    tags: this._tags.map((tag) => tag.toJSON()),
                    composes: this._composes.map((rule) => rule.toJSON(options)),
                };
        }
    }
    Rule.Composite = Composite;
    (function (Composite) {
        function isComposite(value) {
            return value instanceof Composite;
        }
        Composite.isComposite = isComposite;
    })(Composite = Rule.Composite || (Rule.Composite = {}));
    Rule.isComposite = Composite.isComposite;
    /**
     * @public
     */
    class Event {
        static of(type, rule, name) {
            return new Event(type, rule, name);
        }
        _type;
        _rule;
        _name;
        constructor(type, rule, name) {
            this._type = type;
            this._rule = rule;
            this._name = name;
        }
        get type() {
            return this._type;
        }
        get rule() {
            return this._rule;
        }
        get name() {
            return this._name;
        }
        toJSON() {
            return {
                type: this._type,
                rule: this._rule.toJSON(),
                name: this._name,
            };
        }
    }
    Rule.Event = Event;
    /**
     * @public
     */
    (function (Event) {
        function isEvent(value) {
            return value instanceof Event;
        }
        Event.isEvent = isEvent;
        function start(rule, name = "total") {
            return Event.of("start", rule, name);
        }
        Event.start = start;
        function end(rule, name = "total") {
            return Event.of("end", rule, name);
        }
        Event.end = end;
        function startApplicability(rule) {
            return Event.of("start", rule, "applicability");
        }
        Event.startApplicability = startApplicability;
        function endApplicability(rule) {
            return Event.of("end", rule, "applicability");
        }
        Event.endApplicability = endApplicability;
        function startExpectation(rule) {
            return Event.of("start", rule, "expectation");
        }
        Event.startExpectation = startExpectation;
        function endExpectation(rule) {
            return Event.of("end", rule, "expectation");
        }
        Event.endExpectation = endExpectation;
    })(Event = Rule.Event || (Rule.Event = {}));
})(Rule || (Rule = {}));
// Processes the expectations of the results of an interview.
// When the result is Passed/Failed (Left), we accumulate the expectations that are later on passed to the Outcome.
// When we encounter the first Diagnostic result of a cantTell (Right),
// the processing stops and later it is passed to the cantTell Outcome.
function processExpectation(acc, [id, expectation]) {
    return acc.either(
    // The accumulator only contains true result, keep going.
    ([accumulator, oracleUsedAccumulator]) => expectation.either(
    // The current result is defined, accumulate.
    ([result, oracleUsed]) => Left.of(Tuple.of(accumulator.append([id, Maybe.toOption(result)]), oracleUsedAccumulator || oracleUsed)), 
    // The current result is cantTell, abort.
    ([diagnostic, oracleUsed]) => Right.of(Tuple.of(diagnostic, oracleUsedAccumulator || oracleUsed))), 
    // The accumulator already contains cantTell, skip.
    // Note that we only keep the mode of the first Expectation that cannot tell,
    // which is likely OK.
    () => acc);
}
function resolve(target, expectations, rule, 
// A rule asking no questions, never calls its oracle, so it can be anything
oracle, oracleUsedInApplicability) {
    return Future.traverse(expectations, ([id, interview]) => Interview.conduct(interview, rule, oracle).map((expectation) => [id, expectation]))
        .map((expectations) => reduce(expectations, processExpectation, Left.of(Tuple.of(List.empty(), oracleUsedInApplicability))))
        .map((expectation) => expectation.either(([expectations, oracleUsed]) => Outcome.from(rule, target, Record.from(expectations), getMode(oracleUsed)), ([diagnostic, oracleUsed]) => Outcome.CantTell.of(rule, target, diagnostic, getMode(oracleUsed))));
}
function getMode(oracleUsed) {
    return oracleUsed ? Outcome.Mode.SemiAuto : Outcome.Mode.Automatic;
}
//# sourceMappingURL=rule.js.map