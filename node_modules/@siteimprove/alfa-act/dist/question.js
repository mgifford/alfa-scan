import { Serializable } from "@siteimprove/alfa-json";
import { None, Option } from "@siteimprove/alfa-option";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Diagnostic } from "./diagnostic.js";
const { isOption } = Option;
const { isBoolean, isFunction } = Refinement;
/**
 * @public
 * * TYPE is a (JavaScript manipulable) representation of the expected type of
 *   answers. It allows oracles and such to act on it. It can be an Enum, an ID,
 *   a union of string literals, â€¦
 * * SUBJECT is the subject of the question.
 * * CONTEXT is the context, some extra info added to help the subject make sense.
 *   By convention, the context is *always* the test target (or potential test
 *   target when questions are asked in Applicability).
 * * ANSWER is the expected type of the answer.
 * * T is the final result of the question, after transformation. This gives a
 *   monadic structure to the question and allow manipulation of the answer
 *   without breaking the Question structure.
 * * URI is a unique identifier for the question.
 */
export class Question {
    static of(type, uri, message, subject, context, options = {}) {
        const { fallback = None, diagnostic = Diagnostic.empty } = options;
        return new Question(type, uri, message, diagnostic, fallback, subject, context, (answer) => answer);
    }
    _type;
    _uri;
    _message;
    _diagnostic;
    _fallback;
    _subject;
    _context;
    _quester;
    constructor(type, uri, message, diagnostic, fallback, subject, context, quester) {
        this._type = type;
        this._uri = uri;
        this._message = message;
        this._diagnostic = diagnostic;
        this._fallback = fallback;
        this._subject = subject;
        this._context = context;
        this._quester = quester;
    }
    get type() {
        return this._type;
    }
    get uri() {
        return this._uri;
    }
    get message() {
        return this._message;
    }
    get diagnostic() {
        return this._diagnostic;
    }
    get fallback() {
        return this._fallback;
    }
    get subject() {
        return this._subject;
    }
    get context() {
        return this._context;
    }
    isRhetorical() {
        return this instanceof Question.Rhetorical;
    }
    answer(answer) {
        return this._quester(answer);
    }
    answerIf(conditionOrPredicateOrAnswer, answerOrMerger) {
        let condition = false;
        let answer;
        let diagnostic = this._diagnostic;
        if (isBoolean(conditionOrPredicateOrAnswer)) {
            condition = conditionOrPredicateOrAnswer;
            // Type is enforced by overload.
            answer = answerOrMerger;
        }
        else if (isFunction(conditionOrPredicateOrAnswer)) {
            condition = conditionOrPredicateOrAnswer(this._subject, this._context);
            // Type is enforced by overload.
            answer = answerOrMerger;
        }
        else if (isOption(conditionOrPredicateOrAnswer)) {
            if (conditionOrPredicateOrAnswer.isSome()) {
                condition = true;
                answer = conditionOrPredicateOrAnswer.get();
            }
        }
        else {
            // Result
            condition = conditionOrPredicateOrAnswer.isOk();
            if (condition) {
                // the check ensures that the result is Ok
                answer = conditionOrPredicateOrAnswer.getUnsafe();
            }
            else {
                // since the condition is false, we know the result is an Err
                const error = conditionOrPredicateOrAnswer.getErrUnsafe();
                if (Diagnostic.isDiagnostic(error)) {
                    // Type is enforced by overload.
                    const merger = answerOrMerger ??
                        // Default is to overwrite the old diagnostic
                        ((old, cur) => cur);
                    diagnostic = merger(diagnostic, error);
                }
            }
        }
        return condition
            ? new Question.Rhetorical(this._type, this._uri, this._message, this._diagnostic, this._subject, this._context, this.answer(answer))
            : new Question(this._type, this._uri, this._message, diagnostic, this._fallback, this._subject, this._context, this._quester);
    }
    map(mapper) {
        return new Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => mapper(this._quester(answer)));
    }
    apply(mapper) {
        return mapper.flatMap((mapper) => this.map(mapper));
    }
    flatMap(mapper) {
        return new Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => mapper(this._quester(answer))._quester(answer));
    }
    flatten() {
        return new Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => this._quester(answer)._quester(answer));
    }
    toJSON(options) {
        return {
            type: Serializable.toJSON(this._type, options),
            uri: this._uri,
            message: this._message,
            diagnostic: this._diagnostic.toJSON(options),
            fallback: this._fallback.toJSON(options),
            subject: Serializable.toJSON(this._subject, options),
            context: Serializable.toJSON(this._context, options),
        };
    }
}
/**
 * @public
 */
(function (Question) {
    function isQuestion(value) {
        return value instanceof Question;
    }
    Question.isQuestion = isQuestion;
    /**
     * A rhetorical question is a special type of question in which the answer is
     * part of the question itself. This is useful for cases where the answer to
     * a question may optionally be given by the entity asking the question. This
     * means that a question can be conditionally answered while still retaining
     * its monadic structure as the question isn't unwrapped to its answer.
     *
     * @internal
     */
    class Rhetorical extends Question {
        _answer;
        constructor(type, uri, message, diagnostic, subject, context, answer) {
            super(type, uri, message, diagnostic, None, subject, context, () => answer);
            this._answer = answer;
        }
        answer() {
            return this._answer;
        }
        /**
         * @remarks
         * Overriding {@link (Question:class).map} ensures that the answer to a
         * rhetorical question is not lost as the question is transformed.
         */
        map(mapper) {
            return new Rhetorical(this._type, this._uri, this._message, this._diagnostic, this._subject, this._context, mapper(this._answer));
        }
    }
    Question.Rhetorical = Rhetorical;
})(Question || (Question = {}));
//# sourceMappingURL=question.js.map