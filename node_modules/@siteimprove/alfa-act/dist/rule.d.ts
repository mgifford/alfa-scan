import { Array } from "@siteimprove/alfa-array";
import type { Equatable } from "@siteimprove/alfa-equatable";
import { Future } from "@siteimprove/alfa-future";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Maybe } from "@siteimprove/alfa-option";
import type { Performance } from "@siteimprove/alfa-performance";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Result } from "@siteimprove/alfa-result";
import { Sequence } from "@siteimprove/alfa-sequence";
import type * as earl from "@siteimprove/alfa-earl";
import * as json from "@siteimprove/alfa-json";
import type * as sarif from "@siteimprove/alfa-sarif";
import { Cache } from "./cache.js";
import type { Diagnostic } from "./diagnostic.js";
import { Interview } from "./interview.js";
import type { Oracle } from "./oracle.js";
import { Outcome } from "./outcome.js";
import type { Question } from "./question.js";
import { Requirement } from "./requirement.js";
import { Tag } from "./tag.js";
/**
 * @public
 * * I: type of Input for the rule
 * * T: type of the test targets
 * * Q: questions' metadata type
 * * S: possible types of questions' subject.
 */
export declare abstract class Rule<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> implements Equatable, Hashable, json.Serializable<Rule.JSON>, earl.Serializable<Rule.EARL>, sarif.Serializable<sarif.ReportingDescriptor> {
    protected readonly _uri: string;
    protected readonly _requirements: Array<Requirement>;
    protected readonly _tags: Array<Tag>;
    protected readonly _evaluate: Rule.Evaluate<I, T, Q, S>;
    protected constructor(uri: string, requirements: Array<Requirement>, tags: Array<Tag>, evaluator: Rule.Evaluate<I, T, Q, S>);
    get uri(): string;
    get requirements(): ReadonlyArray<Requirement>;
    get tags(): ReadonlyArray<Tag>;
    hasRequirement(requirement: Requirement): boolean;
    hasRequirement(predicate: Predicate<Requirement>): boolean;
    hasTag(tag: Tag): boolean;
    hasTag(predicate: Predicate<Tag>): boolean;
    evaluate(input: I, oracle?: {} extends Q ? any : Oracle<I, T, Q, S>, outcomes?: Cache, performance?: Performance<Rule.Event<I, T, Q, S>>): Future<Iterable<Outcome<I, T, Q, S>>>;
    equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Rule<I, T, Q, S>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    abstract toJSON(options: {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Rule.MinimalJSON;
    abstract toJSON(): Rule.JSON;
    abstract toJSON(options?: json.Serializable.Options): Rule.MinimalJSON | Rule.JSON;
    toEARL(): Rule.EARL;
    toSARIF(): sarif.ReportingDescriptor;
}
/**
 * @public
 */
export declare namespace Rule {
    interface MinimalJSON {
        [key: string]: json.JSON;
        uri: string;
    }
    interface JSON {
        [key: string]: json.JSON;
        type: string;
        uri: string;
        requirements: Array<Requirement.JSON>;
        tags: Array<Tag.JSON>;
    }
    interface EARL extends earl.EARL {
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        "@type": ["earl:TestCriterion", "earl:TestCase"];
        "@id": string;
        "dct:isPartOf": {
            "@set": Array<Requirement.EARL>;
        };
    }
    type Input<R> = R extends Rule<infer I, any, any, any> ? I : never;
    type Target<R> = R extends Rule<any, infer T, any, any> ? T : never;
    type Question<R> = R extends Rule<any, any, infer Q, any> ? Q : never;
    type Subject<R> = R extends Rule<any, any, any, infer S> ? S : never;
    function isRule<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Rule<I, T, Q, S>;
    /**
     * @remarks
     * We use a short-lived cache during audits for rules to store their outcomes.
     * It effectively acts as a memoization layer on top of each rule evaluation
     * procedure, which comes in handy when dealing with composite rules that are
     * dependant on the outcomes of other rules. There are several ways in which
     * audits of such rules can be performed:
     *
     * 1. Put the onus on the caller to construct an audit with dependency-ordered
     *    rules. This is just crazy.
     *
     * 2. Topologically sort rules based on their dependencies before performing
     *    an audit. This requires graph operations.
     *
     * 3. Disregard order entirely and simply run rule evaluation procedures as
     *    their outcomes are needed, thereby risking repeating some of these
     *    procedures. This requires nothing.
     *
     * Given that 3. is the simpler, and non-crazy, approach, we can use this
     * approach in combination with memoization to avoid the risk of repeating
     * rule evaluation procedures.
     */
    interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
        (input: Readonly<I>, oracle: {} extends Q ? any : Oracle<I, T, Q, S>, outcomes: Cache, performance?: Performance<Event<I, T, Q, S>>): Future<Iterable<Outcome<I, T, Q, S>>>;
    }
    class Atomic<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Rule<I, T, Q, S> {
        static of<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(properties: {
            uri: string;
            requirements?: Iterable<Requirement>;
            tags?: Iterable<Tag>;
            evaluate: Atomic.Evaluate<I, T, Q, S>;
        }): Atomic<I, T, Q, S>;
        protected constructor(uri: string, requirements: Array<Requirement>, tags: Array<Tag>, evaluate: Atomic.Evaluate<I, T, Q, S>);
        toJSON(options: {
            verbosity: json.Serializable.Verbosity.Minimal;
        }): Rule.MinimalJSON;
        toJSON(): Atomic.JSON;
    }
    namespace Atomic {
        interface JSON extends Rule.JSON {
            type: "atomic";
        }
        interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
            (input: I, performance?: {
                mark: (name: string) => Performance.Mark<Event<I, T, Q, S>>;
                measure: (name: string, start?: number) => Performance.Measure<Event<I, T, Q, S>>;
            }): {
                applicability(): Iterable<Interview<Q, S, T, Maybe<T>>>;
                expectations(target: T): {
                    [key: string]: Interview<Q, S, T, Maybe<Result<Diagnostic>>>;
                };
            };
        }
        function isAtomic<I, T extends Hashable, Q extends Question.Metadata, S>(value: Rule<I, T, Q, S>): value is Atomic<I, T, Q, S>;
        function isAtomic<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Atomic<I, T, Q, S>;
    }
    const isAtomic: typeof Atomic.isAtomic;
    class Composite<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Rule<I, T, Q, S> {
        static of<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(properties: {
            uri: string;
            requirements?: Iterable<Requirement>;
            tags?: Iterable<Tag>;
            composes: Iterable<Rule<I, T, Q, S>>;
            evaluate: Composite.Evaluate<I, T, Q, S>;
        }): Composite<I, T, Q, S>;
        private readonly _composes;
        protected constructor(uri: string, requirements: Array<Requirement>, tags: Array<Tag>, composes: Array<Rule<I, T, Q, S>>, evaluate: Composite.Evaluate<I, T, Q, S>);
        get composes(): ReadonlyArray<Rule<I, T, Q, S>>;
        toJSON(options: {
            verbosity: json.Serializable.Verbosity.Minimal;
        }): Rule.MinimalJSON;
        toJSON(): Composite.JSON;
    }
    namespace Composite {
        interface JSON extends Rule.JSON {
            type: "composite";
            uri: string;
            composes: Array<Rule.JSON>;
        }
        interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
            (input: I, performance?: {
                mark: (name: string) => Performance.Mark<Event<I, T, Q, S>>;
                measure: (name: string, start?: number) => Performance.Measure<Event<I, T, Q, S>>;
            }): {
                expectations(outcomes: Sequence<Outcome.Applicable<I, T, Q, S>>): {
                    [key: string]: Interview<Q, S, T, Maybe<Result<Diagnostic>>>;
                };
            };
        }
        function isComposite<I, T extends Hashable, Q extends Question.Metadata>(value: Rule<I, T, Q>): value is Composite<I, T, Q>;
        function isComposite<I, T extends Hashable, Q extends Question.Metadata>(value: unknown): value is Composite<I, T, Q>;
    }
    const isComposite: typeof Composite.isComposite;
    /**
     * @public
     */
    class Event<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type = Event.Type, NAME extends string = string> implements Serializable<Event.JSON<TYPE, NAME>> {
        static of<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type, NAME extends string>(type: TYPE, rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, name: NAME): Event<INPUT, TARGET, QUESTION, SUBJECT, TYPE, NAME>;
        private readonly _type;
        private readonly _rule;
        private readonly _name;
        constructor(type: TYPE, rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, name: NAME);
        get type(): TYPE;
        get rule(): Rule<INPUT, TARGET, QUESTION, SUBJECT>;
        get name(): NAME;
        toJSON(): Event.JSON<TYPE, NAME>;
    }
    /**
     * @public
     */
    namespace Event {
        type Type = "start" | "end";
        interface JSON<T extends Type = Type, N extends string = string> {
            [key: string]: json.JSON;
            type: T;
            rule: Rule.JSON;
            name: N;
        }
        function isEvent<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type = Event.Type, NAME extends string = string>(value: unknown): value is Event<INPUT, TARGET, QUESTION, SUBJECT, TYPE, NAME>;
        function start<I, T extends Hashable, Q extends Question.Metadata, S, N extends string = string>(rule: Rule<I, T, Q, S>, name: N): Event<I, T, Q, S, "start", N>;
        function start<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "total">;
        function end<I, T extends Hashable, Q extends Question.Metadata, S, N extends string = string>(rule: Rule<I, T, Q, S>, name: N): Event<I, T, Q, S, "end", N>;
        function end<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "total">;
        function startApplicability<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "applicability">;
        function endApplicability<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "applicability">;
        function startExpectation<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "expectation">;
        function endExpectation<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "expectation">;
    }
}
//# sourceMappingURL=rule.d.ts.map