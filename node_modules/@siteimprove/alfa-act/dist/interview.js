import { Future } from "@siteimprove/alfa-future";
import { Either } from "@siteimprove/alfa-either";
import { Option } from "@siteimprove/alfa-option";
import { Tuple } from "@siteimprove/alfa-tuple";
import { Question } from "./question.js";
/**
 * @public
 */
export var Interview;
(function (Interview) {
    /**
     *  Conduct an interview:
     *  * if it is an answer, just send it back;
     *  * if it is a rhetorical question, fetch its answer and recursively conduct
     *    an interview on it;
     *  * if it is a true question, ask it to the oracle and recursively conduct an
     *    interview on the result.
     *
     *  Oracles must return Options, to have the possibility to not answer a given
     *  question (by returning None).
     *  Oracles must return Futures, because the full interview process is essentially
     *  async (e.g., asking through a CLI).
     *
     *  The final result of the interview is either a final answer (Left), or
     *  a diagnostic (Right) explaining why a final answer couldn't be found.
     *  Final answer will be turned into Passed/Failed outcomes, and diagnostic
     *  into Can't tell; the diagnostic is provided by the last unanswered question.
     *
     *  In both cases, we also record whether the oracle was actually used;
     *  this is useful to record the mode (auto/semi-auto) of the outcome.
     */
    function conduct(
    // Questions' contexts are guaranteed to be (potential) test target of
    // the rule.
    interview, rule, oracle, oracleUsed = false) {
        if (interview instanceof Question) {
            let answer;
            if (interview.isRhetorical()) {
                answer = Future.now(Option.of(interview.answer()));
            }
            else {
                answer = oracle(rule, interview).map((option) => option
                    // Record that the oracle was successfully used
                    .tee((_) => (oracleUsed = true))
                    // If oracle has no answer, use fallback
                    .or(interview.fallback)
                    // Need to bind due to eta-contraction losing `this`.
                    .map(interview.answer.bind(interview)));
            }
            return answer.flatMap((answer) => answer
                // Recursively conduct an interview
                .map((answer) => conduct(answer, rule, oracle, oracleUsed))
                // If we still don't have a final answer, return the last diagnostic.
                .getOrElse(() => Future.now(Either.right(Tuple.of(interview.diagnostic, oracleUsed)))));
        }
        // The interview is not a question, so it is a final answer.
        return Future.now(Either.left(Tuple.of(interview, oracleUsed)));
    }
    Interview.conduct = conduct;
})(Interview || (Interview = {}));
//# sourceMappingURL=interview.js.map