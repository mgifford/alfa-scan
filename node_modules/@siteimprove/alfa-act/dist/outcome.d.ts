import { Equatable } from "@siteimprove/alfa-equatable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import type { Option } from "@siteimprove/alfa-option";
import { Record } from "@siteimprove/alfa-record";
import type { Result } from "@siteimprove/alfa-result";
import * as earl from "@siteimprove/alfa-earl";
import * as json from "@siteimprove/alfa-json";
import * as sarif from "@siteimprove/alfa-sarif";
import { Diagnostic } from "./diagnostic.js";
import type { Question } from "./question.js";
import type { Rule } from "./rule.js";
/**
 * @public
 * I: type of Input for the associated rule
 * T: type of the rule's test target
 * Q: questions' metadata type
 * S: possible types of questions' subject.
 * V: type of outcome value
 */
export declare abstract class Outcome<I, T extends Hashable, Q extends Question.Metadata = {}, S = T, V extends Outcome.Value = Outcome.Value> implements Equatable, Hashable, json.Serializable<Outcome.JSON<V>>, earl.Serializable<Outcome.EARL>, sarif.Serializable<sarif.Result> {
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    private readonly _outcome;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    protected readonly _rule: Rule<I, T, Q, S>;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    protected readonly _mode: Outcome.Mode;
    protected constructor(outcome: V, rule: Rule<I, T, Q, S>, mode: Outcome.Mode);
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    get outcome(): V;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    get rule(): Rule<I, T, Q, S>;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    get mode(): Outcome.Mode;
    get isSemiAuto(): boolean;
    get target(): T | undefined;
    equals<I, T extends Hashable, Q extends Question.Metadata, S, V extends Outcome.Value = Outcome.Value>(value: Outcome<I, T, Q, S, V>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: json.Serializable.Options): Outcome.JSON<V>;
    toEARL(): Outcome.EARL;
    abstract toSARIF(): sarif.Result;
}
/**
 * @public
 */
export declare namespace Outcome {
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#OutcomeValue}
     *
     * @internal
     */
    enum Value {
        Inapplicable = "inapplicable",
        Passed = "passed",
        Failed = "failed",
        CantTell = "cantTell"
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#TestMode}
     */
    enum Mode {
        Automatic = "automatic",
        SemiAuto = "semiAuto",
        Manual = "manual"
    }
    interface JSON<V extends Value = Value> {
        [key: string]: json.JSON;
        outcome: V;
        rule: Rule.MinimalJSON | Rule.JSON;
        mode: Mode;
    }
    interface EARL extends earl.EARL {
        "@type": "earl:Assertion";
        "earl:mode": `earl:${Mode}`;
        "earl:test": {
            "@id": string;
        };
    }
    class Passed<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Passed> {
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode): Passed<I, T, Q, S>;
        private readonly _target;
        private readonly _expectations;
        protected constructor(rule: Rule<I, T, Q, S>, target: T, expectations: Record<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode);
        get target(): T;
        get expectations(): Record<{
            [key: string]: Result<Diagnostic>;
        }>;
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Passed<I, T, Q, S>): boolean;
        equals(value: unknown): value is this;
        hash(hash: Hash): void;
        toJSON(options?: json.Serializable.Options): Passed.JSON<T>;
        toEARL(): Passed.EARL;
        toSARIF(): sarif.Result;
    }
    namespace Passed {
        interface JSON<T> extends Outcome.JSON<Value.Passed> {
            [key: string]: json.JSON;
            target: json.Serializable.ToJSON<T>;
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
        }
        interface EARL extends Outcome.EARL {
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:passed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        function isPassed<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Passed<I, T, Q, S>;
        function isPassed<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Passed<I, T, Q, S>;
    }
    const passed: typeof Passed.of, isPassed: typeof Passed.isPassed;
    class Failed<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Failed> {
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode): Failed<I, T, Q, S>;
        private readonly _target;
        private readonly _expectations;
        protected constructor(rule: Rule<I, T, Q, S>, target: T, expectations: Record<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode);
        get target(): T;
        get expectations(): Record<{
            [key: string]: Result<Diagnostic>;
        }>;
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Failed<I, T, Q, S>): boolean;
        equals(value: unknown): value is this;
        hash(hash: Hash): void;
        toJSON(options?: json.Serializable.Options): Failed.JSON<T>;
        toEARL(): Failed.EARL;
        toSARIF(): sarif.Result;
    }
    namespace Failed {
        interface JSON<T> extends Outcome.JSON<Value.Failed> {
            [key: string]: json.JSON;
            target: json.Serializable.ToJSON<T>;
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
        }
        interface EARL extends Outcome.EARL {
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:failed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        function isFailed<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Failed<I, T, Q, S>;
        function isFailed<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Failed<I, T, Q, S>;
    }
    const failed: typeof Failed.of, isFailed: typeof Failed.isFailed;
    class CantTell<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.CantTell> {
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, diagnostic: Diagnostic, mode: Mode): CantTell<I, T, Q, S>;
        private readonly _target;
        private readonly _diagnostic;
        protected constructor(rule: Rule<I, T, Q, S>, target: T, diagnostic: Diagnostic, mode: Mode);
        get target(): T;
        get diagnostic(): Diagnostic;
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: CantTell<I, T, Q, S>): boolean;
        equals(value: unknown): value is this;
        hash(hash: Hash): void;
        toJSON(options?: json.Serializable.Options): CantTell.JSON<T>;
        toEARL(): CantTell.EARL;
        toSARIF(): sarif.Result;
    }
    namespace CantTell {
        interface JSON<T> extends Outcome.JSON<Value.CantTell> {
            [key: string]: json.JSON;
            target: json.Serializable.ToJSON<T>;
            diagnostic: json.Serializable.ToJSON<Diagnostic>;
        }
        interface EARL extends Outcome.EARL {
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:cantTell";
                };
                "earl:pointer"?: earl.EARL;
            };
        }
        function isCantTell<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is CantTell<I, T, Q, S>;
        function isCantTell<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is CantTell<I, T, Q, S>;
    }
    const cantTell: typeof CantTell.of, isCantTell: typeof CantTell.isCantTell;
    type Applicable<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> = Passed<I, T, Q, S> | Failed<I, T, Q, S> | CantTell<I, T, Q, S>;
    namespace Applicable {
        function isApplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Applicable<I, T, Q, S>;
        function isApplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Applicable<I, T, Q, S>;
    }
    const isApplicable: typeof Applicable.isApplicable;
    class Inapplicable<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Inapplicable> {
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, mode: Mode): Inapplicable<I, T, Q, S>;
        protected constructor(rule: Rule<I, T, Q, S>, mode: Mode);
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Inapplicable<I, T, Q, S>): boolean;
        equals(value: unknown): value is this;
        toJSON(options?: json.Serializable.Options): Inapplicable.JSON;
        toEARL(): Inapplicable.EARL;
        toSARIF(): sarif.Result;
    }
    namespace Inapplicable {
        interface JSON extends Outcome.JSON<Value.Inapplicable> {
        }
        interface EARL extends Outcome.EARL {
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:inapplicable";
                };
            };
        }
        function isInapplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Inapplicable<I, T, Q, S>;
        function isInapplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Inapplicable<I, T, Q, S>;
    }
    const inapplicable: typeof Inapplicable.of, isInapplicable: typeof Inapplicable.isInapplicable;
    function from<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record<{
        [key: string]: Option<Result<Diagnostic>>;
    }>, mode: Mode): Outcome.Applicable<I, T, Q, S>;
}
//# sourceMappingURL=outcome.d.ts.map