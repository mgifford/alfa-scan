import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Record } from "@siteimprove/alfa-record";
import { Err } from "@siteimprove/alfa-result";
import { Trilean } from "@siteimprove/alfa-trilean";
import * as earl from "@siteimprove/alfa-earl";
import * as json from "@siteimprove/alfa-json";
import * as sarif from "@siteimprove/alfa-sarif";
import { Diagnostic } from "./diagnostic.js";
/**
 * @public
 * I: type of Input for the associated rule
 * T: type of the rule's test target
 * Q: questions' metadata type
 * S: possible types of questions' subject.
 * V: type of outcome value
 */
export class Outcome {
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    _outcome;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    _rule;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    _mode;
    constructor(outcome, rule, mode) {
        this._outcome = outcome;
        this._rule = rule;
        this._mode = mode;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    get outcome() {
        return this._outcome;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    get rule() {
        return this._rule;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    get mode() {
        return this._mode;
    }
    get isSemiAuto() {
        return this._mode === Outcome.Mode.SemiAuto;
    }
    get target() {
        return undefined;
    }
    equals(value) {
        return (value instanceof Outcome &&
            value._rule.equals(this._rule) &&
            value._outcome === this._outcome &&
            value._mode === this._mode);
    }
    hash(hash) {
        this._rule.hash(hash);
        hash.writeString(this._outcome);
        hash.writeString(this._mode);
    }
    toJSON(options) {
        return {
            outcome: this._outcome,
            rule: this._rule.toJSON(options),
            mode: this._mode,
        };
    }
    toEARL() {
        return {
            "@context": {
                earl: "http://www.w3.org/ns/earl#",
            },
            "@type": "earl:Assertion",
            "earl:mode": `earl:${this._mode}`,
            "earl:test": {
                "@id": this._rule.uri,
            },
        };
    }
}
/**
 * @public
 */
(function (Outcome) {
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#OutcomeValue}
     *
     * @internal
     */
    let Value;
    (function (Value) {
        Value["Inapplicable"] = "inapplicable";
        Value["Passed"] = "passed";
        Value["Failed"] = "failed";
        Value["CantTell"] = "cantTell";
    })(Value = Outcome.Value || (Outcome.Value = {}));
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#TestMode}
     */
    let Mode;
    (function (Mode) {
        Mode["Automatic"] = "automatic";
        Mode["SemiAuto"] = "semiAuto";
        Mode["Manual"] = "manual";
    })(Mode = Outcome.Mode || (Outcome.Mode = {}));
    class Passed extends Outcome {
        static of(rule, target, expectations, mode) {
            return new Passed(rule, target, expectations, mode);
        }
        _target;
        _expectations;
        constructor(rule, target, expectations, mode) {
            super(Value.Passed, rule, mode);
            this._target = target;
            this._expectations = Record.from(expectations.toArray());
        }
        get target() {
            return this._target;
        }
        get expectations() {
            return this._expectations;
        }
        equals(value) {
            return (super.equals(value) &&
                value instanceof Passed &&
                Equatable.equals(value._target, this._target) &&
                value._expectations.equals(this._expectations));
        }
        hash(hash) {
            super.hash(hash);
            this._target.hash(hash);
            for (const [id, result] of this._expectations) {
                hash.writeString(id);
                result.hash(hash);
            }
        }
        toJSON(options) {
            return {
                ...super.toJSON(options),
                target: json.Serializable.toJSON(this._target, options),
                expectations: this._expectations
                    .toArray()
                    .map(([id, expectation]) => [id, expectation.toJSON(options)]),
            };
        }
        toEARL() {
            const outcome = {
                ...super.toEARL(),
                "earl:result": {
                    "@type": "earl:TestResult",
                    "earl:outcome": {
                        "@id": "earl:passed",
                    },
                    "earl:info": this._expectations
                        .toArray()
                        .reduce((message, [, expectation]) => 
                    // the outcome is passed, so all expectations should be Ok
                    message + "\n" + expectation.getUnsafe().message, "")
                        .trim(),
                },
            };
            for (const pointer of earl.Serializable.toEARL(this._target)) {
                outcome["earl:result"]["earl:pointer"] = pointer;
            }
            return outcome;
        }
        toSARIF() {
            const message = "The test target passes all requirements:\n\n" +
                this._expectations
                    .toArray()
                    // the outcome is passed, so all expectations should be Ok
                    .map(([, expectation]) => `- ${expectation.getUnsafe().message}`)
                    .join("\n");
            const locations = [];
            for (const location of sarif.Serializable.toSARIF(this._target)) {
                locations.push(location);
            }
            return {
                ruleId: this._rule.uri,
                kind: "pass",
                level: "none",
                message: {
                    text: message,
                    markdown: message,
                },
                locations,
            };
        }
    }
    Outcome.Passed = Passed;
    (function (Passed) {
        function isPassed(value) {
            return value instanceof Passed;
        }
        Passed.isPassed = isPassed;
    })(Passed = Outcome.Passed || (Outcome.Passed = {}));
    Outcome.passed = Passed.of, Outcome.isPassed = Passed.isPassed;
    class Failed extends Outcome {
        static of(rule, target, expectations, mode) {
            return new Failed(rule, target, expectations, mode);
        }
        _target;
        _expectations;
        constructor(rule, target, expectations, mode) {
            super(Value.Failed, rule, mode);
            this._target = target;
            this._expectations = Record.from(expectations.toArray());
        }
        get target() {
            return this._target;
        }
        get expectations() {
            return this._expectations;
        }
        equals(value) {
            return (super.equals(value) &&
                value instanceof Failed &&
                Equatable.equals(value._target, this._target) &&
                value._expectations.equals(this._expectations));
        }
        hash(hash) {
            super.hash(hash);
            this._target.hash(hash);
            for (const [id, result] of this._expectations) {
                hash.writeString(id);
                result.hash(hash);
            }
        }
        toJSON(options) {
            return {
                ...super.toJSON(options),
                target: json.Serializable.toJSON(this._target, options),
                expectations: this._expectations
                    .toArray()
                    .map(([id, expectation]) => [id, expectation.toJSON(options)]),
            };
        }
        toEARL() {
            const outcome = {
                ...super.toEARL(),
                "earl:result": {
                    "@type": "earl:TestResult",
                    "earl:outcome": {
                        "@id": "earl:failed",
                    },
                    "earl:info": this._expectations
                        .toArray()
                        .reduce((message, [, expectation]) => {
                        if (expectation.isErr()) {
                            message += "\n" + expectation.getErr().message;
                        }
                        return message;
                    }, "")
                        .trim(),
                },
            };
            for (const pointer of earl.Serializable.toEARL(this._target)) {
                outcome["earl:result"]["earl:pointer"] = pointer;
            }
            return outcome;
        }
        toSARIF() {
            const message = "The test target fails the following requirements:\n\n" +
                Iterable.join(Iterable.map(Iterable.filter(Iterable.map(this._expectations.entries(), ([, expectation]) => expectation), (Err.isErr)), (expectation) => `- ${expectation.getErr().message}`), "\n");
            const locations = [];
            for (const location of sarif.Serializable.toSARIF(this._target)) {
                locations.push(location);
            }
            return {
                ruleId: this._rule.uri,
                kind: "fail",
                level: "error",
                message: {
                    text: message,
                    markdown: message,
                },
                locations,
            };
        }
    }
    Outcome.Failed = Failed;
    (function (Failed) {
        function isFailed(value) {
            return value instanceof Failed;
        }
        Failed.isFailed = isFailed;
    })(Failed = Outcome.Failed || (Outcome.Failed = {}));
    Outcome.failed = Failed.of, Outcome.isFailed = Failed.isFailed;
    class CantTell extends Outcome {
        static of(rule, target, diagnostic, mode) {
            return new CantTell(rule, target, diagnostic, mode);
        }
        _target;
        _diagnostic;
        constructor(rule, target, diagnostic, mode) {
            super(Value.CantTell, rule, mode);
            this._target = target;
            this._diagnostic = diagnostic;
        }
        get target() {
            return this._target;
        }
        get diagnostic() {
            return this._diagnostic;
        }
        equals(value) {
            return (super.equals(value) &&
                value instanceof CantTell &&
                Equatable.equals(value._target, this._target) &&
                value._diagnostic.equals(this._diagnostic));
        }
        hash(hash) {
            super.hash(hash);
            this._target.hash(hash);
            this._diagnostic.hash(hash);
        }
        toJSON(options) {
            return {
                ...super.toJSON(options),
                target: json.Serializable.toJSON(this._target, options),
                diagnostic: this._diagnostic.toJSON(options),
            };
        }
        toEARL() {
            const outcome = {
                ...super.toEARL(),
                "earl:result": {
                    "@type": "earl:TestResult",
                    "earl:outcome": {
                        "@id": "earl:cantTell",
                    },
                },
            };
            for (const pointer of earl.Serializable.toEARL(this._target)) {
                outcome["earl:result"]["earl:pointer"] = pointer;
            }
            return outcome;
        }
        toSARIF() {
            const message = "The rule has outstanding questions that must be answered for the test target";
            const locations = [];
            for (const location of sarif.Serializable.toSARIF(this._target)) {
                locations.push(location);
            }
            return {
                ruleId: this._rule.uri,
                kind: "review",
                level: "warning",
                message: {
                    text: message,
                    markdown: message,
                },
                locations,
            };
        }
    }
    Outcome.CantTell = CantTell;
    (function (CantTell) {
        function isCantTell(value) {
            return value instanceof CantTell;
        }
        CantTell.isCantTell = isCantTell;
    })(CantTell = Outcome.CantTell || (Outcome.CantTell = {}));
    Outcome.cantTell = CantTell.of, Outcome.isCantTell = CantTell.isCantTell;
    let Applicable;
    (function (Applicable) {
        function isApplicable(value) {
            return Outcome.isPassed(value) || Outcome.isFailed(value) || Outcome.isCantTell(value);
        }
        Applicable.isApplicable = isApplicable;
    })(Applicable = Outcome.Applicable || (Outcome.Applicable = {}));
    Outcome.isApplicable = Applicable.isApplicable;
    class Inapplicable extends Outcome {
        static of(rule, mode) {
            return new Inapplicable(rule, mode);
        }
        constructor(rule, mode) {
            super(Value.Inapplicable, rule, mode);
        }
        equals(value) {
            return super.equals(value) && value instanceof Inapplicable;
        }
        toJSON(options) {
            return super.toJSON(options);
        }
        toEARL() {
            return {
                ...super.toEARL(),
                "earl:result": {
                    "@type": "earl:TestResult",
                    "earl:outcome": {
                        "@id": "earl:inapplicable",
                    },
                },
            };
        }
        toSARIF() {
            const message = "The rule did not apply to the test subject";
            return {
                ruleId: this._rule.uri,
                kind: "notApplicable",
                level: "none",
                message: {
                    text: message,
                    markdown: message,
                },
            };
        }
    }
    Outcome.Inapplicable = Inapplicable;
    (function (Inapplicable) {
        function isInapplicable(value) {
            return value instanceof Inapplicable;
        }
        Inapplicable.isInapplicable = isInapplicable;
    })(Inapplicable = Outcome.Inapplicable || (Outcome.Inapplicable = {}));
    Outcome.inapplicable = Inapplicable.of, Outcome.isInapplicable = Inapplicable.isInapplicable;
    function from(rule, target, expectations, mode) {
        return Trilean.fold((expectations) => Trilean.every(expectations, (expectation) => expectation
            .map((expectation) => expectation.isOk())
            .getOr(undefined)), () => Passed.of(rule, target, Record.from(Iterable.map(expectations.entries(), ([id, expectation]) => [
            id,
            // Due to the predicate in every, this branch is only taken if every
            // expectation is a Some<Ok<T>>.
            expectation.getUnsafe(),
        ])), mode), () => Failed.of(rule, target, Record.from(Iterable.map(expectations.entries(), ([id, expectation]) => [
            id,
            // One expectation being a Some<Err<T>> is enough to take that branch,
            // even if others are None.
            expectation.getOr(Err.of(Diagnostic.empty)),
        ])), mode), () => CantTell.of(rule, target, Diagnostic.empty, mode), expectations.values());
    }
    Outcome.from = from;
})(Outcome || (Outcome = {}));
//# sourceMappingURL=outcome.js.map