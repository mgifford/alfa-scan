import { Requirement } from "@siteimprove/alfa-act";
import { Branched } from "@siteimprove/alfa-branched";
import { None, Option } from "@siteimprove/alfa-option";
import { Criteria } from "./criterion/data.js";
/**
 * @public
 */
export class Criterion extends Requirement {
    static of(chapter) {
        const versions = [...Criteria[chapter].versions];
        // Use the criterion URI from the recommendation, if available, otherwise
        // use the URI from the previous version. This ensures that the most recent identifier
        // is used when available.
        const [, { uri }] = versions.find(([version]) => version === Criterion.Version.Recommendation) ?? versions.find(([version]) => version === Criterion.Version.Old);
        return new Criterion(chapter, uri);
    }
    _chapter;
    constructor(chapter, uri) {
        super("criterion", uri);
        this._chapter = chapter;
    }
    /**
     * The chapter of this criterion.
     */
    get chapter() {
        return this._chapter;
    }
    /**
     * The title of this criterion.
     */
    get title() {
        return Criteria[this._chapter].title;
    }
    /**
     * The versions in which this criterion is defined.
     */
    get versions() {
        return [...Criteria[this._chapter].versions].map(([version]) => version);
    }
    /**
     * The level of this criterion.
     *
     * @remarks
     * The level may be different between versions.
     */
    get level() {
        return Branched.from([...Criteria[this._chapter].versions].map(([version, { level }]) => [
            level,
            [version],
        ]));
    }
    toJSON() {
        const { title } = Criteria[this._chapter];
        return {
            ...super.toJSON(),
            chapter: this._chapter,
            title,
        };
    }
    toEARL() {
        const { title } = Criteria[this._chapter];
        return {
            ...super.toEARL(),
            "@context": {
                earl: "http://www.w3.org/ns/earl#",
                dct: "http://purl.org/dc/terms/",
            },
            "dct:title": title,
            "dct:isPartOf": "https://www.w3.org/TR/WCAG/",
        };
    }
}
/**
 * @public
 */
(function (Criterion) {
    function isChapter(value) {
        return value in Criteria;
    }
    Criterion.isChapter = isChapter;
    let Version;
    (function (Version) {
        /**
         * The current version of the WCAG Recommendation.
         */
        Version.Recommendation = "2.2";
        /**
         * The current version of the WCAG Working Draft.
         */
        // export const Draft = "2.2";
        /**
         * The current version of the WCAG Working Draft.
         */
        // export type Draft = typeof Draft;
        /**
         * The Old recommendation.
         */
        Version.Old = "2.1";
    })(Version = Criterion.Version || (Criterion.Version = {}));
    function isCriterion(value) {
        return value instanceof Criterion;
    }
    Criterion.isCriterion = isCriterion;
    function fromURI(uri) {
        const rewrittenUri = uri
            // Keeping slashes in URL rewritting to ensure proper delimiting of path
            // pieces.
            // rewrite WCAG22 -> WCAG2 since this is how we store it.
            // We should use the shared way of tracking which version is the latest as
            // this will require manual updates.
            .replace("/WCAG22/", "/WCAG2/")
            // rewrite WCAG -> WCAG2 since we only parse the latter.
            .replace("/WCAG/", "/WCAG2/");
        for (const [chapter, value] of Object.entries(Criteria)) {
            for (const version of value.versions) {
                if (version[1].uri === rewrittenUri) {
                    return Option.of(Criterion.of(chapter));
                }
            }
        }
        return None;
    }
    Criterion.fromURI = fromURI;
})(Criterion || (Criterion = {}));
//# sourceMappingURL=criterion.js.map