import { Requirement } from "@siteimprove/alfa-act";
import { Branched } from "@siteimprove/alfa-branched";
import { Option } from "@siteimprove/alfa-option";
import { Criteria } from "./criterion/data.js";
/**
 * @public
 */
export declare class Criterion<C extends Criterion.Chapter = Criterion.Chapter, U extends Criterion.URI<C, "2.1" | "2.2"> = Criterion.URI<C, "2.1" | "2.2">> extends Requirement<"criterion", U> {
    static of<C extends Criterion.Chapter>(chapter: C): Criterion<C>;
    private readonly _chapter;
    protected constructor(chapter: C, uri: U);
    /**
     * The chapter of this criterion.
     */
    get chapter(): C;
    /**
     * The title of this criterion.
     */
    get title(): Criterion.Title<C>;
    /**
     * The versions in which this criterion is defined.
     */
    get versions(): Iterable<Criterion.Version>;
    /**
     * The level of this criterion.
     *
     * @remarks
     * The level may be different between versions.
     */
    get level(): Branched<Criterion.Level, Criterion.Version>;
    toJSON(): Criterion.JSON<C, U>;
    toEARL(): Criterion.EARL;
}
/**
 * @public
 */
export declare namespace Criterion {
    interface JSON<C extends Criterion.Chapter = Criterion.Chapter, U extends Criterion.URI<C, "2.1" | "2.2"> = Criterion.URI<C, "2.1" | "2.2">> extends Requirement.JSON<"criterion", U> {
        chapter: C;
        title: string;
    }
    interface EARL extends Requirement.EARL {
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        "dct:title": string;
        "dct:isPartOf": "https://www.w3.org/TR/WCAG/";
    }
    /**
     * The chapters of all criteria.
     */
    type Chapter = keyof Criteria;
    function isChapter(value: string): value is Chapter;
    /**
     * The title of the specified criterion.
     */
    type Title<C extends Chapter = Chapter> = Criteria[C]["title"];
    /**
     * The different versions of the WCAG.
     */
    type Version = "2.0" | "2.1" | "2.2";
    namespace Version {
        /**
         * The current version of the WCAG Recommendation.
         */
        const Recommendation = "2.2";
        /**
         * The current version of the WCAG Recommendation.
         */
        type Recommendation = typeof Recommendation;
        /**
         * The current version of the WCAG Working Draft.
         */
        /**
         * The current version of the WCAG Working Draft.
         */
        /**
         * The Old recommendation.
         */
        const Old = "2.1";
        /**
         * The old recommendation.
         */
        type Old = typeof Old;
    }
    /**
     * The URI of the specified criterion.
     */
    type URI<C extends Chapter = Chapter, V extends Version = Version> = Criteria[C]["versions"] extends Iterable<infer T> ? T extends readonly [V, {
        readonly uri: infer U;
    }] ? U : never : never;
    /**
     * The level of the specified criterion under the specified version.
     */
    type Level<C extends Chapter = Chapter, V extends Version = Version> = Criteria[C]["versions"] extends Iterable<infer T> ? T extends readonly [V, {
        readonly level: infer L;
    }] ? L : never : never;
    namespace Level {
        /**
         * All criteria of the specified level under the specific version.
         */
        type Of<L extends Level, V extends Version = Version.Recommendation> = {
            [C in Chapter]: L extends Level<C, V> ? C : never;
        }[Chapter];
        /**
         * All criteria of level A.
         *
         * @remarks
         * Note that criteria levels are different from conformance levels! While
         * criteria levels are disjoint, conformance levels stack.
         */
        export type A<V extends Version = Version.Recommendation> = Of<"A", V>;
        /**
         * All criteria of level AA.
         *
         * @remarks
         * Note that criteria levels are different from conformance levels! While
         * criteria levels are disjoint, conformance levels stack.
         */
        export type AA<V extends Version = Version.Recommendation> = Of<"AA", V>;
        /**
         * All criteria of level AAA.
         *
         * @remarks
         * Note that criteria levels are different from conformance levels! While
         * criteria levels are disjoint, conformance levels stack.
         */
        export type AAA<V extends Version = Version.Recommendation> = Of<"AAA", V>;
        export {};
    }
    function isCriterion(value: unknown): value is Criterion;
    function fromURI(uri: string): Option<Criterion>;
}
//# sourceMappingURL=criterion.d.ts.map