import { None } from "@siteimprove/alfa-option";
/**
 * @internal
 */
export class BaseSelector {
    _type;
    _specificity;
    _useContext;
    /**
     * The key selector is used to optimise matching of complex (and compound)
     * selectors.
     *
     * @remarks
     * The key selector is the rightmost simple selector in a complex selector,
     * or the rightmost non-pseudo- selector in a compound selector. In order for
     * an element to match a selector, it must match the key selector.
     *
     * For example, consider selector `main .foo + div`. Any element matching it
     * must necessarily be a `<div>`, and for other elements there is no need to
     * waste time traversing the DOM tree to check siblings or ancestors.
     *
     * For compound selectors, e.g. `.foo.bar`, any part could be taken, and we
     * pick the rightmost non-pseudo-. This is done under the assumption that the
     * class selectors are usually piled up from more generic to more precise,
     * especially in the context of nesting selectors. We do not take the pseudo-*
     * selectors as they often depend on context, or match stuff that doesn't
     * really exist.
     *
     * Conversely, an `<img id="image" class="foo bar">` can only match selectors
     * whose key selector is `img`, `#image`, `.foo`, or `.bar`. So we can
     * pre-filter these when attempting matching.
     *
     * @privateRemarks
     * Key selectors are not part of the CSS specification, but are a useful tool
     * for optimising selector matching.
     *
     * Key selectors relate to cascading more than selector syntax and matching,
     * but they only depend on selector and thus make sense as instance properties.
     *
     * {@link http://doc.servo.org/style/selector_map/struct.SelectorMap.html}
     */
    _key = None;
    constructor(type, specificity, useContext) {
        this._type = type;
        this._specificity = specificity;
        this._useContext = useContext;
    }
    get type() {
        return this._type;
    }
    get specificity() {
        return this._specificity;
    }
    get useContext() {
        return this._useContext;
    }
    get key() {
        return this._key;
    }
    /**
     * Whether the selector fits in a Compound context.
     *
     * @remarks
     * Simple selectors are also (degenerate) compound selectors with a single
     * item in the list.
     *
     * @internal
     */
    static hasCompoundType(selector) {
        return [
            "compound",
            "type",
            "id",
            "class",
            "attribute",
            "universal",
            "pseudo-class",
        ].includes(selector.type);
    }
    equals(value) {
        return (value instanceof BaseSelector &&
            value._type === this._type &&
            value._specificity.equals(this._specificity));
    }
    toJSON() {
        return {
            type: this._type,
            specificity: this._specificity.toJSON(),
            ...(this._key.isSome() ? { key: `${this._key.get()}` } : {}),
        };
    }
}
/**
 * Selectors who also contain a name.
 *
 * @remarks
 * This can be either specific (e.g., the id is the name of a #foo selector),
 * or generic (e.g., "focus" is the name of the `:focus` pseudo-class).
 *
 * @internal
 */
export class WithName extends BaseSelector {
    _name;
    constructor(type, name, specificity, useContext) {
        super(type, specificity, useContext);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    matches(element, context) {
        return false;
    }
    equals(value) {
        return (value instanceof WithName &&
            super.equals(value) &&
            value._name === this._name);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            name: this._name,
        };
    }
}
//# sourceMappingURL=selector.js.map