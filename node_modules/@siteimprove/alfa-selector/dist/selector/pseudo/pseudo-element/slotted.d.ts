import { type Parser as CSSParser } from "@siteimprove/alfa-css";
import type { Element } from "@siteimprove/alfa-dom";
import { Context } from "../../../context.js";
import type { Compound } from "../../compound.js";
import type { Selector } from "../../index.js";
import type { Simple } from "../../simple/index.js";
import { PseudoElementSelector } from "./pseudo-element.js";
/**
 * {@link https://drafts.csswg.org/css-scoping/#slotted-pseudo}
 *
 * @public
 */
export declare class Slotted extends PseudoElementSelector<"slotted"> {
    static of(selector: Compound | Simple): Slotted;
    private readonly _selector;
    protected constructor(selector: Compound | Simple);
    get selector(): Compound | Simple;
    /**
     * @remarks
     * `::slotted` never aliases an element in its own tree.
     */
    matches(): boolean;
    [Symbol.iterator](): Iterator<Slotted>;
    equals(value: Slotted): boolean;
    equals(value: unknown): value is this;
    toJSON(): Slotted.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Slotted {
    interface JSON extends PseudoElementSelector.JSON<"slotted"> {
        selector: Compound.JSON | Simple.JSON;
    }
    function isSlotted(value: unknown): value is Slotted;
    /**
     * Check if an element matches a compound selector containing a`::slotted` pseudo-element.
     *
     * @remarks
     * `::slotted` can be used at the end of a compound selector, in which case the
     * start of the compound selector must match the assigned slot.
     * E.g., `div.foo::slotted(.bar)` matches a `.bar` slotted in a `div.foo`.
     *
     * Due to jumping between the light and shadow trees (and the nature of
     * pseudo-element where part of the compound selector must match the originating
     * element and other part must match the aliased element), matching a compound
     * selector containing a ::slotted pseudo-element is more complex than each
     * part individually. Therefore, this needs the full compound selector and
     * cannot simply be a method on the Slotted class.
     *
     * @privateRemarks
     * There is a potential circular dependency: Slotted -> Compound -> Simple -> Slotted.
     * We avoid this by checking `selector.type` rather than using Compound.isCompound.
     */
    function matchSlotted(element: Element, selector: Compound | Simple, context?: Context): boolean;
    function parse(parseSelector: Selector.Parser.Component, withColon?: boolean): CSSParser<Slotted>;
}
//# sourceMappingURL=slotted.d.ts.map