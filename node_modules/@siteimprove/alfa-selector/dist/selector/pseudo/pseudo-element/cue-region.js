import { Function, Token, } from "@siteimprove/alfa-css";
import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { PseudoElementSelector } from "./pseudo-element.js";
const { either, map, right, take } = Parser;
/**
 * {@link https://w3c.github.io/webvtt/#the-cue-region-pseudo-element}
 */
export class CueRegion extends PseudoElementSelector {
    static of(selector) {
        return new CueRegion(Option.from(selector));
    }
    _selector;
    constructor(selector) {
        super("cue-region");
        this._selector = selector;
    }
    get selector() {
        return this._selector;
    }
    *[Symbol.iterator]() {
        yield this;
    }
    equals(value) {
        return value instanceof CueRegion && value.selector.equals(this.selector);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selector: this._selector.toJSON(),
        };
    }
    toString() {
        return `::${this.name}` + this._selector.isSome()
            ? `(${this._selector})`
            : "";
    }
}
(function (CueRegion) {
    function parse(parseSelector, withColon = true) {
        // We need to try and fail the functional notation first to avoid accepting
        // the `::cue-region` prefix of a `::cue-region(selector)`.
        const parser = either(map(Function.parse("cue-region", parseSelector), ([_, selector]) => CueRegion.of(selector)), 
        // We need to eta-expand in order to discard the result of parseIdent.
        map(Token.parseIdent("cue-region"), () => CueRegion.of()));
        return withColon ? right(take(Token.parseColon, 2), parser) : parser;
    }
    CueRegion.parse = parse;
})(CueRegion || (CueRegion = {}));
//# sourceMappingURL=cue-region.js.map