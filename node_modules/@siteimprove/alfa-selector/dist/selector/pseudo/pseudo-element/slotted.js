import { Function, Token, } from "@siteimprove/alfa-css";
import { None, Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Context } from "../../../context.js";
import { Specificity } from "../../../specificity.js";
import { BaseSelector } from "../../selector.js";
import { PseudoElementSelector } from "./pseudo-element.js";
const { filter, map, right, take } = Parser;
/**
 * {@link https://drafts.csswg.org/css-scoping/#slotted-pseudo}
 *
 * @public
 */
export class Slotted extends PseudoElementSelector {
    static of(selector) {
        return new Slotted(selector);
    }
    _selector;
    constructor(selector) {
        super("slotted", Specificity.sum(selector.specificity, Specificity.of(0, 0, 1)));
        this._selector = selector;
    }
    get selector() {
        return this._selector;
    }
    /**
     * @remarks
     * `::slotted` never aliases an element in its own tree.
     */
    matches() {
        return false;
    }
    *[Symbol.iterator]() {
        yield this;
    }
    equals(value) {
        return value instanceof Slotted && value._selector.equals(this._selector);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selector: this._selector.toJSON(),
        };
    }
    toString() {
        return `::${this.name}(${this._selector})`;
    }
}
/**
 * @public
 */
(function (Slotted) {
    function isSlotted(value) {
        return value instanceof Slotted;
    }
    Slotted.isSlotted = isSlotted;
    /**
     * Check if an element matches a compound selector containing a`::slotted` pseudo-element.
     *
     * @remarks
     * `::slotted` can be used at the end of a compound selector, in which case the
     * start of the compound selector must match the assigned slot.
     * E.g., `div.foo::slotted(.bar)` matches a `.bar` slotted in a `div.foo`.
     *
     * Due to jumping between the light and shadow trees (and the nature of
     * pseudo-element where part of the compound selector must match the originating
     * element and other part must match the aliased element), matching a compound
     * selector containing a ::slotted pseudo-element is more complex than each
     * part individually. Therefore, this needs the full compound selector and
     * cannot simply be a method on the Slotted class.
     *
     * @privateRemarks
     * There is a potential circular dependency: Slotted -> Compound -> Simple -> Slotted.
     * We avoid this by checking `selector.type` rather than using Compound.isCompound.
     */
    function matchSlotted(element, selector, context = Context.empty()) {
        // The part of `selector` that must match the slot.
        const slotSelectors = [];
        // The part of `selector` that must match the slotted element
        // (pseudo-classes after ::slotted).
        const qualifier = [];
        const selectors = selector.type === "compound" ? selector.selectors : [selector];
        let actualSelector = None;
        let seen = false;
        for (const candidate of selectors) {
            if (Slotted.isSlotted(candidate)) {
                if (actualSelector.isSome()) {
                    // If there is more than one ::slotted selector, this cannot match.
                    return false;
                }
                actualSelector = Option.of(candidate);
                seen = true;
            }
            else if (seen) {
                qualifier.push(candidate);
            }
            else {
                slotSelectors.push(candidate);
            }
        }
        const slot = element.assignedSlot();
        return (
        // `element` must be slotted.
        slot.some((slot) => 
        // The slot must match the slot selectors, if any.
        slotSelectors.every((selector) => selector.matches(slot, context))) &&
            // There must be an actual ::slotted selector.
            actualSelector.some((slotted) => 
            // `element` must match the argument of the actual ::slotted selector.
            slotted.selector.matches(element, context)) &&
            // `element` must match the qualifier, if any.
            qualifier.every((selector) => selector.matches(element, context)));
    }
    Slotted.matchSlotted = matchSlotted;
    function parse(parseSelector, withColon = true) {
        const parser = Function.parse("slotted", () => filter(parseSelector(), BaseSelector.hasCompoundType, () => "::slotted() only accepts compound selectors"));
        return map(withColon ? right(take(Token.parseColon, 2), parser) : parser, ([_, selector]) => Slotted.of(selector));
    }
    Slotted.parse = parse;
})(Slotted || (Slotted = {}));
//# sourceMappingURL=slotted.js.map