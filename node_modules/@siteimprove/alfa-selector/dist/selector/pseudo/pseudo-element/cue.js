import { Function, Token, } from "@siteimprove/alfa-css";
import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { PseudoElementSelector } from "./pseudo-element.js";
const { either, map, right, take } = Parser;
/**
 * {@link https://w3c.github.io/webvtt/#the-cue-pseudo-element}
 */
export class Cue extends PseudoElementSelector {
    static of(selector) {
        return new Cue(Option.from(selector));
    }
    _selector;
    constructor(selector) {
        super("cue");
        this._selector = selector;
    }
    get selector() {
        return this._selector;
    }
    *[Symbol.iterator]() {
        yield this;
    }
    equals(value) {
        return value instanceof Cue && value.selector.equals(this.selector);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selector: this._selector.toJSON(),
        };
    }
    toString() {
        return `::${this.name}` + this._selector.isSome()
            ? `(${this._selector})`
            : "";
    }
}
(function (Cue) {
    function parseFunc(parseSelector) {
        return map(Function.parse("cue", parseSelector), ([_, selector]) => Cue.of(selector));
    }
    function parseFunctional(parseSelector, withColon = false) {
        return withColon
            ? right(take(Token.parseColon, 2), parseFunc(parseSelector))
            : parseFunc(parseSelector);
    }
    Cue.parseFunctional = parseFunctional;
    function parse(parseSelector, withColon = false) {
        // We need to try and fail the functional notation first to avoid accepting
        // the `::cue` prefix of a `::cue(selector)`.
        const parser = either(parseFunc(parseSelector), 
        // We need to eta-expand in order to discard the result of parseIdent.
        map(Token.parseIdent("cue"), () => Cue.of()));
        return withColon ? right(take(Token.parseColon, 2), parser) : parser;
    }
    Cue.parse = parse;
})(Cue || (Cue = {}));
//# sourceMappingURL=cue.js.map