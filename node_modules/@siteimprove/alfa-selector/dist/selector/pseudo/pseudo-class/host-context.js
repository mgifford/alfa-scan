var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { Cache } from "@siteimprove/alfa-cache";
import { Element, Node } from "@siteimprove/alfa-dom";
import { Parser } from "@siteimprove/alfa-parser";
import { Context } from "../../../context.js";
import { Specificity } from "../../../specificity.js";
import { BaseSelector } from "../../selector.js";
import { WithSelector } from "./pseudo-class.js";
const { filter } = Parser;
/**
 * {@link https://drafts.csswg.org/css-scoping-1/#selectordef-host-context}
 *
 * @privateRemarks
 * In CSS lingo, `:host-context` only accepts a compound selector, but simple
 * selectors are also compounds. Alfa does make a type difference between
 * a Simple selector and a compound selector with only a single Simple
 * selector. Hence, this also accepts Simple selector. This also accepts
 * pseudo-elements, which seems to not be really allowed by the specification.
 *
 * @public
 */
let HostContext = (() => {
    var _a;
    let _classSuper = WithSelector;
    let _instanceExtraInitializers = [];
    let __matchHost_decorators;
    return class HostContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __matchHost_decorators = [(_a = Cache).memoize.bind(_a)];
            __esDecorate(this, null, __matchHost_decorators, { kind: "method", name: "_matchHost", static: false, private: false, access: { has: obj => "_matchHost" in obj, get: obj => obj._matchHost }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static of(selector) {
            return new HostContext(selector);
        }
        constructor(selector) {
            super("host-context", selector, Specificity.sum(selector.specificity, Specificity.of(0, 1, 0)), selector.useContext);
            __runInitializers(this, _instanceExtraInitializers);
        }
        *[Symbol.iterator]() {
            yield this;
        }
        /**
         * @remarks
         * `:host-context` never matches anything in its own tree.
         */
        matches(element, context) {
            return false;
        }
        /**
         * Whether an element (shadow host) has an ancestor matching the selector.
         *
         * @privateRemarks
         * CSS calls the selector "context" which clashes with our use of `Context`
         * as the "state of the page".
         */
        _matchHost(element, context) {
            return element
                .inclusiveAncestors(Node.Traversal.of(Node.Traversal.composed))
                .filter(Element.isElement)
                .some((ancestor) => this._selector.matches(ancestor, context));
        }
        /**
         * Checks whether a shadow host matches.
         *
         * @remarks
         * This must be called with `element` being the shadow host of
         * the Document that defines the selector.
         */
        matchHost(element, context = Context.empty()) {
            return this.useContext
                ? this._matchHost(element, context)
                : // If context is not relevant, use an empty one to increase cache hit
                    // chances.
                    this._matchHost(element, Context.empty());
        }
        equals(value) {
            return (value instanceof HostContext && value._selector.equals(this._selector));
        }
        toJSON() {
            return {
                ...super.toJSON(),
            };
        }
    };
})();
export { HostContext };
(function (HostContext) {
    function isHostContext(value) {
        return value instanceof HostContext;
    }
    HostContext.isHostContext = isHostContext;
    HostContext.parse = (parseSelector, withColon = true) => WithSelector.parseWithSelector("host-context", () => filter(parseSelector(), BaseSelector.hasCompoundType, () => ":host-context() only accepts compound selectors"), HostContext.of, withColon);
})(HostContext || (HostContext = {}));
//# sourceMappingURL=host-context.js.map