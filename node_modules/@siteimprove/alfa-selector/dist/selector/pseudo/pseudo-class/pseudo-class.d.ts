import { Nth, type Parser as CSSParser } from "@siteimprove/alfa-css";
import type { Element } from "@siteimprove/alfa-dom";
import { Serializable } from "@siteimprove/alfa-json";
import type { Option } from "@siteimprove/alfa-option";
import type { Thunk } from "@siteimprove/alfa-thunk";
import type { Absolute, Selector } from "../../index.js";
import { Specificity } from "../../../specificity.js";
import { WithName } from "../../selector.js";
/**
 * @internal
 */
export declare abstract class PseudoClassSelector<N extends string = string> extends WithName<"pseudo-class", N> {
    protected constructor(name: N, useContext: boolean, specificity?: Specificity);
    equals(value: PseudoClassSelector): boolean;
    equals(value: unknown): value is this;
    toJSON(): PseudoClassSelector.JSON<N>;
    toString(): string;
}
/**
 * @internal
 */
export declare namespace PseudoClassSelector {
    interface JSON<N extends string = string> extends WithName.JSON<"pseudo-class", N> {
    }
    /**
     * Parses a non-functional pseudo-class (`:<name>`)
     */
    function parseNonFunctional<T>(name: string, of: Thunk<T>, withColon?: boolean): CSSParser<T>;
}
/**
 * @internal
 */
export declare abstract class WithIndex<N extends string = string> extends PseudoClassSelector<N> {
    protected static readonly _indices: WeakMap<Element<string>, number>;
    protected readonly _index: Nth;
    protected constructor(name: N, nth: Nth, useContext: boolean, specificity?: Specificity);
    equals(value: WithIndex): boolean;
    equals(value: unknown): value is this;
    toJSON(): WithIndex.JSON<N>;
    toString(): string;
}
/**
 * @internal
 */
export declare namespace WithIndex {
    interface JSON<N extends string = string> extends PseudoClassSelector.JSON<N> {
        index: Nth.JSON;
    }
    /**
     * Parses a functional pseudo-class accepting a nth argument (an+b)
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, the selector parser).
     */
    function parseWithIndex<T extends WithIndex>(name: string, of: (nth: Nth) => T, withColon?: boolean): CSSParser<T>;
}
/**
 * @internal
 */
export declare abstract class WithSelector<N extends string = string, S extends Selector = Absolute> extends PseudoClassSelector<N> {
    protected readonly _selector: S;
    protected constructor(name: N, selector: S, specificity: Specificity, useContext: boolean);
    get selector(): S;
    equals(value: WithSelector): boolean;
    equals(value: unknown): value is this;
    toJSON(): WithSelector.JSON<N, S>;
    toString(): string;
}
/**
 * @internal
 */
export declare namespace WithSelector {
    interface JSON<N extends string = string, S extends Selector = Absolute> extends PseudoClassSelector.JSON<N> {
        selector: Serializable.ToJSON<S>;
    }
    /**
     * Parses a functional pseudo-class accepting a selector argument
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, no "name" or "of").
     */
    function parseWithSelector<S extends Selector, N extends string, T extends WithSelector<N, S>>(name: string, parseSelector: Thunk<CSSParser<S>>, of: (selector: S) => T, withColon?: boolean): CSSParser<T>;
}
/**
 * @internal
 */
export declare abstract class WithIndexAndSelector<N extends string = string> extends WithIndex<N> {
    protected readonly _selector: Option<Absolute>;
    protected constructor(name: N, nth: Nth, selector: Option<Absolute>, useContext: boolean, specificity?: Specificity);
    get selector(): Option<Absolute>;
    equals(value: WithIndexAndSelector): boolean;
    equals(value: unknown): value is this;
    toJSON(): WithIndexAndSelector.JSON<N>;
    toString(): string;
}
/**
 * @internal
 */
export declare namespace WithIndexAndSelector {
    interface JSON<N extends string = string> extends WithIndex.JSON<N> {
        selector?: Absolute.JSON;
    }
    /**
     * Parses a functional pseudo-class accepting a nth argument (an+b)
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, no "name" or "of").
     */
    function parseWithIndexAndSelector<T extends WithIndex>(name: string, parseSelector: Selector.Parser.Component, of: (nth: Nth, selector: Option<Absolute>) => T, withColon?: boolean): CSSParser<T>;
}
//# sourceMappingURL=pseudo-class.d.ts.map