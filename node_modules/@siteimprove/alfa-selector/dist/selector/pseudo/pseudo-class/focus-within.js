import { Cache } from "@siteimprove/alfa-cache";
import { Node } from "@siteimprove/alfa-dom";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Context } from "../../../context.js";
import { PseudoClassSelector } from "./pseudo-class.js";
const { State } = Context;
/**
 * {@link https://drafts.csswg.org/selectors/#focus-within-pseudo}
 */
export class FocusWithin extends PseudoClassSelector {
    static of() {
        return new FocusWithin();
    }
    constructor() {
        super("focus-within", true);
    }
    static _cache = Cache.empty();
    *[Symbol.iterator]() {
        yield this;
    }
    matches(element, context = Context.empty()) {
        return FocusWithin._cache.get(element, Cache.empty).get(context, () => {
            // We assume that most of the time the context is near empty and thus it
            // is inexpensive to check if something is in it.
            const focused = Sequence.from(context.withState(State.Focus));
            return (focused.size !== 0 &&
                element
                    .inclusiveDescendants(Node.fullTree)
                    .some((descendant) => focused.includes(descendant)));
        });
    }
    toJSON() {
        return super.toJSON();
    }
}
(function (FocusWithin) {
    FocusWithin.parse = PseudoClassSelector.parseNonFunctional("focus-within", FocusWithin.of);
})(FocusWithin || (FocusWithin = {}));
//# sourceMappingURL=focus-within.js.map