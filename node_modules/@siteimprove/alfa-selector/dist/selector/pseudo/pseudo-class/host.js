var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { Cache } from "@siteimprove/alfa-cache";
import { Function, Token } from "@siteimprove/alfa-css";
import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Context } from "../../../context.js";
import { Specificity } from "../../../specificity.js";
import { BaseSelector } from "../../selector.js";
import { PseudoClassSelector } from "./pseudo-class.js";
const { either, filter, map, right } = Parser;
const { parseColon } = Token;
/**
 * {@link https://drafts.csswg.org/css-scoping-1/#selectordef-host}
 *
 * @privateRemarks
 * Since WithSelector has a mandatory selector, it is not convenient
 * to use it to group both the functional and non-functional variants.
 *
 * In CSS lingo, `:host` only accepts a compound selector, but simple
 * selectors are also compounds. Alfa does make a type difference between
 * a Simple selector and a compound selector with only a single Simple
 * selector. Hence, this also accepts Simple selector. This also accepts
 * pseudo-elements, which seems to not be really allowed by the specification.
 *
 * @public
 */
let Host = (() => {
    var _a;
    let _classSuper = PseudoClassSelector;
    let _instanceExtraInitializers = [];
    let __matchHost_decorators;
    return class Host extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, __matchHost_decorators, { kind: "method", name: "_matchHost", static: false, private: false, access: { has: obj => "_matchHost" in obj, get: obj => obj._matchHost }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static of(selector) {
            return new Host(Option.from(selector));
        }
        _selector = __runInitializers(this, _instanceExtraInitializers);
        constructor(selector) {
            super("host", selector.getter("useContext").getOr(false), Specificity.sum(selector
                .map((selector) => selector.specificity)
                .getOr(Specificity.empty()), Specificity.of(0, 1, 0)));
            this._selector = selector;
        }
        get selector() {
            return this._selector;
        }
        /**
         * @remarks
         * `:host` never matches anything in its own tree.
         */
        matches() {
            return false;
        }
        _matchHost(element, context) {
            return this._selector.every((selector) => selector.matches(element, context));
        }
        /**
         * Checks whether a shadow host matches.
         *
         * @remarks
         * This must be called with `element` being the shadow host of
         * the Document that defines the selector.
         */
        matchHost(element, context = Context.empty()) {
            return this._matchHost(element, context);
        }
        *[(__matchHost_decorators = [(_a = Cache).memoize.bind(_a)], Symbol.iterator)]() {
            yield this;
        }
        equals(value) {
            return value instanceof Host && value._selector.equals(this._selector);
        }
        toJSON() {
            return {
                ...super.toJSON(),
                ...(this._selector.isSome()
                    ? { selector: this._selector.get().toJSON() }
                    : {}),
            };
        }
    };
})();
export { Host };
/**
 * @public
 */
(function (Host) {
    function isHost(value) {
        return value instanceof Host;
    }
    Host.isHost = isHost;
    Host.parseFunctional = (parseSelector, withColon = true) => {
        const parse = Function.parse("host", () => filter(parseSelector(), BaseSelector.hasCompoundType, () => ":host() only accepts compound selectors"));
        return map(withColon ? right(parseColon, parse) : parse, ([, selector]) => Host.of(selector));
    };
    Host.parse = (parseSelector) => either(
    // We need to try the functional variant first to avoid the non-functional
    // greedily passing.
    Host.parseFunctional(parseSelector), PseudoClassSelector.parseNonFunctional("host", Host.of));
})(Host || (Host = {}));
//# sourceMappingURL=host.js.map