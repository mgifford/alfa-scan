import { Token } from "@siteimprove/alfa-css";
import type { Element } from "@siteimprove/alfa-dom";
import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Context } from "../../../context.js";
import type { Compound, Selector, Simple } from "../../index.js";
import { PseudoClassSelector } from "./pseudo-class.js";
/**
 * {@link https://drafts.csswg.org/css-scoping-1/#selectordef-host}
 *
 * @privateRemarks
 * Since WithSelector has a mandatory selector, it is not convenient
 * to use it to group both the functional and non-functional variants.
 *
 * In CSS lingo, `:host` only accepts a compound selector, but simple
 * selectors are also compounds. Alfa does make a type difference between
 * a Simple selector and a compound selector with only a single Simple
 * selector. Hence, this also accepts Simple selector. This also accepts
 * pseudo-elements, which seems to not be really allowed by the specification.
 *
 * @public
 */
export declare class Host extends PseudoClassSelector<"host"> {
    static of(selector?: Compound | Simple): Host;
    private readonly _selector;
    protected constructor(selector: Option<Compound | Simple>);
    get selector(): Option<Compound | Simple>;
    /**
     * @remarks
     * `:host` never matches anything in its own tree.
     */
    matches(): boolean;
    private _matchHost;
    /**
     * Checks whether a shadow host matches.
     *
     * @remarks
     * This must be called with `element` being the shadow host of
     * the Document that defines the selector.
     */
    matchHost(element: Element, context?: Context): boolean;
    [Symbol.iterator](): Iterator<Host>;
    equals(value: Host): boolean;
    equals(value: unknown): value is this;
    toJSON(): Host.JSON;
}
/**
 * @public
 */
export declare namespace Host {
    interface JSON extends PseudoClassSelector.JSON<"host"> {
        selector?: Compound.JSON | Simple.JSON;
    }
    function isHost(value: unknown): value is Host;
    const parseFunctional: (parseSelector: Selector.Parser.Component, withColon?: boolean) => Parser<import("@siteimprove/alfa-slice").Slice<Token>, Host, string, []>;
    const parse: (parseSelector: Selector.Parser.Component) => Parser<import("@siteimprove/alfa-slice").Slice<Token>, Host, string, []>;
}
//# sourceMappingURL=host.d.ts.map