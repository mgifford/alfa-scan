import { Function, Nth, Token, } from "@siteimprove/alfa-css";
import { Serializable } from "@siteimprove/alfa-json";
import { Parser } from "@siteimprove/alfa-parser";
import { Specificity } from "../../../specificity.js";
import { WithName } from "../../selector.js";
const { delimited, end, left, map, option, pair, right } = Parser;
const { parseColon, parseIdent, parseWhitespace } = Token;
/**
 * @internal
 */
export class PseudoClassSelector extends WithName {
    // Some pseudo-class manipulate specificity, so we cannot just set it
    // to (0, 1, 0) for all and must allow for overwriting it.
    // https://www.w3.org/TR/selectors/#specificity
    constructor(name, useContext, specificity = Specificity.pseudoClass()) {
        super("pseudo-class", name, specificity, useContext);
    }
    equals(value) {
        return value instanceof PseudoClassSelector && super.equals(value);
    }
    toJSON() {
        return {
            ...super.toJSON(),
        };
    }
    toString() {
        return `:${this._name}`;
    }
}
/**
 * @internal
 */
(function (PseudoClassSelector) {
    /**
     * Parses a non-functional pseudo-class (`:<name>`)
     */
    function parseNonFunctional(name, of, withColon = true) {
        return (input) => {
            const parser = withColon
                ? right(parseColon, parseIdent(name))
                : parseIdent(name);
            // We need to eta-expand in order to discard the result of parseIdent.
            return map(parser, () => of())(input);
        };
    }
    PseudoClassSelector.parseNonFunctional = parseNonFunctional;
})(PseudoClassSelector || (PseudoClassSelector = {}));
/**
 * @internal
 */
export class WithIndex extends PseudoClassSelector {
    // For pseudo-classes that do not filter the set of elements, we can use a static
    // map of sibling positions.
    // For pseudo-classes that may filter the set of elements, we need this to be
    // an instance map since two instances may have different extra selector and
    // set of candidates.
    static _indices = new WeakMap();
    _index;
    constructor(name, nth, useContext, specificity) {
        super(name, useContext, specificity);
        this._index = nth;
    }
    equals(value) {
        return value instanceof WithIndex && value._index.equals(this._index);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            index: this._index.toJSON(),
        };
    }
    toString() {
        return `:${this.name}(${this._index})`;
    }
}
const parseNth = left(Nth.parse, end((token) => `Unexpected token ${token}`));
/**
 * @internal
 */
(function (WithIndex) {
    /**
     * Parses a functional pseudo-class accepting a nth argument (an+b)
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, the selector parser).
     */
    function parseWithIndex(name, of, withColon = true) {
        const parser = Function.parse(name, parseNth);
        return map(withColon ? right(parseColon, parser) : parser, ([, nth]) => of(nth));
    }
    WithIndex.parseWithIndex = parseWithIndex;
})(WithIndex || (WithIndex = {}));
/**
 * @internal
 */
export class WithSelector extends PseudoClassSelector {
    _selector;
    constructor(name, selector, specificity, useContext) {
        super(name, useContext, specificity);
        this._selector = selector;
    }
    get selector() {
        return this._selector;
    }
    equals(value) {
        return (value instanceof WithSelector && value._selector.equals(this._selector));
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selector: Serializable.toJSON(this._selector),
        };
    }
    toString() {
        return `:${this.name}(${this._selector})`;
    }
}
/**
 * @internal
 */
(function (WithSelector) {
    /**
     * Parses a functional pseudo-class accepting a selector argument
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, no "name" or "of").
     */
    function parseWithSelector(name, parseSelector, of, withColon = true) {
        const parser = Function.parse(name, parseSelector);
        return map(withColon ? right(parseColon, parser) : parser, ([, selector]) => of(selector));
    }
    WithSelector.parseWithSelector = parseWithSelector;
})(WithSelector || (WithSelector = {}));
/**
 * @internal
 */
export class WithIndexAndSelector extends WithIndex {
    _selector;
    constructor(name, nth, selector, useContext, 
    // Both :nth-child and :nth-last-child have this specificity
    specificity = Specificity.sum(Specificity.of(0, 1, 0), selector.map((s) => s.specificity).getOr(Specificity.of(0, 0, 0)))) {
        super(name, nth, useContext, specificity);
        this._selector = selector;
    }
    get selector() {
        return this._selector;
    }
    equals(value) {
        return (value instanceof WithIndexAndSelector &&
            super.equals(value) &&
            value._selector.equals(this._selector));
    }
    toJSON() {
        return {
            ...super.toJSON(),
            ...(this._selector.isSome()
                ? { selector: this._selector.get().toJSON() }
                : {}),
        };
    }
    toString() {
        return `:${this.name}(${this._index} of ${this._selector})`;
    }
}
/**
 * @internal
 */
(function (WithIndexAndSelector) {
    /**
     * Parses a functional pseudo-class accepting a nth argument (an+b)
     *
     * @privateRemarks
     * This can't be named just "parse" as it is overwritten by subclasses with a
     * different type of parameter (namely, no "name" or "of").
     */
    function parseWithIndexAndSelector(name, parseSelector, of, withColon = true) {
        const parser = Function.parse(name, () => pair(Nth.parse, option(right(delimited(parseWhitespace, parseIdent("of")), parseSelector()))));
        return map(withColon ? right(parseColon, parser) : parser, ([, [nth, selector]]) => of(nth, selector));
    }
    WithIndexAndSelector.parseWithIndexAndSelector = parseWithIndexAndSelector;
})(WithIndexAndSelector || (WithIndexAndSelector = {}));
//# sourceMappingURL=pseudo-class.js.map