import { Iterable } from "@siteimprove/alfa-iterable";
import { Parser } from "@siteimprove/alfa-parser";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Context } from "../context.js";
import { Complex } from "./complex.js";
import { Compound } from "./compound.js";
import { List } from "./list.js";
import { Relative as BaseRelative } from "./relative.js";
import { Host } from "./pseudo/pseudo-class/host.js";
import { HostContext } from "./pseudo/pseudo-class/host-context.js";
import { Slotted } from "./pseudo/pseudo-element/slotted.js";
// Re-export for further users
export * from "./combinator.js";
export * from "./complex.js";
export * from "./compound.js";
export * from "./list.js";
export * from "./relative.js";
export * from "./simple/index.js";
const { end, left } = Parser;
const { and, or, test } = Refinement;
/**
 * @public
 */
export var Selector;
(function (Selector) {
    /**
     * Whether a selector targets slotted elements (living in another tree).
     *
     * @remarks
     * `::slotted` inside a complex selector, not in rightmost position,
     * does not match anything. Complex.matches currently let it match stuff,
     * but hasSlotted should make sure we never call it that wayâ€¦
     */
    function hasSlotted(selector) {
        return test(or(Slotted.isSlotted, and(Compound.isCompound, (compound) => Iterable.some(compound.selectors, Slotted.isSlotted)), 
        // `::slotted` only works in the rightmost position of complex selectors.
        and(Complex.isComplex, (complex) => hasSlotted(complex.right))), selector);
    }
    Selector.hasSlotted = hasSlotted;
    /**
     * Whether a selector targets the shadow host of its tree (hence in another tree).
     *
     * @remarks
     * * `:host` and `:context` as part of a compound selector never match.
     * * `:host` and `:host-context` as the leftmost part of a complex selector
     *   actually match a node within the shadow tree. Thus, they are not
     *   considered as "host selector" and Complex.matches handles the case.
     * * `:host` and `:host-context` in other place of a complex selector do
     *   not match anything.
     */
    Selector.isHostSelector = or(Host.isHost, HostContext.isHostContext);
    /**
     * Whether a selector is a shadow selector selecting a light node (in another tree).
     *
     */
    Selector.isShadow = or(Selector.isHostSelector, hasSlotted);
    /**
     * Checks if a selector matches a slotted element.
     *
     * @remarks
     * This will automatically be false is `selector` does not contain a `::slotted`
     * pseudo-element or if `slotted` is not indeed slotted, and shouldn't be used
     * in these cases.
     *
     * @privateRemarks
     * For ::slotted or compound containing ::slotted, we need to use Slotted.matchSlotted
     * to do the magic. For Complex selectors, their own #matches method does the magic.
     */
    function matchSlotted(selector, slotted, context = Context.empty()) {
        return (hasSlotted(selector) &&
            (Slotted.isSlotted(selector) || Compound.isCompound(selector)
                ? Slotted.matchSlotted(slotted, selector, context)
                : selector.matches(slotted, context)));
    }
    Selector.matchSlotted = matchSlotted;
    function parseSelector(options) {
        return left(List.parse(parseSelector, options), end((token) => `Unexpected token ${token}`));
    }
    Selector.parseSelector = parseSelector;
    /**
     * Parses a (list of) complex selector.
     *
     * {@link https://drafts.csswg.org/selectors/#typedef-complex-selector-list}
     * If the list contains a single selector, it is simplified out.
     */
    Selector.parse = parseSelector();
})(Selector || (Selector = {}));
//# sourceMappingURL=index.js.map