import { Array } from "@siteimprove/alfa-array";
import { Parser } from "@siteimprove/alfa-parser";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Specificity } from "../specificity.js";
import { BaseSelector } from "./selector.js";
import { Class, Id, PseudoClass, PseudoElement, Simple, Type, } from "./simple/index.js";
const { map, oneOrMore } = Parser;
const { or, not } = Predicate;
const isPseudo = or(PseudoClass.isPseudoClass, PseudoElement.isPseudoElement);
const hasKey = or(Id.isId, Class.isClass, Type.isType);
/**
 * {@link https://drafts.csswg.org/selectors/#compound}
 *
 * @public
 */
export class Compound extends BaseSelector {
    static of(...selectors) {
        return new Compound(selectors);
    }
    _selectors;
    _pseudos;
    _nonPseudos;
    _length;
    _key;
    constructor(selectors) {
        super("compound", Specificity.sum(...selectors.map((selector) => selector.specificity)), selectors.some((selector) => selector.useContext));
        this._selectors = selectors;
        this._length = selectors.length;
        // We separate the non-pseudo selectors from the pseudo ones.
        // Per CSS syntax, the non-pseudos must come first, even if we don't enforce
        // this ourselves. So technically, we could avoid traversing the array twice.
        // The non-pseudo are stored in reverse order because they are matched in
        // reverse order.
        this._pseudos = selectors.filter(isPseudo);
        this._nonPseudos = selectors.filter(not(isPseudo)).reverse();
        // We use the last keyed selector as the key for the compound selector
        // under the assumption that they are usually written to be more and more
        // precise, e.g. div.grid.grid--column--3. This notably nearly prevents type
        // to be keys for compound selectors as they must come first. This makes for
        // smaller buckets in the selectors map, hence faster matching.
        this._key = Array.findLast(selectors, hasKey).flatMap((selector) => selector.key);
    }
    get selectors() {
        return this._selectors;
    }
    get length() {
        return this._length;
    }
    matches(element, context) {
        return (
        // We match the non-pseudo- selectors in reverse order as they are usually
        // written from most generic to most precise, especially in the context of
        // nesting selectors.
        // This is probably not much of a difference for "raw" compound selectors,
        // due to the key selectors selection, but can make a difference when they
        // are part of ancestors selectors.
        // E.g. in `foo.bar`, `.bar` is already the key selector, so in most cases
        // it would anyway only be matched against .foo elements. But in
        // `foo.bar .baz`, the ancestor part doesn't benefits from key selectors
        // so it can be important to match `.bar` before `foo`.
        this._nonPseudos.every((selector) => selector.matches(element, context)) && this._pseudos.every((selector) => selector.matches(element, context)));
    }
    equals(value) {
        return (value instanceof Compound &&
            Array.equals(value._selectors, this._selectors));
    }
    *[Symbol.iterator]() {
        yield this;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selectors: this._selectors.map((selector) => selector.toJSON()),
        };
    }
    toString() {
        return this._selectors.map((selector) => selector.toString()).join("");
    }
}
/**
 * @public
 */
(function (Compound) {
    function isCompound(value) {
        return value instanceof Compound;
    }
    Compound.isCompound = isCompound;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-compound-selector}
     *
     * @internal
     */
    Compound.parse = (parseSelector) => map(oneOrMore(Simple.parse(parseSelector)), (result) => result.length === 1 ? result[0] : Compound.of(...result));
})(Compound || (Compound = {}));
//# sourceMappingURL=compound.js.map