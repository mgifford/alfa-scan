import { Element } from "@siteimprove/alfa-dom";
import { Maybe, None } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Specificity } from "../specificity.js";
import { Combinator } from "./combinator.js";
import { Complex } from "./complex.js";
import { BaseSelector } from "./selector.js";
const { either, map, pair } = Parser;
/**
 * {@link https://drafts.csswg.org/selectors/#relative-selector}
 *
 * @public
 */
export class Relative extends BaseSelector {
    static of(combinator, selector) {
        return new Relative(combinator, selector);
    }
    _combinator;
    _selector;
    _anchor;
    constructor(combinator, selector, anchor = None) {
        super("relative", selector.specificity, selector.useContext);
        this._combinator = combinator;
        this._selector = selector;
        this._anchor = Maybe.toOption(anchor);
    }
    get combinator() {
        return this._combinator;
    }
    get selector() {
        return this._selector;
    }
    get anchor() {
        return this._anchor;
    }
    matches(element, context) {
        return this._anchor.some((anchor) => Combinator.matcher(anchor, this._combinator, this._selector, element, context));
    }
    anchoredAt(anchor) {
        return new Relative(this._combinator, this._selector, Exact.of(anchor));
    }
    equals(value) {
        return (value instanceof Relative &&
            value._combinator === this._combinator &&
            value._selector.equals(this._selector));
    }
    *[Symbol.iterator]() {
        yield this;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            combinator: this._combinator,
            selector: this._selector.toJSON(),
        };
    }
    toString() {
        const combinator = this._combinator === Combinator.Descendant ? "" : `${this._combinator} `;
        return `${combinator}${this._selector}`;
    }
}
/**
 * @public
 */
(function (Relative) {
    function isRelative(value) {
        return value instanceof Relative;
    }
    Relative.isRelative = isRelative;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-relative-selector}
     */
    Relative.parse = (parseSelector) => map(either(pair(Combinator.parse, Complex.parse(parseSelector)), 
    // Absolute selectors can also be parsed as relative with an implied
    // descendant combinator, e.g. in `:has(h1)`. In this case the
    // whitespace that usually represents the descendant combinator in
    // complex selectors is omitted. We cannot handle that in Combinator.parse
    // as it would turn it into a "catch all" parser.
    map(Complex.parse(parseSelector), (selector) => [Combinator.Descendant, selector])), (result) => {
        const [combinator, selector] = result;
        return Relative.of(combinator, selector);
    });
})(Relative || (Relative = {}));
/**
 * Fake selector to match the anchor of a relative selector, thus allowing to
 * match an anchored relative selector as a complex one.
 */
class Exact extends BaseSelector {
    static of(anchor) {
        return new Exact(anchor);
    }
    _anchor;
    constructor(anchor) {
        super("exact", Specificity.empty(), false);
        this._anchor = anchor;
    }
    matches(element, _) {
        return element === this._anchor;
    }
    *[Symbol.iterator]() {
        return;
    }
}
//# sourceMappingURL=relative.js.map