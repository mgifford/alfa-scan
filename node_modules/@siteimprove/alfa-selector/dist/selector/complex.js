import { Element } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Parser } from "@siteimprove/alfa-parser";
import { Context } from "../context.js";
import { Specificity } from "../specificity.js";
import { Combinator } from "./combinator.js";
import { Compound } from "./compound.js";
import { BaseSelector } from "./selector.js";
const { map, pair, zeroOrMore } = Parser;
/**
 * {@link https://drafts.csswg.org/selectors/#complex}
 *
 * @public
 */
export class Complex extends BaseSelector {
    static of(combinator, left, right) {
        return new Complex(combinator, left, right);
    }
    _combinator;
    _left;
    _right;
    _key;
    constructor(combinator, left, right) {
        super("complex", Specificity.sum(left.specificity, right.specificity), left.useContext || right.useContext);
        this._combinator = combinator;
        this._left = left;
        this._right = right;
        this._key = right.key;
    }
    get combinator() {
        return this._combinator;
    }
    get left() {
        return this._left;
    }
    get right() {
        return this._right;
    }
    matches(element, context) {
        return Combinator.matcher(this._left, this._combinator, this._right, element, context);
    }
    equals(value) {
        return (value instanceof Complex &&
            value._combinator === this._combinator &&
            value._left.equals(this._left) &&
            value._right.equals(this._right));
    }
    *[Symbol.iterator]() {
        yield this;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            combinator: this._combinator,
            left: this._left.toJSON(),
            right: this._right.toJSON(),
        };
    }
    toString() {
        const combinator = this._combinator === Combinator.Descendant
            ? " "
            : ` ${this._combinator} `;
        return `${this._left}${combinator}${this._right}`;
    }
}
/**
 * @public
 */
(function (Complex) {
    function isComplex(value) {
        return value instanceof Complex;
    }
    Complex.isComplex = isComplex;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-complex-selector}
     *
     * @internal
     */
    Complex.parse = (parseSelector) => map(pair(Compound.parse(parseSelector), zeroOrMore(pair(Combinator.parse, Compound.parse(parseSelector)))), (result) => {
        const [left, selectors] = result;
        return Iterable.reduce(selectors, (left, [combinator, right]) => Complex.of(combinator, left, right), left);
    });
})(Complex || (Complex = {}));
//# sourceMappingURL=complex.js.map