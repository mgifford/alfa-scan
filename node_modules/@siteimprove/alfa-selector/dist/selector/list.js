import { Array } from "@siteimprove/alfa-array";
import { Comma, Token } from "@siteimprove/alfa-css";
import { Parser } from "@siteimprove/alfa-parser";
import { Specificity } from "../specificity.js";
import { Complex } from "./complex.js";
import { Relative as BaseRelative } from "./relative.js";
import { BaseSelector } from "./selector.js";
const { either, end, map, separatedList } = Parser;
/**
 * {@link https://drafts.csswg.org/selectors/#selector-list}
 *
 * @public
 */
export class List extends BaseSelector {
    static of(...selectors) {
        return new List(selectors);
    }
    _selectors;
    _length;
    constructor(selectors) {
        super("list", Specificity.max(...selectors.map((selector) => selector.specificity)), selectors.some(selector => selector.useContext));
        this._selectors = selectors;
        this._length = selectors.length;
    }
    get selectors() {
        return this._selectors;
    }
    get length() {
        return this._length;
    }
    matches(element, context) {
        return this._selectors.some((selector) => selector.matches(element, context));
    }
    /**
     * Returns either the list or its unique item if it contains only one.
     *
     * @internal
     */
    simplify() {
        if (this._selectors.length === 1) {
            return this._selectors[0];
        }
        return this;
    }
    equals(value) {
        return (value instanceof List && Array.equals(value._selectors, this._selectors));
    }
    *[Symbol.iterator]() {
        yield* this._selectors;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            selectors: Array.toJSON(this._selectors),
        };
    }
    toString() {
        return this._selectors.map((selector) => selector.toString()).join(", ");
    }
}
/**
 * @public
 */
(function (List) {
    function isList(value) {
        return value instanceof List;
    }
    List.isList = isList;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-selector-list}
     * {@link https://drafts.csswg.org/selectors/#typedef-complex-selector-list}
     * {@link https://drafts.csswg.org/selectors/#typedef-compound-selector-list}
     * {@link https://drafts.csswg.org/selectors/#typedef-simple-selector-list}
     * {@link https://drafts.csswg.org/selectors/#typedef-relative-selector-list}
     *
     * {@link https://drafts.csswg.org/selectors/#forgiving-selector}
     *
     * @remarks
     * We automatically simplify lists of 1 item as a way to speed up a bit
     * matching. Thus, we do not need to unwrap a 1-item list at every match.
     * List may end up totally empty, in the case of forgiving lists containing
     * only invalid selectors. This is expected by CSS syntax. In that case, we
     * keep the list. It is up to the wrapper to decide whether to match an empty
     * list.
     *
     * Only the top-level list needs to know whether it is forgiving or not. Inner
     * lists parsing depend on their contexts.
     * E.g., `:is(###, div)` is valid (forgiving list for `:is`), but
     * `:is(:not(###, div))` is not (non-forgiving list for `:not`, even in a
     * forgiving context).
     */
    function parseList(parseSelector, options) {
        const parser = (options?.forgiving ?? false)
            ? // In a forgiving context, if the parser errors, we discard all tokens
                // until the next comma.
                either(parseSelector(), Token.skipUntil(either(Comma.parse, end((token) => `Unexpected token ${token}`))))
            : parseSelector();
        return map(separatedList(parser, Comma.parse), (result) => List.of(...result.filter((result) => result !== undefined)).simplify());
    }
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-selector-list}
     * {@link https://drafts.csswg.org/selectors/#typedef-complex-selector-list}
     *
     * @internal
     */
    List.parseComplex = (parseSelector, options) => parseList(() => Complex.parse(parseSelector), options);
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-relative-selector-list}
     *
     * @internal
     */
    List.parseRelative = (parseSelector, options) => parseList(() => BaseRelative.parse(parseSelector), options);
    /** @internal */
    function parse(parseSelector, options) {
        return (options?.relative ?? false)
            ? List.parseRelative(parseSelector, options)
            : List.parseComplex(parseSelector, options);
    }
    List.parse = parse;
})(List || (List = {}));
//# sourceMappingURL=list.js.map