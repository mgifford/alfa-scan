import { type Parser as CSSParser } from "@siteimprove/alfa-css";
import { Element } from "@siteimprove/alfa-dom";
import { BaseSelector } from "./selector.js";
import { Context } from "../context.js";
import type { Selector } from "./index.js";
/**
 * {@link https://drafts.csswg.org/selectors/#selector-combinator}
 *
 * @public
 */
export declare enum Combinator {
    /**
     * @example div span
     */
    Descendant = " ",
    /**
     * @example div \> span
     */
    DirectDescendant = ">",
    /**
     * @example div ~ span
     */
    Sibling = "~",
    /**
     * @example div + span
     */
    DirectSibling = "+"
}
/**
 * @public
 */
export declare namespace Combinator {
    /**
     * Does the element match the combinator, with left and right selectors?
     *
     * This is used both for Complex selectors matching and for Relative selectors
     * matching, hence it is defined here to re-use code.
     *
     * @remarks
     * This gets pretty hairy when shadow selectors (:host, :host-context,
     * ::slotted) are used in a complex selector.
     * * ::slotted may be used in the rightmost, e.g., `div ::slotted(p)`.
     *   In that case, the full selector matches something in the light,
     *   depending on the structure of the shadow tree. Thus, the full selector must
     *   be considered as a shadow selector (it matches out of its tree), and this
     *   can simply use tree traversal options to navigate the flat tree
     *   structure. However, the actual match toward the element must use the
     *   advanced #matchSlotted.
     * * :host and :host-context may be used as the leftmost, e.g., `:host(.foo) p`.
     *   This is useful to let users customise components through a simple
     *   class name on the custom element. In this case, the full selector
     *   matches something in the shadow tree and the full selector must **not**
     *   be considered as shadow selector (it matches in its own tree). But upon
     *   hitting the :host or :host-context, the matching must be delegated to
     *   the advance #matchHost (and jump over the shadow root to the actual
     *   host).
     *
     * @privateRemarks
     * Due to the recursive nature of the check, we oversimplify it a bit.
     * Namely, we do not really check that ::slotted appears in the rightmost
     * position only. This means that we incorrectly match thinks like
     * `div ::slotted(*) span` to a <span> descendant **in the light tree** of the
     * slotted element. This is incorrect, see CSS discussions about the
     * deprecated ::content. However, this shouldn't be a problem because
     * Selector.isShadow classify complex selectors by the presence of
     * ::slotted in the rightmost position only. Therefore, such a selector
     * will try to match in its own tree and fail to match the slotted element.
     *
     * In the rare case where (i) people use this incorrect structure and (ii)
     * it happens that there is a sub-shadow tree with structure similar enough
     * to cause the match, this will be incorrect, but we can probably live with
     * it until we see it.
     */
    function matcher(left: BaseSelector, combinator: Combinator, right: Selector, element: Element, context?: Context): boolean;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-combinator}
     *
     * @internal
     */
    const parse: CSSParser<Combinator>;
}
//# sourceMappingURL=combinator.d.ts.map