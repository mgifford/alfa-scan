import { type Token as CSSToken } from "@siteimprove/alfa-css";
import { type Parser as CSSParser } from "@siteimprove/alfa-parser";
import type { Slice } from "@siteimprove/alfa-slice";
import type { Selector } from "../index.js";
import { Attribute } from "./attribute.js";
import { Class } from "./class.js";
import { Id } from "./id.js";
import { PseudoClass } from "../pseudo/pseudo-class/index.js";
import { PseudoElement } from "../pseudo/pseudo-element/index.js";
import { Type } from "./type.js";
import { Universal } from "./universal.js";
export * from "./attribute.js";
export * from "./class.js";
export * from "./id.js";
export * from "../pseudo/pseudo-class/index.js";
export * from "../pseudo/pseudo-element/index.js";
export * from "./type.js";
export * from "./universal.js";
/**
 * {@link https://drafts.csswg.org/selectors/#simple}
 *
 * @public
 */
export type Simple = Type | Universal | Attribute | Class | Id | PseudoClass | PseudoElement;
/**
 * @public
 */
export declare namespace Simple {
    type JSON = Type.JSON | Universal.JSON | Attribute.JSON | Class.JSON | Id.JSON | PseudoClass.JSON | PseudoElement.JSON;
    function isSimple(value: unknown): value is Simple;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-simple-selector}
     *
     * @privateRemarks
     * This function is a hot path and uses token lookahead for simple cases
     * to avoid backtracking. Any changes to this function should be benchmarked.
     *
     * @internal
     */
    const parse: (parseSelector: Selector.Parser.Component) => CSSParser<Slice<CSSToken>, Simple, string>;
}
//# sourceMappingURL=index.d.ts.map