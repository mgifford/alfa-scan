import { Token } from "@siteimprove/alfa-css";
import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Specificity } from "../../specificity.js";
import { WithName } from "../selector.js";
import { parseName } from "./parser.js";
const { delimited, either, left, map, option, pair } = Parser;
const { and, equals, property } = Predicate;
/**
 * {@link https://drafts.csswg.org/selectors/#attribute-selector}
 *
 * @public
 */
export class Attribute extends WithName {
    static of(namespace, name, value = None, matcher = None, modifier = None) {
        return new Attribute(namespace, name, value, matcher, modifier);
    }
    _namespace;
    _value;
    _matcher;
    _modifier;
    constructor(namespace, name, value, matcher, modifier) {
        super("attribute", name, Specificity.of(0, 1, 0), false);
        this._namespace = namespace;
        this._value = value;
        this._matcher = matcher;
        this._modifier = modifier;
    }
    get namespace() {
        return this._namespace;
    }
    get value() {
        return this._value;
    }
    get matcher() {
        return this._matcher;
    }
    get modifier() {
        return this._modifier;
    }
    matches(element) {
        for (const namespace of this._namespace) {
            let predicate;
            switch (namespace) {
                case "*":
                    predicate = property("name", equals(this._name));
                    break;
                case "":
                    predicate = and(property("name", equals(this._name)), property("namespace", equals(None)));
                    break;
                default:
                    predicate = and(property("name", equals(this._name)), property("namespace", equals(namespace)));
            }
            return Iterable.some(element.attributes, and(predicate, (attribute) => this.matchesValue(attribute.value)));
        }
        return element
            .attribute(this._name)
            .some((attribute) => this.matchesValue(attribute.value));
    }
    matchesValue(value) {
        for (const modifier of this._modifier) {
            switch (modifier) {
                case Attribute.Modifier.CaseInsensitive:
                    value = value.toLowerCase();
            }
        }
        for (const match of this._value) {
            switch (this._matcher.getOr(Attribute.Matcher.Equal)) {
                case Attribute.Matcher.Equal:
                    return value === match;
                case Attribute.Matcher.Prefix:
                    return value.startsWith(match);
                case Attribute.Matcher.Suffix:
                    return value.endsWith(match);
                case Attribute.Matcher.Substring:
                    return value.includes(match);
                case Attribute.Matcher.DashMatch:
                    return value === match || value.startsWith(`${match}-`);
                case Attribute.Matcher.Includes:
                    return value.split(/\s+/).some(equals(match));
            }
        }
        return true;
    }
    equals(value) {
        return (value instanceof Attribute &&
            value._namespace.equals(this._namespace) &&
            value._name === this._name &&
            value._value.equals(this._value) &&
            value._matcher.equals(this._matcher) &&
            value._modifier.equals(this._modifier));
    }
    *[Symbol.iterator]() {
        yield this;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            namespace: this._namespace.getOr(null),
            value: this._value.getOr(null),
            matcher: this._matcher.getOr(null),
            modifier: this._modifier.getOr(null),
        };
    }
    toString() {
        const namespace = this._namespace
            .map((namespace) => `${namespace}|`)
            .getOr("");
        const value = this._value
            .map((value) => `"${JSON.stringify(value)}"`)
            .getOr("");
        const matcher = this._matcher.getOr("");
        const modifier = this._modifier.map((modifier) => ` ${modifier}`).getOr("");
        return `[${namespace}${this._name}${matcher}${value}${modifier}]`;
    }
}
/**
 * @public
 */
(function (Attribute) {
    let Matcher;
    (function (Matcher) {
        /**
         * @example [foo=bar]
         */
        Matcher["Equal"] = "=";
        /**
         * @example [foo~=bar]
         */
        Matcher["Includes"] = "~=";
        /**
         * @example [foo|=bar]
         */
        Matcher["DashMatch"] = "|=";
        /**
         * @example [foo^=bar]
         */
        Matcher["Prefix"] = "^=";
        /**
         * @example [foo$=bar]
         */
        Matcher["Suffix"] = "$=";
        /**
         * @example [foo*=bar]
         */
        Matcher["Substring"] = "*=";
    })(Matcher = Attribute.Matcher || (Attribute.Matcher = {}));
    let Modifier;
    (function (Modifier) {
        /**
         * @example [foo=bar i]
         */
        Modifier["CaseInsensitive"] = "i";
        /**
         * @example [foo=Bar s]
         */
        Modifier["CaseSensitive"] = "s";
    })(Modifier = Attribute.Modifier || (Attribute.Modifier = {}));
    function isAttribute(value) {
        return value instanceof Attribute;
    }
    Attribute.isAttribute = isAttribute;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-attr-matcher}
     */
    const parseMatcher = map(left(option(either(Token.parseDelim("~"), Token.parseDelim("|"), Token.parseDelim("^"), Token.parseDelim("$"), Token.parseDelim("*"))), Token.parseDelim("=")), (delim) => delim.isSome()
        ? `${delim.get()}=`
        : Attribute.Matcher.Equal);
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-attr-modifier}
     */
    const parseModifier = either(map(Token.parseIdent("i"), () => Attribute.Modifier.CaseInsensitive), map(Token.parseIdent("s"), () => Attribute.Modifier.CaseSensitive));
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-attribute-selector}
     *
     * @internal
     */
    Attribute.parse = map(delimited(Token.parseOpenSquareBracket, pair(parseName, option(pair(pair(parseMatcher, either(Token.parseString(), Token.parseIdent())), delimited(option(Token.parseWhitespace), option(parseModifier))))), Token.parseCloseSquareBracket), (result) => {
        const [[namespace, name], rest] = result;
        if (rest.isSome()) {
            const [[matcher, value], modifier] = rest.get();
            return Attribute.of(namespace, name, Option.of(value.value), Option.of(matcher), modifier);
        }
        return Attribute.of(namespace, name);
    });
})(Attribute || (Attribute = {}));
//# sourceMappingURL=attribute.js.map