import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Specificity } from "../../specificity.js";
import { WithName } from "../selector.js";
import { parseName } from "./parser.js";
const { map } = Parser;
/**
 * {@link https://drafts.csswg.org/selectors/#type-selector}
 *
 * @public
 */
export class Type extends WithName {
    static of(namespace, name) {
        return new Type(namespace, name);
    }
    _namespace;
    _key;
    constructor(namespace, name) {
        super("type", name, Specificity.of(0, 0, 1), false);
        this._namespace = namespace;
        this._key = Option.of(this);
    }
    get namespace() {
        return this._namespace;
    }
    matches(element) {
        if (this._name !== element.name) {
            return false;
        }
        if (this._namespace.isNone() || this._namespace.includes("*")) {
            return true;
        }
        return element.namespace.equals(this._namespace);
    }
    equals(value) {
        return (value instanceof Type &&
            value._namespace.equals(this._namespace) &&
            value._name === this._name);
    }
    *[Symbol.iterator]() {
        yield this;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            namespace: this._namespace.getOr(null),
        };
    }
    toString() {
        const namespace = this._namespace
            .map((namespace) => `${namespace}|`)
            .getOr("");
        return `${namespace}${this._name}`;
    }
}
/**
 * @public
 */
(function (Type) {
    function isType(value) {
        return value instanceof Type;
    }
    Type.isType = isType;
    /**
     * {@link https://drafts.csswg.org/selectors/#typedef-type-selector}
     *
     * @internal
     */
    Type.parse = map(parseName, ([namespace, name]) => Type.of(namespace, name));
})(Type || (Type = {}));
//# sourceMappingURL=type.js.map