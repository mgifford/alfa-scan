import { type Comparer } from "@siteimprove/alfa-comparable";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import type { Serializable } from "@siteimprove/alfa-json";
import type * as json from "@siteimprove/alfa-json";
/**
 * {@link https://www.w3.org/TR/selectors/#specificity}
 * {@link https://drafts.csswg.org/css-cascade-5/#cascade-specificity}
 *
 * @remarks
 * Specificities are triplet (a, b, c), ordered lexicographically.
 * We also store a 32 bits integer representing the specificity with 10 bits
 * per components (and 2 wasted bits). This allows for quick lexicographic
 * comparison, which is the frequent operation on specificities. Components are
 * therefore limited to 1024 values (10 bits).
 *
 * @public
 */
export declare class Specificity implements Serializable<Specificity.JSON>, Equatable, Hashable {
    static of(a: number, b: number, c: number): Specificity;
    private static _empty;
    static empty(): Specificity;
    private static _pseudoClass;
    static pseudoClass(): Specificity;
    private readonly _a;
    private readonly _b;
    private readonly _c;
    private readonly _value;
    protected constructor(a: number, b: number, c: number);
    get a(): number;
    get b(): number;
    get c(): number;
    get value(): number;
    equals(value: Specificity): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(): Specificity.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Specificity {
    interface JSON {
        [key: string]: json.JSON;
        a: number;
        b: number;
        c: number;
    }
    function isSpecificity(value: unknown): value is Specificity;
    function sum(...specificities: ReadonlyArray<Specificity>): Specificity;
    function max(...specificities: ReadonlyArray<Specificity>): Specificity;
    const compare: Comparer<Specificity>;
}
//# sourceMappingURL=specificity.d.ts.map