import type { Mapper } from "@siteimprove/alfa-mapper";
import { Iterable } from "@siteimprove/alfa-iterable";
/**
 * {@link https://en.wikipedia.org/wiki/Three-valued_logic}
 *
 * @public
 */
export type Trilean = boolean | undefined;
/**
 * @public
 */
export declare namespace Trilean {
    type Predicate<T, A extends Array<unknown> = []> = (value: T, ...args: A) => Trilean;
    function test<T, A extends Array<unknown> = []>(predicate: Predicate<T, A>, value: T, ...args: A): Trilean;
    function fold<T, A extends Array<unknown> = [], V = T, W = T, X = T>(predicate: Predicate<T, A>, ifTrue: Mapper<T, V>, ifFalse: Mapper<T, W>, ifUndefined: Mapper<T, X>, value: T, ...args: A): V | W | X;
    function not<T, A extends Array<unknown> = []>(predicate: Predicate<T, A>): Predicate<T, A>;
    function and<T, A extends Array<unknown> = []>(...predicates: [Predicate<T, A>, Predicate<T, A>, ...Array<Predicate<T, A>>]): Predicate<T, A>;
    function or<T, A extends Array<unknown> = []>(...predicates: [Predicate<T, A>, Predicate<T, A>, ...Array<Predicate<T, A>>]): Predicate<T, A>;
    function xor<T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    function nor<T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    function nand<T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    function some<T>(iterable: Iterable<T>, predicate: Predicate<T, [number]>): Trilean;
    function none<T>(iterable: Iterable<T>, predicate: Predicate<T, [number]>): Trilean;
    function every<T>(iterable: Iterable<T>, predicate: Predicate<T, [number]>): Trilean;
}
//# sourceMappingURL=trilean.d.ts.map