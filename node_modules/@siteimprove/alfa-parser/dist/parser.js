import { Array } from "@siteimprove/alfa-array";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Result } from "@siteimprove/alfa-result";
const { not } = Predicate;
/**
 * @public
 */
export var Parser;
(function (Parser) {
    function toParser(infallible) {
        return (input, ...args) => Result.of(infallible(input, ...args));
    }
    Parser.toParser = toParser;
    function map(parser, mapper) {
        return (input, ...args) => parser(input, ...args).map(([remainder, value]) => [
            remainder,
            mapper(value),
        ]);
    }
    Parser.map = map;
    function mapResult(parser, mapper) {
        return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value).map((result) => [remainder, result]));
    }
    Parser.mapResult = mapResult;
    function flatMap(parser, mapper) {
        return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value)(remainder, ...args));
    }
    Parser.flatMap = flatMap;
    function filter(parser, predicate, ifError) {
        return mapResult(parser, (value) => predicate(value) ? Result.of(value) : Err.of(ifError(value)));
    }
    Parser.filter = filter;
    function reject(parser, predicate, ifError) {
        return filter(parser, not(predicate), ifError);
    }
    Parser.reject = reject;
    function zeroOrMore(parser) {
        return takeAtLeast(parser, 0);
    }
    Parser.zeroOrMore = zeroOrMore;
    function oneOrMore(parser) {
        // The result contains at least one token, so this cast is safe
        return takeAtLeast(parser, 1);
    }
    Parser.oneOrMore = oneOrMore;
    function take(parser, count) {
        return takeBetween(parser, count, count);
    }
    Parser.take = take;
    function takeBetween(parser, lower, upper) {
        return (input, ...args) => {
            const values = [];
            let value;
            for (let i = 0; i < upper; i++) {
                const result = parser(input, ...args);
                if (result.isOk()) {
                    [input, value] = result.get();
                    values.push(value);
                }
                else if (result.isErr()) {
                    if (values.length < lower) {
                        return result;
                    }
                    else {
                        break;
                    }
                }
            }
            return Result.of([input, values]);
        };
    }
    Parser.takeBetween = takeBetween;
    function takeAtLeast(parser, lower) {
        return takeBetween(parser, lower, Infinity);
    }
    Parser.takeAtLeast = takeAtLeast;
    function takeAtMost(parser, upper) {
        return takeBetween(parser, 0, upper);
    }
    Parser.takeAtMost = takeAtMost;
    function takeUntil(parser, condition) {
        return (input, ...args) => {
            const values = [];
            let value;
            while (true) {
                if (condition(input, ...args).isOk()) {
                    return Result.of([input, values]);
                }
                const result = parser(input, ...args);
                if (result.isOk()) {
                    [input, value] = result.get();
                    values.push(value);
                }
                else if (result.isErr()) {
                    return result;
                }
            }
        };
    }
    Parser.takeUntil = takeUntil;
    function skip(parser) {
        return map(parser, () => undefined);
    }
    Parser.skip = skip;
    function skipUntil(parser, delimiter) {
        return skip(takeUntil(parser, delimiter));
    }
    Parser.skipUntil = skipUntil;
    function peek(parser) {
        return (input, ...args) => parser(input, ...args).map(([, value]) => [input, value]);
    }
    Parser.peek = peek;
    function tee(parser, callback) {
        return (input, ...args) => parser(input, ...args).tee(([remainder, result]) => {
            callback(result, remainder, ...args);
        });
    }
    Parser.tee = tee;
    function teeErr(parser, callback) {
        return (input, ...args) => parser(input, ...args).teeErr((err) => {
            callback(err, ...args);
        });
    }
    Parser.teeErr = teeErr;
    function option(parser) {
        return (input, ...args) => {
            const result = parser(input, ...args);
            if (result.isOk()) {
                const [input, value] = result.get();
                return Result.of([input, Option.of(value)]);
            }
            return Result.of([input, None]);
        };
    }
    Parser.option = option;
    function either(...parsers) {
        return (input, ...args) => {
            let error;
            for (const parser of parsers) {
                const result = parser(input, ...args);
                if (result.isErr()) {
                    error = result;
                }
                else {
                    return result;
                }
            }
            // Per the function overloads, there will always be at least one parser
            // specified. It is therefore safe to assert that if we get this far, at
            // least one parser will have produced an error.
            return error;
        };
    }
    Parser.either = either;
    /**
     * Select a parser based on the peeked value.
     *
     * @remarks
     * This is more efficient than a long chain of `either` since it does not try
     * to re-parse the input multiple times after the first parser failed, if the
     * peeked value is enough to differentiate the input.
     *
     * The parser will receive the full input, no matter how much the peeker looks
     * at or tries to consume. The peeked tokens will be looked at twice, so the
     * peeker should only be looking at a small number of tokens.
     */
    function exclusive(peeker, getParser) {
        return flatMap(peek(peeker), getParser);
    }
    Parser.exclusive = exclusive;
    function pair(left, right) {
        return flatMap(left, (left) => map(right, (right) => [left, right]));
    }
    Parser.pair = pair;
    function left(left, ...right) {
        return (input, ...args) => {
            const first = left(input, ...args);
            if (!first.isOk()) {
                return first;
            }
            let [remainder, result] = first.get();
            for (const parser of right) {
                const next = parser(remainder, ...args);
                if (next.isErr()) {
                    return next;
                }
                [remainder] = next.getUnsafe();
            }
            return Result.of([remainder, result]);
        };
    }
    Parser.left = left;
    function right(left, right) {
        return flatMap(left, () => map(right, (right) => right));
    }
    Parser.right = right;
    function delimited(left, parser, right = left) {
        return flatMap(left, () => flatMap(parser, (parser) => map(right, () => parser)));
    }
    Parser.delimited = delimited;
    function separated(left, separator, right = left) {
        return flatMap(left, (left) => flatMap(separator, () => map(right, (right) => [left, right])));
    }
    Parser.separated = separated;
    /**
     * Parse a separated list containing at least one item
     *
     * @param parser - Parser for the items in the list
     * @param separator - Parser for the separator between items
     * @param lower - Minimum number of items to parse, defaults to 1
     * @param upper - Maximum number of items to parse, defaults to Infinity
     */
    function separatedList(parser, separator, lower = 1, upper = Infinity) {
        return map(pair(parser, takeBetween(right(separator, parser), Math.max(0, lower - 1), Math.min(Infinity, upper - 1))), ([first, rest]) => Array.prepend(rest, first));
    }
    Parser.separatedList = separatedList;
    /**
     * Turns `[Parser<A>, Parser<B>, Parser<C>]` into `Parser<[A,  B,  C]>`
     */
    function array(separator, ...parsers) {
        return (input, ...args) => {
            const result = [];
            for (const parser of parsers) {
                // Skip leading separators
                for (const [remainder] of separator(input, ...args)) {
                    input = remainder;
                }
                const parsed = parser(input, ...args);
                if (parsed.isErr()) {
                    return parsed;
                }
                const [next, value] = parsed.getUnsafe();
                input = next;
                result.push(value);
            }
            return Result.of([input, result]);
        };
    }
    Parser.array = array;
    /**
     * {@link https://drafts.csswg.org/css-values-4/#comb-any}
     * Turns `[Parser<A>, Parser<B>, Parser<C>]` into `Parser<A || B || C>`
     *
     * @Remarks
     * This parser never fails and will return an array of `undefined` if none
     * of the individual parsers succeed. It is nonetheless easier to not define
     * it as Infallible since call sites usually expect Parser and combinators.
     *
     * Be careful that no early parser can accept a prefix of what a later one
     * accepts. Otherwise, the early parser will incorrectly consume the tokens
     * of the later one.
     * That is, `doubleBar(parseFoo, parseFoobar)` will happily consume the "foo"
     * in "foobar" and thus incorrectly "fail" on "foobar foo" (`parseFoo` consumes
     * the "foo" in "foobar" leaving "bar foo" that cannot be parsed further).
     */
    function doubleBar(separator, ...parsers) {
        const size = parsers.length;
        return (input, ...args) => {
            const result = globalThis
                .Array(size)
                .map(() => undefined);
            // The main loop goes through the input, testing all parsers until one
            // matches and looping back immediately to parse the next token.
            mainLoop: while (true) {
                // First, skip leading separators
                for (const [remainder] of separator(input, ...args)) {
                    input = remainder;
                }
                // Next, test all parsers until a match is found.
                for (let i = 0; i < size; i++) {
                    // If this parser already succeeded, move on to the next one
                    if (result[i] !== undefined) {
                        // This continues the parsers loop, not the main loop.
                        continue;
                    }
                    // Try the parser
                    const parsed = parsers[i](input, ...args);
                    if (parsed.isOk()) {
                        [input, result[i]] = parsed.get();
                        // Once a parser succeeds, we want to restart the main loop, so we
                        // can again test all parsers in order. We could keep going with
                        // the remaining parsers, but then we might need to also test the
                        // previous ones, â€¦
                        // This is just cleaner logic.
                        continue mainLoop;
                    }
                }
                // If no parser succeeds (or they all already produced a value), we're
                // done with the input and can finally escape the main loop.
                break;
            }
            return Result.of([input, result]);
        };
    }
    Parser.doubleBar = doubleBar;
    function end(ifError) {
        return (input) => {
            for (const value of input) {
                return Err.of(ifError(value));
            }
            return Result.of([input, undefined]);
        };
    }
    Parser.end = end;
    function final(parser, ifError) {
        return left(parser, end(ifError));
    }
    Parser.final = final;
})(Parser || (Parser = {}));
//# sourceMappingURL=parser.js.map