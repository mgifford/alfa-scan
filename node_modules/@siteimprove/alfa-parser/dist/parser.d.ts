import { Array } from "@siteimprove/alfa-array";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { Result } from "@siteimprove/alfa-result";
/**
 * @public
 */
export type Parser<I, T, E = never, A extends Array<unknown> = []> = (input: I, ...args: A) => Result<[I, T], E>;
/**
 * @public
 */
export declare namespace Parser {
    export type Infallible<I, T, A extends Array<unknown> = []> = (input: I, ...args: A) => [I, T];
    export function toParser<I, T, A extends Array<unknown> = []>(infallible: Parser.Infallible<I, T, A>): Parser<I, T, never, A>;
    export function map<I, T, U, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, mapper: Mapper<T, U>): Parser<I, U, E, A>;
    export function mapResult<I, T, U, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, mapper: Mapper<T, Result<U, E>>): Parser<I, U, E, A>;
    export function flatMap<I, T, U, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, mapper: Mapper<T, Parser<I, U, E, A>>): Parser<I, U, E, A>;
    export function filter<I, T, U extends T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, refinement: Refinement<T, U>, ifError: Mapper<T, E>): Parser<I, U, E, A>;
    export function filter<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, predicate: Predicate<T>, ifError: Mapper<T, E>): Parser<I, T, E, A>;
    export function reject<I, T, U extends T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, refinement: Refinement<T, U>, ifError: Mapper<T, E>): Parser<I, Exclude<T, U>, E, A>;
    export function reject<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, predicate: Predicate<T>, ifError: Mapper<T, E>): Parser<I, T, E, A>;
    export function zeroOrMore<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>): Parser<I, Array<T>, E, A>;
    export function oneOrMore<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>): Parser<I, [T, ...Array<T>], E, A>;
    export function take<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, count: number): Parser<I, Array<T>, E, A>;
    export function takeBetween<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, lower: number, upper: number): Parser<I, Array<T>, E, A>;
    export function takeAtLeast<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, lower: number): Parser<I, Array<T>, E, A>;
    export function takeAtMost<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, upper: number): Parser<I, Array<T>, E, A>;
    export function takeUntil<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, condition: Parser<I, unknown, E, A>): Parser<I, Array<T>, E, A>;
    export function skip<I, E, A extends Array<unknown> = []>(parser: Parser<I, unknown, E, A>): Parser<I, void, E, A>;
    export function skipUntil<I, E, A extends Array<unknown> = []>(parser: Parser<I, unknown, E, A>, delimiter: Parser<I, unknown, E, A>): Parser<I, void, E, A>;
    export function peek<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>): Parser<I, T, E, A>;
    export function tee<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, callback: Callback<T, void, [remainder: I, ...args: A]>): Parser<I, T, E, A>;
    export function teeErr<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, callback: Callback<E, void, A>): Parser<I, T, E, A>;
    export function option<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>): Parser<I, Option<T>, E, A>;
    export function either<I, T, U, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, right: Parser<I, U, E, A>): Parser<I, T | U, E, A>;
    export function either<I, T, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, right: Parser<I, T, E, A>, ...rest: Array<Parser<I, T, E, A>>): Parser<I, T, E, A>;
    /**
     * Select a parser based on the peeked value.
     *
     * @remarks
     * This is more efficient than a long chain of `either` since it does not try
     * to re-parse the input multiple times after the first parser failed, if the
     * peeked value is enough to differentiate the input.
     *
     * The parser will receive the full input, no matter how much the peeker looks
     * at or tries to consume. The peeked tokens will be looked at twice, so the
     * peeker should only be looking at a small number of tokens.
     */
    export function exclusive<I, T, U, E, A extends Array<unknown> = []>(peeker: Parser<I, T, E, A>, getParser: Mapper<T, Parser<I, U, E, A>>): Parser<I, U, E, A>;
    export function pair<I, T, U, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, right: Parser<I, U, E, A>): Parser<I, [T, U], E, A>;
    export function left<I, T, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, ...right: Array<Parser<I, unknown, E, A>>): Parser<I, T, E, A>;
    export function right<I, T, U, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, right: Parser<I, U, E, A>): Parser<I, U, E, A>;
    export function delimited<I, T, E, A extends Array<unknown> = []>(delimiter: Parser<I, unknown, E, A>, parser: Parser<I, T, E, A>): Parser<I, T, E, A>;
    export function delimited<I, T, E, A extends Array<unknown> = []>(left: Parser<I, unknown, E, A>, parser: Parser<I, T, E, A>, right: Parser<I, unknown, E, A>): Parser<I, T, E, A>;
    export function separated<I, T, U, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, separator: Parser<I, unknown, E, A>): Parser<I, [T, T], E, A>;
    export function separated<I, T, U, E, A extends Array<unknown> = []>(left: Parser<I, T, E, A>, separator: Parser<I, unknown, E, A>, right: Parser<I, U, E, A>): Parser<I, [T, U], E, A>;
    /**
     * Parse a separated list containing at least one item
     *
     * @param parser - Parser for the items in the list
     * @param separator - Parser for the separator between items
     * @param lower - Minimum number of items to parse, defaults to 1
     * @param upper - Maximum number of items to parse, defaults to Infinity
     */
    export function separatedList<I, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, separator: Parser<I, unknown, E, A>, lower?: number, upper?: number): Parser<I, [T, ...Array<T>], E, A>;
    /**
     * Turns `[Parser<A>, Parser<B>, Parser<C>]` into `Parser<[A,  B,  C]>`
     */
    export function array<I, T extends Array<unknown>, E, A extends Array<unknown> = []>(separator: Parser<I, any, E, A>, ...parsers: ToParsers<I, T, E, A>): Parser<I, T, E, A>;
    /**
     * {@link https://drafts.csswg.org/css-values-4/#comb-any}
     * Turns `[Parser<A>, Parser<B>, Parser<C>]` into `Parser<A || B || C>`
     *
     * @Remarks
     * This parser never fails and will return an array of `undefined` if none
     * of the individual parsers succeed. It is nonetheless easier to not define
     * it as Infallible since call sites usually expect Parser and combinators.
     *
     * Be careful that no early parser can accept a prefix of what a later one
     * accepts. Otherwise, the early parser will incorrectly consume the tokens
     * of the later one.
     * That is, `doubleBar(parseFoo, parseFoobar)` will happily consume the "foo"
     * in "foobar" and thus incorrectly "fail" on "foobar foo" (`parseFoo` consumes
     * the "foo" in "foobar" leaving "bar foo" that cannot be parsed further).
     */
    export function doubleBar<I, T extends Array<unknown>, E, A extends Array<unknown> = []>(separator: Parser<I, any, E, A>, ...parsers: ToParsers<I, T, E, A>): Parser<I, Maybe<T>, E, A>;
    /**
     * Turns `[A, B, C]` into `[Parser<A>, Parser<B>, Parser<C>]`
     */
    type ToParsers<I, T extends Array<unknown>, E, A extends Array<unknown> = []> = T extends [infer Head, ...infer Tail] ? [Parser<I, Head, E, A>, ...ToParsers<I, Tail, E, A>] : [];
    /**
     * Turns `[A, B, C]` into `[A | undefined, B | undefined, C | undefined]`
     */
    type Maybe<T extends Array<unknown>> = T extends [infer Head, ...infer Tail] ? [Head | undefined, ...Maybe<Tail>] : [];
    export function end<I extends Iterable<unknown>, E>(ifError: Mapper<I extends Iterable<infer T> ? T : unknown, E>): Parser<I, void, E, Array<any>>;
    export function final<I extends Iterable<unknown>, T, E, A extends Array<unknown> = []>(parser: Parser<I, T, E, A>, ifError: Mapper<I extends Iterable<infer T> ? T : unknown, E>): Parser<I, T, E, A>;
    export {};
}
//# sourceMappingURL=parser.d.ts.map