import { Iterable } from "@siteimprove/alfa-iterable";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
/**
 * Caches are wrapper around Javascript's `WeakMap` to store transient values.
 *
 * @remarks
 * Caches are mutable! To preserve referential transparency, the preferred way
 * of using caches is to store them as a local variable (never send them as
 * parameters); and to use a single `cache.get(key, () => …)` call to retrieve
 * values from it. Ideally, use `Cache.memoize()` to create a memoized function.
 *
 * Since Caches are built on WeakMap, the keys must be objects.
 *
 * Since Caches are built on WeakMap, they do not prevent the garbage collection
 * of keys, and the associated value is then freed too. This avoids memory leaks,
 * and ensure a lightweight caching mechanism for objects that stay in memory for
 * some time.
 *
 * Typical use of Caches is to store indirect values related to a DOM tree (e.g.,
 * the associated ARIA tree, …) Once the audit is done and the DOM tree is
 * discarded, the cache is automatically freed.
 *
 * @public
 */
export declare class Cache<K extends Cache.Key, V> {
    /**
     * Creates an empty cache.
     */
    static empty<K extends Cache.Key, V>(): Cache<K, V>;
    private readonly _storage;
    protected constructor();
    /**
     * Returns the value (if it exists) associated with the given key.
     */
    get(key: K): Option<V>;
    /**
     * Returns the value associated with the given key; if it does not exist,
     * evaluates `ifMissing`, store the result in the cache and returns it.
     */
    get<U extends V = V>(key: K, ifMissing: Mapper<this, U>): V;
    /**
     * Tests whether a given key exists in the cache.
     */
    has(key: K): boolean;
    /**
     * Adds a key-value pair to a cache.
     *
     * @remarks
     * Avoid using this. Prefer using the `ifMissing` parameter of `get()` instead.
     */
    set(key: K, value: V): this;
    /**
     * Merges a cache with an iterable of key-value pairs.
     */
    merge(iterable: Iterable<readonly [K, V]>): this;
}
/**
 * @public
 */
export declare namespace Cache {
    /**
     * Allowed keys in a Cache.
     */
    type Key = object;
    /**
     * Creates a new cache from an iterable of key-value pairs.
     */
    function from<K extends Key, V>(iterable: Iterable<readonly [K, V]>): Cache<K, V>;
    /**
     * Memoizes a method.
     */
    function memoize<This, Args extends Array<Key>, Return>(target: (this: This, ...args: Args) => Return): (this: This, ...args: Args) => Return;
    /**
     * Memoizes a function
     *
     * @remarks
     * When memoizing a recursive function, care must be taken to also memoize the
     * recursive calls. This is best done by wrapping an anonymous function that
     * recurses on the memoized function:
     * `const foo = Cache.memoize(function (x: A): B { … foo(x2) … })`
     */
    function memoize<Args extends Array<Key>, Return>(target: (...args: Args) => Return): (...args: Args) => Return;
}
//# sourceMappingURL=cache.d.ts.map