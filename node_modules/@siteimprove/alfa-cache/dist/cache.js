import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
/**
 * Caches are wrapper around Javascript's `WeakMap` to store transient values.
 *
 * @remarks
 * Caches are mutable! To preserve referential transparency, the preferred way
 * of using caches is to store them as a local variable (never send them as
 * parameters); and to use a single `cache.get(key, () => …)` call to retrieve
 * values from it. Ideally, use `Cache.memoize()` to create a memoized function.
 *
 * Since Caches are built on WeakMap, the keys must be objects.
 *
 * Since Caches are built on WeakMap, they do not prevent the garbage collection
 * of keys, and the associated value is then freed too. This avoids memory leaks,
 * and ensure a lightweight caching mechanism for objects that stay in memory for
 * some time.
 *
 * Typical use of Caches is to store indirect values related to a DOM tree (e.g.,
 * the associated ARIA tree, …) Once the audit is done and the DOM tree is
 * discarded, the cache is automatically freed.
 *
 * @public
 */
export class Cache {
    /**
     * Creates an empty cache.
     */
    static empty() {
        return new Cache();
    }
    _storage = new WeakMap();
    constructor() { }
    get(key, ifMissing) {
        if (this._storage.has(key)) {
            const value = this._storage.get(key);
            if (ifMissing === undefined) {
                return Option.of(value);
            }
            return value;
        }
        if (ifMissing === undefined) {
            return None;
        }
        const value = ifMissing(this);
        this._storage.set(key, value);
        return value;
    }
    /**
     * Tests whether a given key exists in the cache.
     */
    has(key) {
        return this._storage.has(key);
    }
    /**
     * Adds a key-value pair to a cache.
     *
     * @remarks
     * Avoid using this. Prefer using the `ifMissing` parameter of `get()` instead.
     */
    set(key, value) {
        this._storage.set(key, value);
        return this;
    }
    /**
     * Merges a cache with an iterable of key-value pairs.
     */
    merge(iterable) {
        return Iterable.reduce(iterable, (cache, [key, value]) => cache.set(key, value), this);
    }
}
/**
 * @public
 */
(function (Cache) {
    /**
     * Creates a new cache from an iterable of key-value pairs.
     */
    function from(iterable) {
        return Cache.empty().merge(iterable);
    }
    Cache.from = from;
    /**
     * Empty object constant, used to memoize functions that are not methods.
     */
    const emptyObj = {};
    function memoize(
    // When called on an instance's method `target`, `this` is the instance.
    target) {
        // First, we create the cache.
        // Because, for methods, we run the decorator at the class level, we need
        // to add an extra layer of cache for the instances.
        // For functions, this will be a useless layer and we need to make sure
        // to always unwrap it with the same object to avoid creating one entry
        // per call.
        const cache = Cache.empty();
        // Next, we create the memoized function. Since the cache is scoped to the
        // decorator, it cannot be accessed from outside and won't be tampered with.
        return function (...args) {
            // Here, `this` is still the instance on which the (new) method is added.
            // We need to save it for later.
            const that = this;
            // We create a recursive memoized function that will traverse the cache,
            // parameter by parameter. It needs to be passed a (partial) cache
            // together with the remaining parameters.
            // This is OK since the side-effect happens only to the previously defined
            // scoped cache.
            function memoized(cache, ...innerArgs) {
                // From now on, `this` is the `memoized` function itself, hence the need
                // for an earlier copy.
                if (innerArgs.length === 0) {
                    // We have reached the end of the parameters, always hitting the cache,
                    // thus `ToCache<A, Return>` is `Return`, and `cache` is the actual
                    // return value that was `.get()` in the previous call.
                    // Typescript is completely lost here. It cannot make the connection
                    // between `innerArgs` being of length 0, and `A` being `[]`; thus is
                    // unable to correctly infer that `ToCache<A, Return>` is `Return`.
                    return cache;
                }
                // There are still parameters to handle, deconstruct them.
                const [head, ...tail] = innerArgs;
                // On that bit, TS is so lost that we just disable it…
                // @ts-ignore
                // Compute the next cache to use, by retrieving the values associated
                // with `head`. This will be either the final value (if `head` is the last
                // parameter), or a further cache.
                const next = cache.get(head, 
                // @ts-ignore
                // If `head` is not in the cache, and there are no more parameters,
                // we need to call the original function. In case of method, we need
                // to re-bind it to the original instance.
                // (we could directly return the result in that case, instead of going
                // to the next call to `memoized`; but since we need to test
                // `innerArgs.length === 0` anyway, we let that handle it)
                //
                // If `head` is not in the cache but there are more parameters,
                // we just create an empty cache.
                tail.length === 0 ? () => target.bind(that)(...args) : Cache.empty);
                // Recurse with the next cache and the remaining parameters.
                return memoized(next, ...tail);
            }
            // Finally, we can call the recursive memoized function, starting by
            // unwrapping the instance layer of the cache.
            // At this point, `this` is the instance on which the (new) method is added.
            const instanceCache = cache.get(typeof this === "object" && this !== null ? this : emptyObj, Cache.empty);
            return memoized(instanceCache, ...args);
        };
    }
    Cache.memoize = memoize;
})(Cache || (Cache = {}));
//# sourceMappingURL=cache.js.map