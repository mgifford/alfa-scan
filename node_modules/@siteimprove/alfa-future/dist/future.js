import { Array } from "@siteimprove/alfa-array";
import { Iterable } from "@siteimprove/alfa-iterable";
/**
 * {@link http://blog.higher-order.com/assets/trampolines.pdf}
 *
 * @public
 */
export class Future {
    then(callback) {
        let step = this;
        while (true) {
            const next = step.step();
            if (step !== next) {
                step = next;
            }
            else {
                return next.then(callback);
            }
        }
    }
    get() {
        let step = this;
        while (true) {
            const next = step.step();
            if (step !== next) {
                step = next;
            }
            else {
                return next.get();
            }
        }
    }
    map(mapper) {
        return this.flatMap((value) => Now.of(mapper(value)));
    }
    apply(mapper) {
        return mapper.flatMap((mapper) => this.map(mapper));
    }
    flatten() {
        return this.flatMap((future) => future);
    }
    tee(callback) {
        return this.map((value) => {
            callback(value);
            return value;
        });
    }
    async *asyncIterator() {
        yield this.toPromise();
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    toPromise() {
        return new Promise((resolve) => this.then(resolve));
    }
}
/**
 * @public
 */
(function (Future) {
    function isFuture(value) {
        return value instanceof Future;
    }
    Future.isFuture = isFuture;
    function empty() {
        return now(undefined);
    }
    Future.empty = empty;
    function now(value) {
        return Now.of(value);
    }
    Future.now = now;
    function defer(continuation) {
        return Defer.of(continuation);
    }
    Future.defer = defer;
    function suspend(thunk) {
        return Suspend.of(thunk);
    }
    Future.suspend = suspend;
    function delay(thunk) {
        return suspend(() => now(thunk()));
    }
    Future.delay = delay;
    function from(promise) {
        return Future.defer((callback) => (typeof promise === "function" ? promise() : promise).then(callback));
    }
    Future.from = from;
    function traverse(values, mapper) {
        return Iterable.reduce(values, (values, value, i) => values.flatMap((values) => mapper(value, i).map((value) => Array.append(values, value))), now(Array.empty()));
    }
    Future.traverse = traverse;
    function sequence(futures) {
        return traverse(futures, (value) => value);
    }
    Future.sequence = sequence;
})(Future || (Future = {}));
class Now extends Future {
    static of(value) {
        return new Now(value);
    }
    _value;
    constructor(value) {
        super();
        this._value = value;
    }
    step() {
        return this;
    }
    then(callback) {
        callback(this._value);
    }
    get() {
        return this._value;
    }
    isNow() {
        return true;
    }
    isDeferred() {
        return false;
    }
    isSuspended() {
        return false;
    }
    map(mapper) {
        return new Now(mapper(this._value));
    }
    flatMap(mapper) {
        return Suspend.of(() => mapper(this._value));
    }
}
class Defer extends Future {
    static of(continuation) {
        return new Defer(continuation);
    }
    _continuation;
    constructor(continuation) {
        super();
        this._continuation = continuation;
    }
    step() {
        return this;
    }
    then(callback) {
        this._continuation((value) => defer(() => callback(value)));
    }
    get() {
        throw new Error("Attempted to .get() from deferred future");
    }
    isNow() {
        return false;
    }
    isDeferred() {
        return true;
    }
    isSuspended() {
        return false;
    }
    flatMap(mapper) {
        return Defer.Bind.of(this._continuation, mapper);
    }
}
(function (Defer) {
    class Bind extends Future {
        static of(continuation, mapper) {
            return new Bind(continuation, mapper);
        }
        _continuation;
        _mapper;
        constructor(continuation, mapper) {
            super();
            this._continuation = continuation;
            this._mapper = mapper;
        }
        step() {
            return this;
        }
        then(callback) {
            this._continuation((value) => defer(() => this._mapper(value).then(callback)));
        }
        get() {
            throw new Error("Attempted to .get() from deferred future");
        }
        isNow() {
            return false;
        }
        isDeferred() {
            return true;
        }
        isSuspended() {
            return false;
        }
        flatMap(mapper) {
            return Suspend.of(() => Bind.of(this._continuation, (value) => this._mapper(value).flatMap(mapper)));
        }
    }
    Defer.Bind = Bind;
})(Defer || (Defer = {}));
class Suspend extends Future {
    static of(thunk) {
        return new Suspend(thunk);
    }
    _thunk;
    constructor(thunk) {
        super();
        this._thunk = thunk;
    }
    step() {
        return this._thunk();
    }
    isNow() {
        return false;
    }
    isDeferred() {
        return false;
    }
    isSuspended() {
        return true;
    }
    flatMap(mapper) {
        return Suspend.Bind.of(this._thunk, mapper);
    }
}
(function (Suspend) {
    class Bind extends Future {
        static of(thunk, mapper) {
            return new Bind(thunk, mapper);
        }
        _thunk;
        _mapper;
        constructor(thunk, mapper) {
            super();
            this._thunk = thunk;
            this._mapper = mapper;
        }
        step() {
            return this._thunk().flatMap(this._mapper);
        }
        isNow() {
            return false;
        }
        isDeferred() {
            return false;
        }
        isSuspended() {
            return true;
        }
        flatMap(mapper) {
            return Suspend.of(() => Bind.of(this._thunk, (value) => this._mapper(value).flatMap(mapper)));
        }
    }
    Suspend.Bind = Bind;
})(Suspend || (Suspend = {}));
async function defer(thunk) {
    return Promise.resolve().then(thunk);
}
//# sourceMappingURL=future.js.map