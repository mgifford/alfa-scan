import { Array } from "@siteimprove/alfa-array";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Collection } from "@siteimprove/alfa-collection";
import { Comparable, type Comparer, type Comparison } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Lazy } from "@siteimprove/alfa-lazy";
import { Map } from "@siteimprove/alfa-map";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { Set } from "@siteimprove/alfa-set";
import { Sequence } from "./sequence.js";
/**
 * @public
 */
export declare class Cons<T> implements Sequence<T> {
    static of<T>(head: T, tail?: Lazy<Sequence<T>>): Cons<T>;
    private readonly _head;
    private readonly _tail;
    protected constructor(head: T, tail: Lazy<Sequence<T>>);
    get size(): number;
    isEmpty(): this is Sequence<never>;
    forEach(callback: Callback<T, void, [index: number]>): void;
    map<U>(mapper: Mapper<T, U, [index: number]>): Cons<U>;
    /**
     * @internal
     */
    map<U>(mapper: Mapper<T, U, [index: number]>, index: number): Cons<U>;
    apply<U>(mapper: Sequence<Mapper<T, U>>): Sequence<U>;
    flatMap<U>(mapper: Mapper<T, Sequence<U>, [index: number]>): Sequence<U>;
    /**
     * @internal
     */
    flatMap<U>(mapper: Mapper<T, Sequence<U>, [index: number]>, index: number): Sequence<U>;
    flatten<T>(this: Sequence<Sequence<T>>): Sequence<T>;
    reduce<U>(reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    reduceWhile<U>(predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    reduceUntil<U>(predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    filter<U extends T>(refinement: Refinement<T, U, [index: number]>): Sequence<U>;
    filter(predicate: Predicate<T, [index: number]>): Sequence<T>;
    /**
     * @internal
     */
    filter(predicate: Predicate<T, [index: number]>, index: number): Sequence<T>;
    reject<U extends T>(refinement: Refinement<T, U, [index: number]>): Sequence<Exclude<T, U>>;
    reject(predicate: Predicate<T, [index: number]>): Sequence<T>;
    find<U extends T>(refinement: Refinement<T, U, [index: number]>): Option<U>;
    find(predicate: Predicate<T, [index: number]>): Option<T>;
    includes(value: T): boolean;
    collect<U>(mapper: Mapper<T, Option<U>, [index: number]>): Sequence<U>;
    /**
     * @internal
     */
    collect<U>(mapper: Mapper<T, Option<U>, [index: number]>, index: number): Sequence<U>;
    collectFirst<U>(mapper: Mapper<T, Option<U>, [index: number]>): Option<U>;
    some(predicate: Predicate<T, [index: number]>): boolean;
    none(predicate: Predicate<T, [index: number]>): boolean;
    every(predicate: Predicate<T, [index: number]>): boolean;
    count(predicate: Predicate<T, [index: number]>): number;
    /**
     * Counts elements in the sequence until a predicate condition is met,
     * optionally filtering elements to count.
     *
     * @param predicate - The stopping condition. Iteration stops when this returns true.
     * @param filter - Optional predicate to filter which elements are counted. If not provided, all elements before the stopping condition are counted.
     */
    countUntil(predicate: Predicate<T, [index: number]>, filter?: Predicate<T, [index: number]>): number;
    distinct(): Sequence<T>;
    /**
     * @internal
     */
    distinct(seen: Set<T>): Sequence<T>;
    get(index: number): Option<T>;
    has(index: number): boolean;
    set(index: number, value: T): Cons<T>;
    insert(index: number, value: T): Cons<T>;
    append(value: T): Cons<T>;
    prepend(value: T): Cons<T>;
    concat(iterable: Iterable<T>): Cons<T>;
    subtract(iterable: Iterable<T>): Sequence<T>;
    intersect(iterable: Iterable<T>): Sequence<T>;
    tee<A extends Array<unknown> = []>(callback: Callback<this, void, [...args: A]>, ...args: A): this;
    zip<U>(iterable: Iterable<U>): Sequence<[T, U]>;
    first(): Option<T>;
    last(): Option<T>;
    take(count: number): Sequence<T>;
    takeWhile<U extends T>(refinement: Refinement<T, U, [index: number]>): Sequence<U>;
    takeWhile(predicate: Predicate<T, [index: number]>): Sequence<T>;
    takeUntil(predicate: Predicate<T, [index: number]>): Sequence<T>;
    /**
     * @internal
     */
    takeUntil(predicate: Predicate<T, [index: number]>, index: number): Sequence<T>;
    /**
     * Returns the elements that precede the first element for which the
     * predicate returns `true`.
     *
     * @remarks
     * The returned sequence is in reverse order relative to the input (nearest-first).
     */
    preceding(predicate: Predicate<T, [index: number]>): Sequence<T>;
    takeLast(count: number): Sequence<T>;
    takeLastWhile<U extends T>(refinement: Refinement<T, U, [index: number]>): Sequence<U>;
    takeLastWhile(predicate: Predicate<T, [index: number]>): Sequence<T>;
    takeLastUntil(predicate: Predicate<T, [index: number]>): Sequence<T>;
    skip(count: number): Sequence<T>;
    skipWhile(predicate: Predicate<T, [index: number]>): Sequence<T>;
    skipUntil(predicate: Predicate<T, [index: number]>): Sequence<T>;
    skipLast(count: number): Sequence<T>;
    skipLastWhile(predicate: Predicate<T, [index: number]>): Sequence<T>;
    skipLastUntil(predicate: Predicate<T, [index: number]>): Sequence<T>;
    trim(predicate: Predicate<T, [index: number]>): Sequence<T>;
    trimLeading(predicate: Predicate<T, [index: number]>): Sequence<T>;
    trimTrailing(predicate: Predicate<T, [index: number]>): Sequence<T>;
    rest(): Sequence<T>;
    slice(start: number, end?: number): Sequence<T>;
    reverse(): Sequence<T>;
    join(separator: string): string;
    sort<T extends Comparable<T>>(this: Sequence<T>): Sequence<T>;
    sortWith(comparer: Comparer<T>): Sequence<T>;
    sortWith<T, U extends T = T>(this: Sequence<U>, comparer: Comparer<T>): Sequence<U>;
    compare<T>(this: Sequence<Comparable<T>>, iterable: Iterable<T>): Comparison;
    compareWith<U = T>(iterable: Iterable<U>, comparer: Comparer<T, U, [index: number]>): Comparison;
    groupBy<K>(grouper: Mapper<T, K, [index: number]>): Map<K, Sequence<T>>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    iterator(): Iterator<T>;
    [Symbol.iterator](): Iterator<T>;
    toArray(): Array<T>;
    toJSON(options?: Serializable.Options): Cons.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Cons {
    type JSON<T> = Collection.Indexed.JSON<T>;
    function isCons<T>(value: Iterable<T>): value is Cons<T>;
    function isCons<T>(value: unknown): value is Cons<T>;
}
//# sourceMappingURL=cons.d.ts.map