import type { Callback } from "@siteimprove/alfa-callback";
import { Clone } from "@siteimprove/alfa-clone";
import { Comparable, type Comparer, Comparison } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @remarks
 * This is a re-export of the global `Array` interface to ensure that it merges
 * with the `Array` namespace.
 *
 * @public
 */
export type Array<T> = globalThis.Array<T>;
/**
 * @public
 */
export declare namespace Array {
    function isArray<T>(value: Iterable<T>): value is Array<T>;
    function isArray<T>(value: unknown): value is Array<T>;
    function of<T>(...values: Array<T>): Array<T>;
    function empty<T = never>(): Array<T>;
    function allocate<T>(capacity: number): Array<T>;
    /**
     * @remarks
     * Unlike the built-in function of the same name, this function will pass
     * along existing arrays as-is instead of returning a copy.
     */
    function from<T>(iterable: Iterable<T>): Array<T>;
    function size<T>(array: ReadonlyArray<T>): number;
    function isEmpty<T>(array: ReadonlyArray<T>): array is Array<never>;
    function copy<T>(array: ReadonlyArray<T>): Array<T>;
    function clone<T extends Clone<T>>(array: ReadonlyArray<T>): Array<T>;
    function forEach<T>(array: ReadonlyArray<T>, callback: Callback<T, void, [index: number]>): void;
    function map<T, U = T>(array: ReadonlyArray<T>, mapper: Mapper<T, U, [index: number]>): Array<U>;
    function flatMap<T, U = T>(array: ReadonlyArray<T>, mapper: Mapper<T, ReadonlyArray<U>, [index: number]>): Array<U>;
    function flatten<T>(array: ReadonlyArray<ReadonlyArray<T>>): Array<T>;
    function reduce<T, U = T>(array: ReadonlyArray<T>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function reduceWhile<T, U = T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function reduceUntil<T, U = T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function apply<T, U>(array: ReadonlyArray<T>, mapper: ReadonlyArray<Mapper<T, U>>): Array<U>;
    function filter<T, U extends T>(array: ReadonlyArray<T>, refinement: Refinement<T, U, [index: number]>): Array<U>;
    function filter<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): Array<T>;
    function reject<T, U extends T>(array: ReadonlyArray<T>, refinement: Refinement<T, U, [index: number]>): Array<Exclude<T, U>>;
    function reject<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): Array<T>;
    function find<T, U extends T>(array: ReadonlyArray<T>, refinement: Refinement<T, U, [index: number]>): Option<U>;
    function find<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): Option<T>;
    function findLast<T, U extends T>(array: ReadonlyArray<T>, refinement: Refinement<T, U, [index: number]>): Option<U>;
    function findLast<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): Option<T>;
    function includes<T>(array: ReadonlyArray<T>, value: T): boolean;
    function collect<T, U>(array: ReadonlyArray<T>, mapper: Mapper<T, Option<U>, [index: number]>): Array<U>;
    function collectFirst<T, U>(array: ReadonlyArray<T>, mapper: Mapper<T, Option<U>, [index: number]>): Option<U>;
    function some<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): boolean;
    function none<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): boolean;
    function every<T, U extends T>(array: ReadonlyArray<T>, refinement: Refinement<T, U, [index: number]>): array is Array<U>;
    function every<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): boolean;
    function count<T>(array: ReadonlyArray<T>, predicate: Predicate<T, [index: number]>): number;
    function distinct<T>(array: ReadonlyArray<T>): Array<T>;
    function get<T>(array: ReadonlyArray<T>, index: number): Option<T>;
    function has<T>(array: ReadonlyArray<T>, index: number): boolean;
    function set<T>(array: Array<T>, index: number, value: T): Array<T>;
    function insert<T>(array: Array<T>, index: number, value: T): Array<T>;
    function append<T>(array: Array<T>, value: T): [...Array<T>, T];
    function prepend<T>(array: Array<T>, value: T): [T, ...Array<T>];
    function concat<T>(array: ReadonlyArray<T>, ...iterables: Array<Iterable<T>>): Array<T>;
    function subtract<T>(array: ReadonlyArray<T>, ...iterables: Array<Iterable<T>>): Array<T>;
    function intersect<T>(array: ReadonlyArray<T>, ...iterables: Array<Iterable<T>>): Array<T>;
    function zip<T, U = T>(array: ReadonlyArray<T>, iterable: Iterable<U>): Array<[T, U]>;
    function first<T>(array: ReadonlyArray<T>): Option<T>;
    function last<T>(array: ReadonlyArray<T>): Option<T>;
    function sort<T extends Comparable<T>>(array: Array<T>): Array<T>;
    function sortWith<T>(array: Array<T>, comparer: Comparer<T>): Array<T>;
    function sortWith<T, U extends T = T>(array: Array<U>, comparer: Comparer<T>): Array<U>;
    function compare<T extends Comparable<U>, U = T>(a: ReadonlyArray<T>, b: Iterable<U>): Comparison;
    function compareWith<T, U = T>(a: ReadonlyArray<T>, b: Iterable<U>, comparer: Comparer<T, U, [index: number]>): Comparison;
    function search<T>(array: ReadonlyArray<T>, value: T, comparer: Comparer<T>): number;
    function equals<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): boolean;
    function hash<T>(array: ReadonlyArray<T>, hash: Hash): void;
    function iterator<T>(array: ReadonlyArray<T>): Iterator<T>;
    function toJSON<T>(array: ReadonlyArray<T>, options?: Serializable.Options): Array<Serializable.ToJSON<T>>;
}
//# sourceMappingURL=array.d.ts.map