import { Clone } from "@siteimprove/alfa-clone";
import { Comparable, Comparison, } from "@siteimprove/alfa-comparable";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import * as builtin from "./builtin.js";
const { not } = Predicate;
const { compareComparable } = Comparable;
/**
 * @public
 */
export var Array;
(function (Array) {
    function isArray(value) {
        return builtin.Array.isArray(value);
    }
    Array.isArray = isArray;
    function of(...values) {
        return values;
    }
    Array.of = of;
    function empty() {
        return [];
    }
    Array.empty = empty;
    function allocate(capacity) {
        return new builtin.Array(capacity);
    }
    Array.allocate = allocate;
    /**
     * @remarks
     * Unlike the built-in function of the same name, this function will pass
     * along existing arrays as-is instead of returning a copy.
     */
    function from(iterable) {
        if (isArray(iterable)) {
            return iterable;
        }
        return [...iterable];
    }
    Array.from = from;
    function size(array) {
        return array.length;
    }
    Array.size = size;
    function isEmpty(array) {
        return array.length === 0;
    }
    Array.isEmpty = isEmpty;
    function copy(array) {
        return array.slice(0);
    }
    Array.copy = copy;
    function clone(array) {
        return array.map(Clone.clone);
    }
    Array.clone = clone;
    function forEach(array, callback) {
        array.forEach(callback);
    }
    Array.forEach = forEach;
    function map(array, mapper) {
        return array.map(mapper);
    }
    Array.map = map;
    function flatMap(array, mapper) {
        return array.flatMap(mapper);
    }
    Array.flatMap = flatMap;
    function flatten(array) {
        return array.flat();
    }
    Array.flatten = flatten;
    function reduce(array, reducer, accumulator) {
        return array.reduce(reducer, accumulator);
    }
    Array.reduce = reduce;
    function reduceWhile(array, predicate, reducer, accumulator) {
        for (let i = 0, n = array.length; i < n; i++) {
            const value = array[i];
            if (predicate(value, i)) {
                accumulator = reducer(accumulator, value, i);
            }
            else {
                break;
            }
        }
        return accumulator;
    }
    Array.reduceWhile = reduceWhile;
    function reduceUntil(array, predicate, reducer, accumulator) {
        return reduceWhile(array, not(predicate), reducer, accumulator);
    }
    Array.reduceUntil = reduceUntil;
    function apply(array, mapper) {
        return flatMap(mapper, (mapper) => map(array, mapper));
    }
    Array.apply = apply;
    function filter(array, predicate) {
        return array.filter(predicate);
    }
    Array.filter = filter;
    function reject(array, predicate) {
        return filter(array, not(predicate));
    }
    Array.reject = reject;
    function find(array, predicate) {
        return Option.from(array.find(predicate));
    }
    Array.find = find;
    function findLast(array, predicate) {
        // Array#findLast is only available since August 2022 and in es2023.
        // We currently compile to es2022.
        for (let i = array.length - 1; i >= 0; i--) {
            const value = array[i];
            if (predicate(value, i)) {
                return Option.of(value);
            }
        }
        return None;
    }
    Array.findLast = findLast;
    function includes(array, value) {
        return array.some(Predicate.equals(value));
    }
    Array.includes = includes;
    function collect(array, mapper) {
        const result = empty();
        for (let i = 0, n = array.length; i < n; i++) {
            for (const value of mapper(array[i], i)) {
                result.push(value);
            }
        }
        return result;
    }
    Array.collect = collect;
    function collectFirst(array, mapper) {
        for (let i = 0, n = array.length; i < n; i++) {
            const value = mapper(array[i], i);
            if (value.isSome()) {
                return value;
            }
        }
        return None;
    }
    Array.collectFirst = collectFirst;
    function some(array, predicate) {
        return array.some(predicate);
    }
    Array.some = some;
    function none(array, predicate) {
        return array.every(not(predicate));
    }
    Array.none = none;
    function every(array, predicate) {
        return array.every(predicate);
    }
    Array.every = every;
    function count(array, predicate) {
        return reduce(array, (count, value, index) => (predicate(value, index) ? count + 1 : count), 0);
    }
    Array.count = count;
    function distinct(array) {
        const result = empty();
        for (let i = 0, n = array.length; i < n; i++) {
            const value = array[i];
            if (result.some(Predicate.equals(value))) {
                continue;
            }
            result.push(value);
        }
        return result;
    }
    Array.distinct = distinct;
    function get(array, index) {
        return 0 <= index && index < array.length ? Option.of(array[index]) : None;
    }
    Array.get = get;
    function has(array, index) {
        return 0 <= index && index < array.length;
    }
    Array.has = has;
    function set(array, index, value) {
        if (0 <= index && index < array.length) {
            array[index] = value;
        }
        return array;
    }
    Array.set = set;
    function insert(array, index, value) {
        if (0 <= index && index <= array.length) {
            array.splice(index, 0, value);
        }
        return array;
    }
    Array.insert = insert;
    function append(array, value) {
        array.push(value);
        return array;
    }
    Array.append = append;
    function prepend(array, value) {
        array.unshift(value);
        return array;
    }
    Array.prepend = prepend;
    function concat(array, ...iterables) {
        return [...Iterable.concat(array, ...iterables)];
    }
    Array.concat = concat;
    function subtract(array, ...iterables) {
        return [...Iterable.subtract(array, ...iterables)];
    }
    Array.subtract = subtract;
    function intersect(array, ...iterables) {
        return [...Iterable.intersect(array, ...iterables)];
    }
    Array.intersect = intersect;
    function zip(array, iterable) {
        const result = empty();
        const it = Iterable.iterator(iterable);
        for (let i = 0, n = array.length; i < n; i++) {
            const next = it.next();
            if (next.done === true) {
                break;
            }
            result.push([array[i], next.value]);
        }
        return result;
    }
    Array.zip = zip;
    function first(array) {
        return array.length > 0 ? Option.of(array[0]) : None;
    }
    Array.first = first;
    function last(array) {
        return array.length > 0 ? Option.of(array[array.length - 1]) : None;
    }
    Array.last = last;
    function sort(array) {
        return sortWith(array, compareComparable);
    }
    Array.sort = sort;
    function sortWith(array, comparer) {
        return array.sort(comparer);
    }
    Array.sortWith = sortWith;
    function compare(a, b) {
        return compareWith(a, b, compareComparable);
    }
    Array.compare = compare;
    function compareWith(a, b, comparer) {
        return Iterable.compareWith(a, b, comparer);
    }
    Array.compareWith = compareWith;
    function search(array, value, comparer) {
        let lower = 0;
        let upper = array.length - 1;
        while (lower <= upper) {
            const middle = (lower + (upper - lower) / 2) >>> 0;
            switch (comparer(value, array[middle])) {
                case Comparison.Greater:
                    lower = middle + 1;
                    break;
                case Comparison.Less:
                    upper = middle - 1;
                    break;
                case Comparison.Equal:
                    return middle;
            }
        }
        return lower;
    }
    Array.search = search;
    function equals(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, n = a.length; i < n; i++) {
            if (!Equatable.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    Array.equals = equals;
    function hash(array, hash) {
        for (let i = 0, n = array.length; i < n; i++) {
            hash.writeUnknown(array[i]);
        }
        hash.writeUint32(array.length);
    }
    Array.hash = hash;
    function iterator(array) {
        return array[Symbol.iterator]();
    }
    Array.iterator = iterator;
    function toJSON(array, options) {
        return array.map((value) => Serializable.toJSON(value, options));
    }
    Array.toJSON = toJSON;
})(Array || (Array = {}));
//# sourceMappingURL=array.js.map