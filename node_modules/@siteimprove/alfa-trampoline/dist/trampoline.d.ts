import type { Applicative } from "@siteimprove/alfa-applicative";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Foldable } from "@siteimprove/alfa-foldable";
import type { Functor } from "@siteimprove/alfa-functor";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Monad } from "@siteimprove/alfa-monad";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Thunk } from "@siteimprove/alfa-thunk";
/**
 * {@link http://blog.higher-order.com/assets/trampolines.pdf}
 *
 * @public
 */
export declare abstract class Trampoline<T> implements Functor<T>, Applicative<T>, Monad<T>, Foldable<T>, Iterable<T> {
    protected abstract step(): Trampoline<T>;
    run(): T;
    abstract isDone(): boolean;
    abstract isSuspended(): boolean;
    map<U>(mapper: Mapper<T, U>): Trampoline<U>;
    apply<U>(mapper: Trampoline<Mapper<T, U>>): Trampoline<U>;
    abstract flatMap<U>(mapper: Mapper<T, Trampoline<U>>): Trampoline<U>;
    flatten<T>(this: Trampoline<Trampoline<T>>): Trampoline<T>;
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    tee(callback: Callback<T>): Trampoline<T>;
    iterator(): Iterator<T>;
    [Symbol.iterator](): Iterator<T>;
}
/**
 * @public
 */
export declare namespace Trampoline {
    function isTrampoline<T>(value: Iterable<T>): value is Trampoline<T>;
    function isTrampoline<T>(value: unknown): value is Trampoline<T>;
    function empty(): Trampoline<void>;
    function done<T>(value: T): Trampoline<T>;
    function suspend<T>(thunk: Thunk<Trampoline<T>>): Trampoline<T>;
    function delay<T>(thunk: Thunk<T>): Trampoline<T>;
    function traverse<T, U>(values: Iterable<T>, mapper: Mapper<T, Trampoline<U>, [index: number]>): Trampoline<Iterable<U>>;
    function sequence<T>(futures: Iterable<Trampoline<T>>): Trampoline<Iterable<T>>;
}
//# sourceMappingURL=trampoline.d.ts.map