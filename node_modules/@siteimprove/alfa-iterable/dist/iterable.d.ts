import type { Callback } from "@siteimprove/alfa-callback";
import { Comparable, type Comparer, Comparison } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @remarks
 * This is a re-export of the global `Iterable` interface to ensure that it
 * merges with the `Iterable` namespace.
 *
 * @public
 */
export type Iterable<T> = globalThis.Iterable<T>;
/**
 * @public
 */
export declare namespace Iterable {
    function isIterable<T>(value: unknown): value is Iterable<T>;
    function empty<T>(): Iterable<T>;
    function from<T>(arrayLike: ArrayLike<T>): Iterable<T>;
    function size<T>(iterable: Iterable<T>): number;
    function isEmpty<T>(iterable: Iterable<T>): iterable is Iterable<never>;
    function forEach<T>(iterable: Iterable<T>, callback: Callback<T, void, [index: number]>): void;
    function map<T, U = T>(iterable: Iterable<T>, mapper: Mapper<T, U, [index: number]>): Iterable<U>;
    function flatMap<T, U = T>(iterable: Iterable<T>, mapper: Mapper<T, Iterable<U>, [index: number]>): Iterable<U>;
    function flatten<T>(iterable: Iterable<Iterable<T>>): Iterable<T>;
    function reduce<T, U = T>(iterable: Iterable<T>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function reduceWhile<T, U = T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function reduceUntil<T, U = T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    function apply<T, U>(iterable: Iterable<T>, mapper: Iterable<Mapper<T, U>>): Iterable<U>;
    function filter<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Iterable<U>;
    function filter<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function reject<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Iterable<Exclude<T, U>>;
    function reject<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function find<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Option<U>;
    function find<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Option<T>;
    function findLast<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Option<U>;
    function findLast<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Option<T>;
    function includes<T>(iterable: Iterable<T>, value: T): boolean;
    function collect<T, U>(iterable: Iterable<T>, mapper: Mapper<T, Option<U>, [index: number]>): Iterable<U>;
    function collectFirst<T, U>(iterable: Iterable<T>, mapper: Mapper<T, Option<U>, [index: number]>): Option<U>;
    function some<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): boolean;
    function none<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): boolean;
    function every<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): boolean;
    function count<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): number;
    function distinct<T>(iterable: Iterable<T>): Iterable<T>;
    function get<T>(iterable: Iterable<T>, index: number): Option<T>;
    function has<T>(iterable: Iterable<T>, index: number): boolean;
    function set<T>(iterable: Iterable<T>, index: number, value: T): Iterable<T>;
    function insert<T>(iterable: Iterable<T>, index: number, value: T): Iterable<T>;
    function append<T>(iterable: Iterable<T>, value: T): Iterable<T>;
    function prepend<T>(iterable: Iterable<T>, value: T): Iterable<T>;
    function concat<T>(iterable: Iterable<T>, ...iterables: Array<Iterable<T>>): Iterable<T>;
    function subtract<T>(iterable: Iterable<T>, ...iterables: Array<Iterable<T>>): Iterable<T>;
    function intersect<T>(iterable: Iterable<T>, ...iterables: Array<Iterable<T>>): Iterable<T>;
    function zip<T, U = T>(a: Iterable<T>, b: Iterable<U>): Iterable<[T, U]>;
    function first<T>(iterable: Iterable<T>): Option<T>;
    function last<T>(iterable: Iterable<T>): Option<T>;
    function take<T>(iterable: Iterable<T>, count: number): Iterable<T>;
    function takeWhile<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Iterable<U>;
    function takeWhile<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function takeUntil<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function takeLast<T>(iterable: Iterable<T>, count?: number): Iterable<T>;
    function takeLastWhile<T, U extends T>(iterable: Iterable<T>, refinement: Refinement<T, U, [index: number]>): Iterable<U>;
    function takeLastWhile<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function takeLastUntil<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function skip<T>(iterable: Iterable<T>, count: number): Iterable<T>;
    function skipWhile<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function skipUntil<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function skipLast<T>(iterable: Iterable<T>, count?: number): Iterable<T>;
    function skipLastWhile<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function skipLastUntil<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function trim<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function trimLeading<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function trimTrailing<T>(iterable: Iterable<T>, predicate: Predicate<T, [index: number]>): Iterable<T>;
    function rest<T>(iterable: Iterable<T>): Iterable<T>;
    function slice<T>(iterable: Iterable<T>, start: number, end?: number): Iterable<T>;
    function reverse<T>(iterable: Iterable<T>): Iterable<T>;
    function join<T>(iterable: Iterable<T>, separator: string): string;
    function sort<T extends Comparable<T>>(iterable: Iterable<T>): Iterable<T>;
    function sortWith<T>(iterable: Iterable<T>, comparer: Comparer<T>): Iterable<T>;
    function sortWith<T, U extends T = T>(iterable: Iterable<U>, comparer: Comparer<T>): Iterable<U>;
    function compare<T extends Comparable<U>, U = T>(a: Iterable<T>, b: Iterable<U>): Comparison;
    function compareWith<T, U = T>(a: Iterable<T>, b: Iterable<U>, comparer: Comparer<T, U, [index: number]>): Comparison;
    function equals<T>(a: Iterable<T>, b: Iterable<T>): boolean;
    function hash<T>(iterable: Iterable<T>, hash: Hash): void;
    function iterator<T>(iterable: Iterable<T>): Iterator<T>;
    function groupBy<T, K>(iterable: Iterable<T>, grouper: Mapper<T, K, [index: number]>): Iterable<[K, Iterable<T>]>;
    function toJSON<T>(iterable: Iterable<T>, options?: Serializable.Options): Array<Serializable.ToJSON<T>>;
}
//# sourceMappingURL=iterable.d.ts.map