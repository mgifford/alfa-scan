import type { Callback } from "@siteimprove/alfa-callback";
import type { Collection } from "@siteimprove/alfa-collection";
import { Equatable } from "@siteimprove/alfa-equatable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { List } from "@siteimprove/alfa-list";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @public
 */
export declare class Branched<T, B = never> implements Collection<T>, Iterable<[T, Iterable<B>]> {
    static of<T, B = never>(value: T, ...branches: Array<B>): Branched<T, B>;
    private readonly _values;
    protected constructor(values: List<Value<T, B>>);
    get size(): number;
    isEmpty(): this is Branched<never, B>;
    forEach(callback: Callback<T, void, [Iterable<B>]>): void;
    map<U>(mapper: Mapper<T, U, [Iterable<B>]>): Branched<U, B>;
    apply<U>(mapper: Branched<Mapper<T, U>, B>): Branched<U, B>;
    flatMap<U>(mapper: Mapper<T, Branched<U, B>, [Iterable<B>]>): Branched<U, B>;
    flatten<T, B>(this: Branched<Branched<T, B>, B>): Branched<T, B>;
    reduce<U>(reducer: Reducer<T, U, [Iterable<B>]>, accumulator: U): U;
    filter<U extends T>(refinement: Refinement<T, U, [Iterable<B>]>): Branched<U, B>;
    filter(predicate: Predicate<T, [Iterable<B>]>): Branched<T, B>;
    reject<U extends T>(refinement: Refinement<T, U, [Iterable<B>]>): Branched<Exclude<T, U>, B>;
    reject(predicate: Predicate<T, [Iterable<B>]>): Branched<T, B>;
    find<U extends T>(refinement: Refinement<T, U, [Iterable<B>]>): Option<U>;
    find(predicate: Predicate<T, [Iterable<B>]>): Option<T>;
    includes(value: T): boolean;
    collect<U>(mapper: Mapper<T, Option<U>, [Iterable<B>]>): Branched<U, B>;
    collectFirst<U>(mapper: Mapper<T, Option<U>, [Iterable<B>]>): Option<U>;
    some(predicate: Predicate<T, [Iterable<B>]>): boolean;
    none(predicate: Predicate<T, [Iterable<B>]>): boolean;
    every(predicate: Predicate<T, [Iterable<B>]>): boolean;
    count(predicate: Predicate<T, [Iterable<B>]>): number;
    /**
     * @remarks
     * As branched values merges branches with duplicate values, they will only
     * ever contain distinct values.
     */
    distinct(): Branched<T, B>;
    tee<A extends Array<unknown> = []>(callback: Callback<this, void, [...args: A]>, ...args: A): this;
    branch(value: T, ...branches: Array<B>): Branched<T, B>;
    equals<T, B>(value: Branched<T, B>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Iterator<[T, Iterable<B>]>;
    toArray(): Array<[T, Array<B>]>;
    toJSON(): Branched.JSON<T, B>;
}
/**
 * @public
 */
export declare namespace Branched {
    type JSON<T, B = never> = Array<[
        Serializable.ToJSON<T>,
        Array<Serializable.ToJSON<B>>
    ]>;
    function isBranched<T, B = never>(value: unknown): value is Branched<T, B>;
    function from<T, B = never>(values: Iterable<readonly [T, Iterable<B>]>): Branched<T, B>;
    function traverse<T, U, B>(values: Iterable<T>, mapper: Mapper<T, Branched<U, B>, [index: number]>): Branched<Iterable<U>, B>;
    function sequence<T, B>(values: Iterable<Branched<T, B>>): Branched<Iterable<T>, B>;
}
declare class Value<T, B> implements Equatable, Hashable {
    static of<T, B>(value: T, branches?: Option<List<B>>): Value<T, B>;
    private readonly _value;
    private readonly _branches;
    protected constructor(value: T, branches: Option<List<B>>);
    get value(): T;
    get branches(): Option<List<B>>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
}
export {};
//# sourceMappingURL=branched.d.ts.map