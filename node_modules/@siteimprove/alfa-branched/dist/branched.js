import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { List } from "@siteimprove/alfa-list";
import { None, Some } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
const { not } = Predicate;
/**
 * @public
 */
export class Branched {
    static of(value, ...branches) {
        return new Branched(List.of(Value.of(value, branches.length === 0 ? None : Some.of(List.from(branches)))));
    }
    _values;
    constructor(values) {
        this._values = values;
    }
    get size() {
        return this._values.size;
    }
    isEmpty() {
        return false;
    }
    forEach(callback) {
        this._values.forEach(({ value, branches }) => callback(value, branches.getOrElse(() => List.empty())));
    }
    map(mapper) {
        return new Branched(this._values.reduce((values, { value, branches }) => merge(values, mapper(value, branches.getOrElse(() => List.empty())), branches), List.empty()));
    }
    apply(mapper) {
        return mapper.flatMap((mapper) => this.map(mapper));
    }
    flatMap(mapper) {
        return new Branched(this._values.reduce((values, { value, branches: scope }) => mapper(value, scope.getOrElse(() => List.empty()))._values.reduce((values, { value, branches }) => {
            if (scope.isNone() && branches.isSome()) {
                branches = unused(branches, this._values);
            }
            else {
                branches = narrow(branches, scope);
            }
            return merge(values, value, branches);
        }, values), List.empty()));
    }
    flatten() {
        return this.flatMap((branched) => branched);
    }
    reduce(reducer, accumulator) {
        return this._values.reduce((accumulator, value) => reducer(accumulator, value.value, value.branches.getOrElse(() => List.empty())), accumulator);
    }
    filter(predicate) {
        return new Branched(this._values.filter(({ value, branches }) => predicate(value, branches.getOrElse(() => List.empty()))));
    }
    reject(predicate) {
        return this.filter(not(predicate));
    }
    find(predicate) {
        return this._values
            .find(({ value, branches }) => predicate(value, branches.getOrElse(() => List.empty())))
            .map(({ value }) => value);
    }
    includes(value) {
        return this._values.some(({ value: found }) => Equatable.equals(value, found));
    }
    collect(mapper) {
        return new Branched(this._values.reduce((values, { value, branches }) => mapper(value, branches.getOrElse(() => List.empty()))
            .map((value) => merge(values, value, branches))
            .getOr(values), List.empty()));
    }
    collectFirst(mapper) {
        return this._values.collectFirst(({ value, branches }) => mapper(value, branches.getOrElse(() => List.empty())));
    }
    some(predicate) {
        for (const value of this._values) {
            if (predicate(value.value, value.branches.getOrElse(() => List.empty()))) {
                return true;
            }
        }
        return false;
    }
    none(predicate) {
        return this.every(not(predicate));
    }
    every(predicate) {
        for (const value of this._values) {
            if (!predicate(value.value, value.branches.getOrElse(() => List.empty()))) {
                return false;
            }
        }
        return true;
    }
    count(predicate) {
        return this.reduce((count, value, branches) => predicate(value, branches) ? count + 1 : count, 0);
    }
    /**
     * @remarks
     * As branched values merges branches with duplicate values, they will only
     * ever contain distinct values.
     */
    distinct() {
        return this;
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    branch(value, ...branches) {
        return new Branched(merge(this._values, value, branches.length === 0 ? None : Some.of(List.from(branches))));
    }
    equals(value) {
        return value instanceof Branched && value._values.equals(this._values);
    }
    hash(hash) {
        hash.writeHashable(this._values);
    }
    *[Symbol.iterator]() {
        for (const value of this._values) {
            yield [value.value, value.branches.getOrElse(() => List.empty())];
        }
    }
    toArray() {
        return this._values
            .toArray()
            .map(({ value, branches }) => [
            value,
            branches.getOrElse(() => List.empty()).toArray(),
        ]);
    }
    toJSON() {
        return this._values
            .toArray()
            .map(({ value, branches }) => [
            Serializable.toJSON(value),
            branches.getOrElse(() => List.empty()).toJSON(),
        ]);
    }
}
/**
 * @public
 */
(function (Branched) {
    function isBranched(value) {
        return value instanceof Branched;
    }
    Branched.isBranched = isBranched;
    function from(values) {
        if (isBranched(values)) {
            return values;
        }
        const [[value, branches], ...rest] = values;
        return rest.reduce((result, [value, branches]) => result.branch(value, ...branches), Branched.of(value, ...branches));
    }
    Branched.from = from;
    function traverse(values, mapper) {
        return Iterable.reduce(values, (values, value, i) => values.flatMap((values) => mapper(value, i).map((value) => values.append(value))), Branched.of(List.empty()));
    }
    Branched.traverse = traverse;
    function sequence(values) {
        return traverse(values, (value) => value);
    }
    Branched.sequence = sequence;
})(Branched || (Branched = {}));
class Value {
    static of(value, branches = None) {
        return new Value(value, branches);
    }
    _value;
    _branches;
    constructor(value, branches) {
        this._value = value;
        this._branches = branches;
    }
    get value() {
        return this._value;
    }
    get branches() {
        return this._branches;
    }
    equals(value) {
        return (value instanceof Value &&
            Equatable.equals(value._value, this._value) &&
            Equatable.equals(value._branches, this._branches));
    }
    hash(hash) {
        hash.writeUnknown(this._value).writeHashable(this._branches);
    }
}
function merge(values, value, branches) {
    if (values.size === 0) {
        return List.of(Value.of(value, branches));
    }
    branches = values
        .find((existing) => Equatable.equals(existing.value, value))
        .map((existing) => existing.branches.flatMap((left) => branches.map((right) => left.concat(right))))
        .getOr(branches);
    return deduplicate(values, value, branches).append(Value.of(value, branches));
}
function deduplicate(values, value, branches) {
    return values.reduce((values, existing) => {
        if (Equatable.equals(existing.value, value)) {
            return values;
        }
        if (existing.branches.isNone()) {
            return branches.isNone() ? values : values.append(existing);
        }
        return existing.branches.reduce((values, existingBranches) => {
            const deduplicated = branches.reduce((existing, branches) => existing.subtract(branches), existingBranches);
            if (deduplicated.size === 0) {
                return values;
            }
            return values.append(Value.of(existing.value, Some.of(deduplicated)));
        }, values);
    }, List.empty());
}
function narrow(branches, scope) {
    return scope.map((scope) => branches.reduce((scope, branches) => scope.intersect(branches), scope));
}
function unused(branches, values) {
    return values.reduce((branches, value) => value.branches
        .flatMap((existing) => branches.map((branches) => branches.subtract(existing)))
        .or(branches), branches);
}
//# sourceMappingURL=branched.js.map