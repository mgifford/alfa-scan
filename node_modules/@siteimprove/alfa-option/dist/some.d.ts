import type { Callback } from "@siteimprove/alfa-callback";
import { Comparable, type Comparer, Comparison } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type * as json from "@siteimprove/alfa-json";
import type { Option } from "./option.js";
import { None } from "./none.js";
/**
 * @public
 */
export declare class Some<T> implements Option<T> {
    static of<T>(value: T): Some<T>;
    private readonly _value;
    protected constructor(value: T);
    isSome(): this is Some<T>;
    isNone(): this is None;
    map<U>(mapper: Mapper<T, U>): Some<U>;
    getter<K extends keyof T>(key: K): Some<T[K]>;
    forEach(mapper: Mapper<T, void>): void;
    apply<U>(mapper: Option<Mapper<T, U>>): Option<U>;
    flatMap<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    flatten<T>(this: Some<Option<T>>): Option<T>;
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    filter<U extends T>(refinement: Refinement<T, U>): Option<U>;
    filter(predicate: Predicate<T>): Option<T>;
    reject<U extends T>(refinement: Refinement<T, U>): Option<Exclude<T, U>>;
    reject(predicate: Predicate<T>): Option<T>;
    includes(value: T): boolean;
    some<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    some(predicate: Predicate<T>): boolean;
    none<U extends T>(refinement: Refinement<T, U>): this is Some<Exclude<T, U>>;
    none(predicate: Predicate<T>): boolean;
    every<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    every(predicate: Predicate<T>): boolean;
    and<U>(option: Option<U>): Option<U>;
    andThen<U>(option: Mapper<T, Option<U>>): Option<U>;
    or(): Some<T>;
    orElse(): Some<T>;
    get(): T;
    /**
     * @internal
     */
    getUnsafe(): T;
    getOr(): T;
    getOrElse(): T;
    tee(callback: Callback<T>): this;
    compare<T>(this: Option<Comparable<T>>, option: Option<T>): Comparison;
    compareWith<U = T>(option: Option<U>, comparer: Comparer<T, U>): Comparison;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Iterator<T>;
    toArray(): [T];
    toJSON(options?: Serializable.Options): Some.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Some {
    interface JSON<T> {
        [key: string]: json.JSON;
        type: "some";
        value: Serializable.ToJSON<T>;
    }
    function isSome<T>(value: Iterable<T>): value is Some<T>;
    function isSome<T>(value: unknown): value is Some<T>;
}
//# sourceMappingURL=some.d.ts.map