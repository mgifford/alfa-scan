import { Iterable } from "@siteimprove/alfa-iterable";
import { None } from "@siteimprove/alfa-option";
import { String } from "@siteimprove/alfa-string";
import { Node } from "../node.js";
import { Set } from "@siteimprove/alfa-set";
import { Role } from "../role.js";
import { Element as DomElement } from "@siteimprove/alfa-dom";
import { Selective } from "@siteimprove/alfa-selective";
/**
 * @public
 */
export class Element extends Node {
    static of(owner, role = None, name = None, attributes = [], children = []) {
        return new Element(owner, role, name, Array.from(attributes), Array.from(children));
    }
    _role;
    _name;
    _attributes;
    constructor(owner, role, name, attributes, children) {
        super(owner, children, "element");
        this._role = role;
        this._name = name;
        this._attributes = attributes;
    }
    get role() {
        return this._role;
    }
    get name() {
        return this._name;
    }
    get attributes() {
        return this._attributes;
    }
    attribute(predicate) {
        return Iterable.find(this._attributes, typeof predicate === "string"
            ? (attribute) => attribute.name === predicate
            : predicate);
    }
    clone() {
        return new Element(this._node, this._role, this._name, this._attributes, this._children.map((child) => child.clone()));
    }
    isIgnored() {
        return false;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            role: this._role.map((role) => role.name).getOr(null),
            name: this._name.map((name) => name.value).getOr(null),
            attributes: this._attributes.map((attribute) => attribute.toJSON()),
        };
    }
    toString() {
        return [
            [
                this._role.map((role) => role.name).getOr("element"),
                ...this._name.map((name) => `"${name}"`),
            ].join(" "),
            ...this._children.map((child) => String.indent(child.toString())),
        ].join("\n");
    }
    static allowedAttributesForInputType(inputType) {
        switch (inputType) {
            // https://www.w3.org/TR/html-aria/#el-input-color
            case "color":
                return ["aria-disabled"];
            // https://www.w3.org/TR/html-aria/#el-input-date
            case "date":
            // https://www.w3.org/TR/html-aria/#el-input-datetime-local
            case "datetime-local":
            // https://www.w3.org/TR/html-aria/#el-input-email
            case "email":
            // https://www.w3.org/TR/html-aria/#el-input-month
            case "month":
            // https://www.w3.org/TR/html-aria/#el-input-password
            case "password":
            // https://www.w3.org/TR/html-aria/#el-input-time
            case "time":
            // https://www.w3.org/TR/html-aria/#el-input-week
            case "week":
                return Role.of("textbox").supportedAttributes;
            // https://www.w3.org/TR/html-aria/#el-input-file
            case "file":
                return ["aria-disabled", "aria-invalid", "aria-required"];
            default:
                return [];
        }
    }
    /**
     * The attributes that are allowed on this element, taking into consideration ARIA in HTML conformance requirements.
     * See {@link https://w3c.github.io/html-aria/#docconformance}
     */
    allowedAttributes() {
        const global = Role.of("roletype").supportedAttributes;
        const fromRole = this.role.map(role => role.supportedAttributes).getOr([]);
        const additional = Selective.of(this.node)
            .if(DomElement.hasName("input"), input => Element.allowedAttributesForInputType(input.inputType()))
            // https://www.w3.org/TR/html-aria/#el-select
            .if(DomElement.hasName("select"), select => DomElement.hasDisplaySize((size) => size !== 1)(select)
            ? Role.of("combobox").supportedAttributes
            : Role.of("menu").supportedAttributes)
            .else(() => [])
            .get();
        return Array.from(Set.from([...global, ...fromRole, ...additional]));
    }
    isAttributeAllowed(attribute) {
        return this.allowedAttributes().includes(attribute);
    }
}
//# sourceMappingURL=element.js.map