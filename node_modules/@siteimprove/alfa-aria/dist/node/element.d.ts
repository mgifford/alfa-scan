import { Iterable } from "@siteimprove/alfa-iterable";
import type { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type * as dom from "@siteimprove/alfa-dom";
import type { Attribute } from "../attribute.js";
import type { Name } from "../name/index.js";
import { Node } from "../node.js";
import { Role } from "../role.js";
/**
 * @public
 */
export declare class Element extends Node<"element"> {
    static of(owner: dom.Node, role?: Option<Role>, name?: Option<Name>, attributes?: Iterable<Attribute>, children?: Iterable<Node>): Element;
    private readonly _role;
    private readonly _name;
    private readonly _attributes;
    protected constructor(owner: dom.Node, role: Option<Role>, name: Option<Name>, attributes: Array<Attribute>, children: Array<Node>);
    get role(): Option<Role>;
    get name(): Option<Name>;
    get attributes(): ReadonlyArray<Attribute>;
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option<Attribute<N>>;
    attribute(predicate: Predicate<Attribute>): Option<Attribute>;
    attribute<N extends Attribute.Name>(predicate: N): Option<Attribute<N>>;
    clone(): Element;
    isIgnored(): boolean;
    toJSON(): Element.JSON;
    toString(): string;
    private static allowedAttributesForInputType;
    /**
     * The attributes that are allowed on this element, taking into consideration ARIA in HTML conformance requirements.
     * See {@link https://w3c.github.io/html-aria/#docconformance}
     */
    allowedAttributes(): ReadonlyArray<Attribute.Name>;
    isAttributeAllowed(attribute: Attribute.Name): boolean;
}
/**
 * @public
 */
export declare namespace Element {
    interface JSON extends Node.JSON<"element"> {
        role: Role.Name | null;
        name: string | null;
        attributes: Array<Attribute.JSON>;
    }
}
//# sourceMappingURL=element.d.ts.map