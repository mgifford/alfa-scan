import { Array } from "@siteimprove/alfa-array";
import { Element } from "@siteimprove/alfa-dom";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Hashable, Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type * as json from "@siteimprove/alfa-json";
import type { Attribute } from "./attribute.js";
import { Roles } from "./role/data.js";
import * as predicate from "./role/predicate.js";
/**
 * @public
 */
export declare class Role<N extends Role.Name = Role.Name> implements Equatable, Hashable, Serializable {
    static of<N extends Role.Name>(name: N): Role<N>;
    private readonly _name;
    private readonly _supportedAttributes;
    private readonly _requiredAttributes;
    private readonly _prohibitedAttributes;
    protected constructor(name: N, supportedAttributes: Array<Attribute.Name>, requiredAttributes: Array<Attribute.Name>, prohibitedAttributes: Array<Attribute.Name>);
    get name(): N;
    /**
     * Get all attributes supported by this role and its inherited (ancestors) roles.
     */
    get supportedAttributes(): ReadonlyArray<Attribute.Name>;
    /**
     * Get all attributes required by this role and its inherited (ancestors) roles.
     */
    get requiredAttributes(): ReadonlyArray<Attribute.Name>;
    /**
     * Get all attributes prohibited on this role and its inherited (ancestors) roles.
     */
    get prohibitedAttributes(): ReadonlyArray<Attribute.Name>;
    /**
     * Get the required parent of this role.
     */
    get requiredParent(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    /**
     * Get the required children of this role.
     */
    get requiredChildren(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    /**
     * Check if this role has the specified name.
     */
    hasName<N extends Role.Name>(name: N): this is Role<N>;
    /**
     * Check if this role is a superclass of the role with the specified name.
     */
    isSuperclassOf<N extends Role.Name>(name: N): this is Role<Role.SuperclassOf<N>>;
    /**
     * Check if this role is a subclass of the role with the specified name.
     */
    isSubclassOf<N extends Role.Name>(name: N): this is Role<Role.SubclassOf<N>>;
    /**
     * Check if this role either is, or is a subclass of, the role with the
     * specified name.
     */
    is<N extends Role.Name>(name: N): this is Role<N | Role.SubclassOf<N>>;
    /**
     * Check if this role is abstract.
     */
    isAbstract(): this is Role<Role.Abstract>;
    /**
     * Check if this role is non-abstract.
     */
    isConcrete(): this is Role<Role.Concrete>;
    /**
     * Check if this role is presentational.
     */
    isPresentational(): this is Role<Role.Presentational>;
    /**
     * Check if this role is a widget.
     */
    isWidget(): this is Role<Role.Widget>;
    /**
     * Check if this role is a landmark.
     */
    isLandmark(): this is Role<Role.Landmark>;
    /**
     * Check if this role supports naming by the specified method.
     */
    isNamedBy(method: Role.NamedBy): boolean;
    /**
     * Check if this role prohibits naming.
     */
    isNameProhibited(): boolean;
    /**
     * Check if this role has a required parent.
     */
    hasRequiredParent(): boolean;
    /**
     * Check if this role has presentational children.
     */
    hasPresentationalChildren(): boolean;
    /**
     * Check if this role has required children.
     */
    hasRequiredChildren(): boolean;
    /**
     * Check if this role supports the specified attribute.
     */
    isAttributeSupported(name: Attribute.Name): boolean;
    /**
     * Check if this role requires the specified attribute.
     */
    isAttributeRequired(name: Attribute.Name): boolean;
    /**
     * Check if this role prohibits the specified attribute.
     */
    isAttributeProhibited(name: Attribute.Name): boolean;
    /**
     * Get the implicit value of the specified attribute, if any.
     */
    implicitAttributeValue(name: Attribute.Name): Option<string>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(): Role.JSON;
}
/**
 * @public
 */
export declare namespace Role {
    interface JSON {
        [key: string]: json.JSON;
        name: Name;
    }
    type Name = keyof Roles;
    function isName(value: string): value is Name;
    /**
     * The names of all abstract roles.
     */
    type Abstract = {
        [N in Name]: Roles[N]["abstract"] extends true ? N : never;
    }[Name];
    /**
     * The names of all non-abstract roles.
     */
    type Concrete = Exclude<Name, Abstract>;
    /**
     * The names of all presentational roles.
     *
     * @remarks
     * In WAI-ARIA, the role `none` is defined to be synonymous with the role
     * `presentation`. We therefore refer collectively to the two roles as the
     * presentational roles.
     */
    type Presentational = "presentation" | "none";
    /**
     * The names of all widget roles.
     */
    type Widget = SubclassOf<"widget">;
    /**
     * The names of all landmark roles.
     */
    type Landmark = SubclassOf<"landmark">;
    /**
     * The inherited roles for the specified role.
     */
    type Inherited<N extends Name> = N extends "roletype" | "none" ? never : Members<Roles[N]["inherited"]>;
    /**
     * All roles that are subclasses of the specified role.
     */
    type SubclassOf<N extends Name> = {
        [M in Name]: N extends SuperclassOf<M> ? M : never;
    }[Name];
    /**
     * All roles that are superclasses of the specified role.
     *
     * @remarks
     * The super roles `roletype` and `none` act as base conditions of the
     * recursive type construction in order to avoid the TypeScript compiler
     * infinitely recursing while instantiating the type.
     */
    type SuperclassOf<N extends Name> = N extends "roletype" | "none" ? never : Inherited<N> | {
        [M in Inherited<N>]: SuperclassOf<M>;
    }[Inherited<N>];
    /**
     * The methods by which the element assigned to the specified role may receive
     * its name.
     */
    type NamedBy<N extends Name = Name> = Members<Roles[N]["name"]["from"]>;
    function isRole<N extends Name>(value: unknown, name?: N): value is Role<Name>;
    /**
     * Get the role assigned either explicitly or implicitly to an element, if
     * any.
     */
    function from(element: Element): Option<Role>;
    /**
     * Get the role explicitly assigned to an element, if any.
     */
    function fromExplicit(element: Element): Option<Role>;
    /**
     * Get the role implicitly assigned to an element, if any.
     */
    function fromImplicit(element: Element): Option<Role>;
    const hasName: typeof predicate.hasName;
}
type Members<T> = T extends Iterable<infer T> ? T : never;
export {};
//# sourceMappingURL=role.d.ts.map