import { Array } from "@siteimprove/alfa-array";
import { Element } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Map } from "@siteimprove/alfa-map";
import { Option, None } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Set } from "@siteimprove/alfa-set";
import { Feature } from "./feature.js";
import { Roles } from "./role/data.js";
import * as predicate from "./role/predicate.js";
const { and, not, nor } = Predicate;
let roles = Map.empty();
/**
 * @public
 */
export class Role {
    static of(name) {
        return roles.get(name).getOrElse(() => {
            // The "as const" building of Roles makes TS give it a very
            // rigid type, and we need to manually help it to correctly merge the
            // Attribute.Name keys into a single union type. As of TS 4.8.2, removing
            // the type guard, or trying to destructure Roles[name] in one go, breaks.
            const attributes = Roles[name].attributes;
            const inherited = Roles[name].inherited;
            const supportedAttributes = Set.from(attributes.map(([attribute]) => attribute)).concat(inherited.flatMap((parent) => Role.of(parent).supportedAttributes));
            const requiredAttributes = Set.from(Array.collect(attributes, ([attribute, { required }]) => required ? Option.of(attribute) : None)).concat(inherited.flatMap((parent) => Role.of(parent).requiredAttributes));
            const prohibitedAttributes = Set.from(Array.collect(attributes, ([attribute, { prohibited }]) => prohibited ? Option.of(attribute) : None)).concat(inherited.flatMap((parent) => Role.of(parent).prohibitedAttributes));
            const role = new Role(name, [...supportedAttributes], [...requiredAttributes], [...prohibitedAttributes]);
            roles = roles.set(name, role);
            return role;
        });
    }
    _name;
    _supportedAttributes;
    _requiredAttributes;
    _prohibitedAttributes;
    constructor(name, supportedAttributes, requiredAttributes, prohibitedAttributes) {
        this._name = name;
        this._supportedAttributes = supportedAttributes;
        this._requiredAttributes = requiredAttributes;
        this._prohibitedAttributes = prohibitedAttributes;
    }
    get name() {
        return this._name;
    }
    /**
     * Get all attributes supported by this role and its inherited (ancestors) roles.
     */
    get supportedAttributes() {
        return this._supportedAttributes;
    }
    /**
     * Get all attributes required by this role and its inherited (ancestors) roles.
     */
    get requiredAttributes() {
        return this._requiredAttributes;
    }
    /**
     * Get all attributes prohibited on this role and its inherited (ancestors) roles.
     */
    get prohibitedAttributes() {
        return this._prohibitedAttributes;
    }
    /**
     * Get the required parent of this role.
     */
    get requiredParent() {
        return Roles[this._name].parent.required;
    }
    /**
     * Get the required children of this role.
     */
    get requiredChildren() {
        return Roles[this._name].children.required;
    }
    /**
     * Check if this role has the specified name.
     */
    hasName(name) {
        return this._name === name;
    }
    /**
     * Check if this role is a superclass of the role with the specified name.
     */
    isSuperclassOf(name) {
        const { inherited } = Roles[name];
        for (const parent of inherited) {
            if (parent === this._name || this.isSuperclassOf(parent)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Check if this role is a subclass of the role with the specified name.
     */
    isSubclassOf(name) {
        return Role.of(name).isSuperclassOf(this._name);
    }
    /**
     * Check if this role either is, or is a subclass of, the role with the
     * specified name.
     */
    is(name) {
        return this.hasName(name) || this.isSubclassOf(name);
    }
    /**
     * Check if this role is abstract.
     */
    isAbstract() {
        return Roles[this._name].abstract;
    }
    /**
     * Check if this role is non-abstract.
     */
    isConcrete() {
        return !this.isAbstract();
    }
    /**
     * Check if this role is presentational.
     */
    isPresentational() {
        return this.hasName("presentation") || this.hasName("none");
    }
    /**
     * Check if this role is a widget.
     */
    isWidget() {
        return this.is("widget");
    }
    /**
     * Check if this role is a landmark.
     */
    isLandmark() {
        return this.is("landmark");
    }
    /**
     * Check if this role supports naming by the specified method.
     */
    isNamedBy(method) {
        for (const found of Roles[this._name].name.from) {
            if (found === method) {
                return true;
            }
        }
        return false;
    }
    /**
     * Check if this role prohibits naming.
     */
    isNameProhibited() {
        return Roles[this._name].name.prohibited;
    }
    /**
     * Check if this role has a required parent.
     */
    hasRequiredParent() {
        return Roles[this._name].parent.required.length > 0;
    }
    /**
     * Check if this role has presentational children.
     */
    hasPresentationalChildren() {
        return Roles[this._name].children.presentational;
    }
    /**
     * Check if this role has required children.
     */
    hasRequiredChildren() {
        return Roles[this._name].children.required.length > 0;
    }
    /**
     * Check if this role supports the specified attribute.
     */
    isAttributeSupported(name) {
        return this._supportedAttributes.includes(name);
    }
    /**
     * Check if this role requires the specified attribute.
     */
    isAttributeRequired(name) {
        return this._requiredAttributes.includes(name);
    }
    /**
     * Check if this role prohibits the specified attribute.
     */
    isAttributeProhibited(name) {
        return this._prohibitedAttributes.includes(name);
    }
    /**
     * Get the implicit value of the specified attribute, if any.
     */
    implicitAttributeValue(name) {
        const { inherited, attributes } = Roles[this._name];
        for (const [found, { value }] of attributes) {
            if (name === found && value !== null) {
                return Option.from(value);
            }
        }
        for (const parent of inherited) {
            for (const value of Role.of(parent).implicitAttributeValue(name)) {
                return Option.of(value);
            }
        }
        return None;
    }
    equals(value) {
        return value instanceof Role && value._name === this._name;
    }
    hash(hash) {
        hash.writeString(this._name);
    }
    toJSON() {
        return {
            name: this._name,
        };
    }
}
/**
 * @public
 */
(function (Role) {
    function isName(value) {
        return value in Roles;
    }
    Role.isName = isName;
    function isRole(value, name) {
        return value instanceof Role && (name === undefined || value.name === name);
    }
    Role.isRole = isRole;
    /**
     * Get the role assigned either explicitly or implicitly to an element, if
     * any.
     */
    function from(element) {
        return fromExplicit(element).orElse(() => fromImplicit(element));
    }
    Role.from = from;
    /**
     * Get the role explicitly assigned to an element, if any.
     */
    function fromExplicit(element) {
        const roles = element
            .attribute("role")
            .map((attribute) => attribute.tokens())
            .getOrElse(() => Sequence.empty());
        return (roles
            .map((role) => role.toLowerCase())
            .filter(isName)
            .map(Role.of)
            // Abstract roles are only used for ontological purposes and are not
            // allowed to be used by authors; we therefore filter them out.
            .reject((role) => role.isAbstract())
            // If the element is not allowed to be presentational, reject all
            // presentational roles.
            .reject((role) => isAllowedPresentational(element) ? false : role.isPresentational())
            .first());
    }
    Role.fromExplicit = fromExplicit;
    /**
     * Get the role implicitly assigned to an element, if any.
     */
    function fromImplicit(element) {
        return element.namespace.flatMap((namespace) => Feature.from(namespace, element.name).flatMap((feature) => Sequence.from(feature.role(element))
            // If the element is not allowed to be presentational, reject all
            // presentational roles.
            .reject((role) => isAllowedPresentational(element) ? false : role.isPresentational())
            .first()));
    }
    Role.fromImplicit = fromImplicit;
    Role.hasName = predicate.hasName;
})(Role || (Role = {}));
/**
 * Check if an element has one or more global `aria-*` attributes.
 */
const hasGlobalAttributes = (element) => Iterable.some(Role.of("roletype").supportedAttributes, (attribute) => element.attribute(attribute).isSome());
/**
 * Check if an element is potentially focusable, not accounting for whether or
 * not the element is rendered.
 */
const isPotentiallyFocusable = and(Element.hasTabIndex(), not(Element.isActuallyDisabled));
/**
 * Check if an element is allowed to be assigned a presentational role.
 */
const isAllowedPresentational = nor(hasGlobalAttributes, isPotentiallyFocusable);
//# sourceMappingURL=role.js.map