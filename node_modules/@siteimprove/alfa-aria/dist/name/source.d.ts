import { type Attribute, type Element, Node, type Text } from "@siteimprove/alfa-dom";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import type * as json from "@siteimprove/alfa-json";
import type { Name } from "./name.js";
/**
 * @public
 */
export type Source = Source.Data | Source.Descendant | Source.Ancestor | Source.Label | Source.Reference;
/**
 * @public
 */
export declare namespace Source {
    type JSON = Data.JSON | Descendant.JSON | Ancestor.JSON | Label.JSON | Reference.JSON;
    class Data implements Equatable, Serializable<Data.JSON> {
        static of(text: Text): Data;
        private readonly _text;
        protected constructor(text: Text);
        get type(): "data";
        get text(): Text;
        equals(value: unknown): value is this;
        [Symbol.iterator](): Iterator<Node>;
        toJSON(): Data.JSON;
    }
    namespace Data {
        interface JSON {
            [key: string]: json.JSON;
            type: "data";
            text: string;
        }
    }
    function data(text: Text): Data;
    class Descendant implements Equatable, Serializable<Descendant.JSON> {
        static of(element: Element, name: Name): Descendant;
        private readonly _element;
        private readonly _name;
        protected constructor(element: Element, name: Name);
        get type(): "descendants";
        get element(): Element;
        get name(): Name;
        equals(value: unknown): value is this;
        [Symbol.iterator](): Iterator<Node>;
        toJSON(): Descendant.JSON;
    }
    namespace Descendant {
        interface JSON {
            [key: string]: json.JSON;
            type: "descendant";
            element: string;
            name: Name.JSON;
        }
    }
    function descendant(element: Element, name: Name): Descendant;
    class Ancestor implements Equatable, Serializable<Ancestor.JSON> {
        static of(element: Element, name: Name): Ancestor;
        private readonly _element;
        private readonly _name;
        protected constructor(element: Element, name: Name);
        get type(): "ancestor";
        get element(): Element;
        get name(): Name;
        equals(value: unknown): value is this;
        [Symbol.iterator](): Iterator<Node>;
        toJSON(): Ancestor.JSON;
    }
    namespace Ancestor {
        interface JSON {
            [key: string]: json.JSON;
            type: "ancestor";
            element: string;
            name: Name.JSON;
        }
    }
    function ancestor(element: Element, name: Name): Ancestor;
    class Label implements Equatable, Serializable<Label.JSON> {
        static of(attribute: Attribute): Label;
        private readonly _attribute;
        protected constructor(attribute: Attribute);
        get type(): "label";
        get attribute(): Attribute;
        equals(value: unknown): value is this;
        [Symbol.iterator](): Iterator<Node>;
        toJSON(): Label.JSON;
    }
    namespace Label {
        interface JSON {
            [key: string]: json.JSON;
            type: "label";
            attribute: string;
        }
    }
    function label(attribute: Attribute): Label;
    class Reference implements Equatable, Serializable<Reference.JSON> {
        static of(attribute: Attribute, name: Name): Reference;
        private readonly _attribute;
        private readonly _name;
        protected constructor(attribute: Attribute, name: Name);
        get type(): "reference";
        get attribute(): Attribute;
        get name(): Name;
        equals(value: unknown): value is this;
        [Symbol.iterator](): Iterator<Node>;
        toJSON(): Reference.JSON;
    }
    namespace Reference {
        interface JSON {
            [key: string]: json.JSON;
            type: "reference";
            attribute: string;
            name: Name.JSON;
        }
    }
    function reference(attribute: Attribute, name: Name): Reference;
}
//# sourceMappingURL=source.d.ts.map