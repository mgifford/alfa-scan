import { Array } from "@siteimprove/alfa-array";
import { None, Option } from "@siteimprove/alfa-option";
/**
 * @internal
 */
export class State {
    static _empty = new State([], None, None, false, false);
    static empty() {
        return this._empty;
    }
    _visited;
    // which element has an aria-labelledby causing the current traversal?
    _referrer;
    // which element was the target of aria-labelledby?
    _referred;
    _isRecursing;
    _isDescending;
    constructor(visited, referrer, referred, isRecursing, isDescending) {
        this._visited = visited;
        this._referrer = referrer;
        this._referred = referred;
        this._isRecursing = isRecursing;
        this._isDescending = isDescending;
    }
    /**
     * The elements that have been seen by the name computation so far. This is
     * used for detecting circular references resulting from things such as the
     * `aria-labelledby` attribute and form controls that get their name from
     * a containing `<label>` element.
     */
    get visited() {
        return this._visited;
    }
    /**
     * The element that referenced the name computation.
     * (this is the element on which aria-labelledby is set)
     */
    get referrer() {
        return this._referrer;
    }
    /**
     * The element that is referenced during the name computation.
     * (this is the target of the aria-labelledby attribute)
     */
    get referred() {
        return this._referred;
    }
    /**
     * Whether the name computation is the result of recursion.
     */
    get isRecursing() {
        return this._isRecursing;
    }
    /**
     * Whether the name computation is the result of a reference.
     */
    get isReferencing() {
        return this._referrer.isSome();
    }
    /**
     * Whether the name computation is descending into a subtree.
     */
    get isDescending() {
        return this._isDescending;
    }
    hasVisited(element) {
        return this._visited.includes(element);
    }
    visit(element) {
        if (this._visited.includes(element)) {
            return this;
        }
        return new State([...this._visited, element], this._referrer, this._referred, this._isRecursing, this._isDescending);
    }
    recurse(isRecursing) {
        if (this._isRecursing === isRecursing) {
            return this;
        }
        return new State(this._visited, this._referrer, this._referred, isRecursing, this._isDescending);
    }
    /**
     * @remarks
     * This set both _referrer and _referred, so that they will always be
     * either both Some or both None.
     *
     * @remarks
     * We currently have no way to clear references since we currently have no
     * use for it.
     */
    reference(referrer, referred) {
        if (this._referrer.includes(referrer) &&
            this._referred.includes(referred)) {
            return this;
        }
        return new State(this._visited, Option.of(referrer), Option.of(referred), this._isRecursing, this._isDescending);
    }
    descend(isDescending) {
        if (this._isDescending === isDescending) {
            return this;
        }
        return new State(this._visited, this._referrer, this._referred, this._isRecursing, isDescending);
    }
    equals(value) {
        return (value instanceof State &&
            Array.equals(value._visited, this._visited) &&
            value._referrer.equals(this._referrer) &&
            value._referred.equals(this._referred) &&
            value._isRecursing === this._isRecursing &&
            value._isDescending === this._isDescending);
    }
    toJSON() {
        return {
            visited: this._visited.map((element) => element.path()),
            referrer: this._referrer.map((element) => element.path()).getOr(null),
            referred: this._referred.map((element) => element.path()).getOr(null),
            isRecursing: this._isRecursing,
            isDescending: this._isDescending,
        };
    }
}
//# sourceMappingURL=state.js.map