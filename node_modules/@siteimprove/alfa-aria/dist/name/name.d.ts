import { Array } from "@siteimprove/alfa-array";
import type { Device } from "@siteimprove/alfa-device";
import type { Attribute } from "@siteimprove/alfa-dom";
import { Element, Node, Text } from "@siteimprove/alfa-dom";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type { Thunk } from "@siteimprove/alfa-thunk";
import type * as json from "@siteimprove/alfa-json";
import * as predicate from "./predicate/index.js";
import { Source } from "./source.js";
import { State } from "./state.js";
/**
 * @public
 */
export declare class Name implements Equatable, Serializable<Name.JSON> {
    static of(value: string, sources?: Iterable<Source>, spaces?: {
        before?: boolean;
        after?: boolean;
    }): Name;
    private readonly _value;
    private readonly _sources;
    private readonly _spaceBefore;
    private readonly _spaceAfter;
    protected constructor(value: string, sources: Array<Source>, spaceBefore: boolean, spaceAfter: boolean);
    get value(): string;
    get spaces(): {
        before: boolean;
        after: boolean;
    };
    get hasSpaces(): boolean;
    get source(): ReadonlyArray<Source>;
    sourceNodes(): Iterable<Node>;
    /**
     * Normalize the name by trimming and collapsing spaces.
     *
     * @remarks
     * If the name starts or end with spaces that are removed upon trimming,
     * also records that they are needing upon concatenation.
     */
    normalize(): Name;
    /**
     * Add spaces before or after. Do not remove spaces if they are already there.
     */
    spaced(spaceBefore: boolean, spaceAfter?: boolean): Name;
    private add;
    static join(...names: Array<Name>): Name;
    isEmpty(): boolean;
    equals(value: unknown): value is this;
    toJSON(): Name.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Name {
    interface JSON {
        [key: string]: json.JSON;
        value: string;
        spaces: {
            before: boolean;
            after: boolean;
        };
        sources: Array<Source.JSON>;
    }
    function from(node: Element | Text, device: Device): Option<Name>;
    /**
     * @internal
     */
    function fromNode(node: Element | Text, device: Device, state: State): Option<Name>;
    /**
     * @internal
     */
    function fromElement(element: Element, device: Device, state: State): Option<Name>;
    /**
     * @internal
     */
    function fromText(text: Text): Option<Name>;
    /**
     * @remarks
     * Firefox incorrectly skips aria-labelledby when descending
     * {@link https://bugzilla.mozilla.org/show_bug.cgi?id=1652712}
     *
     * @internal
     */
    function fromDescendants(element: Element, device: Device, state: State): Option<Name>;
    /**
     * @internal
     */
    function fromLabel(attribute: Attribute): Option<Name>;
    /**
     * @internal
     */
    function fromReferences(attribute: Attribute, referrer: Element, device: Device, state: State): Option<Name>;
    /**
     * @remarks
     * For isolated spaces (e.g., <span> </span>), we need to keep memory of the
     * space and thus must carry over an empty name with spacing. This is
     * however more complex for steps. Here, we want to go to the next step in case
     * of whitespace name, but if we find no name, then we are possibly facing a
     * whitespace element's text and must keep it when concatenating sibling names.
     *
     * @internal
     */
    function fromSteps(...steps: Array<Thunk<Option<Name>>>): Option<Name>;
    const hasValue: typeof predicate.hasValue;
}
//# sourceMappingURL=name.d.ts.map