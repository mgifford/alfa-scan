import { Array } from "@siteimprove/alfa-array";
import type { Element } from "@siteimprove/alfa-dom";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type * as json from "@siteimprove/alfa-json";
/**
 * @internal
 */
export declare class State implements Equatable, Serializable<State.JSON> {
    private static _empty;
    static empty(): State;
    private readonly _visited;
    private readonly _referrer;
    private readonly _referred;
    private readonly _isRecursing;
    private readonly _isDescending;
    protected constructor(visited: Array<Element>, referrer: Option<Element>, referred: Option<Element>, isRecursing: boolean, isDescending: boolean);
    /**
     * The elements that have been seen by the name computation so far. This is
     * used for detecting circular references resulting from things such as the
     * `aria-labelledby` attribute and form controls that get their name from
     * a containing `<label>` element.
     */
    get visited(): Iterable<Element>;
    /**
     * The element that referenced the name computation.
     * (this is the element on which aria-labelledby is set)
     */
    get referrer(): Option<Element>;
    /**
     * The element that is referenced during the name computation.
     * (this is the target of the aria-labelledby attribute)
     */
    get referred(): Option<Element>;
    /**
     * Whether the name computation is the result of recursion.
     */
    get isRecursing(): boolean;
    /**
     * Whether the name computation is the result of a reference.
     */
    get isReferencing(): boolean;
    /**
     * Whether the name computation is descending into a subtree.
     */
    get isDescending(): boolean;
    hasVisited(element: Element): boolean;
    visit(element: Element): State;
    recurse(isRecursing: boolean): State;
    /**
     * @remarks
     * This set both _referrer and _referred, so that they will always be
     * either both Some or both None.
     *
     * @remarks
     * We currently have no way to clear references since we currently have no
     * use for it.
     */
    reference(referrer: Element, referred: Element): State;
    descend(isDescending: boolean): State;
    equals(state: State): boolean;
    equals(value: unknown): value is this;
    toJSON(): State.JSON;
}
/**
 * @internal
 */
export declare namespace State {
    interface JSON {
        [key: string]: json.JSON;
        visited: Array<string>;
        referrer: string | null;
        referred: string | null;
        isRecursing: boolean;
        isDescending: boolean;
    }
}
//# sourceMappingURL=state.d.ts.map