import type { Device } from "@siteimprove/alfa-device";
import { Flags } from "@siteimprove/alfa-flags";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { Sequence } from "@siteimprove/alfa-sequence";
import * as dom from "@siteimprove/alfa-dom";
import * as tree from "@siteimprove/alfa-tree";
import { Attribute } from "./attribute.js";
import { Name } from "./name/index.js";
import { Role } from "./role.js";
import * as predicate from "./node/predicate.js";
/**
 * {@link https://w3c.github.io/aria/#accessibility_tree}
 *
 * @public
 */
export declare abstract class Node<T extends string = string> extends tree.Node<"ARIA traversal", Node.TraversalFlags, T> implements Serializable<Node.JSON<T>> {
    protected readonly _node: dom.Node;
    protected constructor(owner: dom.Node, children: Array<Node>, type: T);
    get node(): dom.Node;
    get name(): Option<Name>;
    get role(): Option<Role>;
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option<Attribute<N>>;
    attribute(predicate: Predicate<Attribute>): Option<Attribute>;
    attribute<N extends Attribute.Name>(name: N): Option<Attribute<N>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    parent(options?: Node.Traversal): Option<Node>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    children(options?: Node.Traversal): Sequence<Node>;
    abstract clone(parent?: Option<Node>): Node;
    abstract isIgnored(): boolean;
    toJSON(): Node.JSON<T>;
}
/**
 * @public
 */
export interface Node {
    isParentOf(node: Node, options?: Node.Traversal): boolean;
    root(options?: Node.Traversal): Node;
    isRootOf(node: Node, options?: Node.Traversal): boolean;
    isChildOf(node: Node, options?: Node.Traversal): boolean;
    descendants(options?: Node.Traversal): Sequence<Node>;
    isDescendantOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveDescendants(options?: Node.Traversal): Sequence<Node>;
    isInclusiveDescendantsOf(node: Node, options?: Node.Traversal): boolean;
    ancestors(options?: Node.Traversal): Sequence<Node>;
    isAncestorOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveAncestors(options?: Node.Traversal): Sequence<Node>;
    isInclusiveAncestorOf(node: Node, options?: Node.Traversal): boolean;
    siblings(options?: Node.Traversal): Sequence<Node>;
    isSiblingOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveSiblings(options?: Node.Traversal): Sequence<Node>;
    isInclusiveSiblingOf(node: Node, options?: Node.Traversal): boolean;
    preceding(options?: Node.Traversal): Sequence<Node>;
    following(options?: Node.Traversal): Sequence<Node>;
    first(options?: Node.Traversal): Option<Node>;
    last(options?: Node.Traversal): Option<Node>;
    previous(options?: Node.Traversal): Option<Node>;
    next(options?: Node.Traversal): Option<Node>;
    index(options?: Node.Traversal): number;
    closest<T extends Node>(refinement: Refinement<Node, T>, options?: Node.Traversal): Option<T>;
    closest(predicate: Predicate<Node>, options?: Node.Traversal): Option<Node>;
}
/**
 * @public
 */
export declare namespace Node {
    interface JSON<T extends string = string> extends tree.Node.JSON<T> {
        node: string;
    }
    const Traversal: {
        of: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => {
            has(flag: 0 | 1 | "ignored"): boolean;
            isSet: (flag: 0 | 1 | "ignored") => boolean;
            add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
            set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
            remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
            unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
            is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): boolean;
            equals(value: any): boolean;
            equals(value: unknown): value is any;
            toString(): string;
            toJSON(): Flags.JSON<"ARIA traversal"> & {
                ignored: boolean;
            };
            readonly value: number;
            readonly kind: "ARIA traversal";
        } & {
            ignored: boolean;
        };
        readonly none: 0;
        readonly empty: {
            has(flag: 0 | 1 | "ignored"): boolean;
            isSet: (flag: 0 | 1 | "ignored") => boolean;
            add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
            set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
            remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
            unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
            is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): boolean;
            equals(value: any): boolean;
            equals(value: unknown): value is any;
            toString(): string;
            toJSON(): Flags.JSON<"ARIA traversal"> & {
                ignored: boolean;
            };
            readonly value: number;
            readonly kind: "ARIA traversal";
        } & {
            ignored: boolean;
        };
        readonly allFlags: [1];
        nameOf: (flag: 1) => "ignored";
        reduce: (...flags: import("@siteimprove/alfa-array").Array<number>) => number;
        named: <K extends string, A extends import("@siteimprove/alfa-array").Array<string>>(kind: K, ...flags: A) => {
            [x: string]: any;
        };
        ignored: 1;
    };
    type Traversal = ReturnType<(typeof Traversal)["of"]>;
    type TraversalFlags = (typeof Node.Traversal.allFlags)[number];
    /**
     * Traversal options to include ignored nodes in the traversal.
     */
    const includeIgnored: {
        has(flag: 0 | 1 | "ignored"): boolean;
        isSet: (flag: 0 | 1 | "ignored") => boolean;
        add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
        set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
        remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): any;
        unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">) => any;
        is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | "ignored">): boolean;
        equals(value: any): boolean;
        equals(value: unknown): value is any;
        toString(): string;
        toJSON(): Flags.JSON<"ARIA traversal"> & {
            ignored: boolean;
        };
        readonly value: number;
        readonly kind: "ARIA traversal";
    } & {
        ignored: boolean;
    };
    function from(node: dom.Node, device: Device): Node;
    const hasAttribute: typeof predicate.hasAttribute, hasName: typeof predicate.hasName, hasRole: typeof predicate.hasRole;
}
//# sourceMappingURL=node.d.ts.map