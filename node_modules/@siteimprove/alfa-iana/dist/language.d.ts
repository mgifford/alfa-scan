import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import { Result } from "@siteimprove/alfa-result";
import type * as json from "@siteimprove/alfa-json";
import { Languages } from "./language/data.js";
/**
 * @public
 */
export declare class Language implements Equatable, Serializable {
    static of(primary: Language.Primary, extended?: Option<Language.Extended>, script?: Option<Language.Script>, region?: Option<Language.Region>, variants?: Array<Language.Variant>): Language;
    private readonly _primary;
    private readonly _extended;
    private readonly _script;
    private readonly _region;
    private readonly _variants;
    constructor(primary: Language.Primary, extended: Option<Language.Extended>, script: Option<Language.Script>, region: Option<Language.Region>, variants: Array<Language.Variant>);
    get primary(): Language.Primary;
    get extended(): Option<Language.Extended>;
    get script(): Option<Language.Script>;
    get region(): Option<Language.Region>;
    get variants(): Iterable<Language.Variant>;
    equals(value: unknown): value is this;
    toJSON(): Language.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Language {
    interface JSON {
        [key: string]: json.JSON;
        type: "language";
        primary: Primary.JSON;
        extended: Extended.JSON | null;
        script: Script.JSON | null;
        region: Region.JSON | null;
        variants: Array<Variant.JSON>;
    }
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-3.1.11}
     */
    type Scope = Exclude<Languages["primary"][Primary.Name]["scope"], null>;
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-3.1.2}
     */
    abstract class Subtag<T extends string = string, N extends string = string> implements Equatable, Serializable<Subtag.JSON<T, N>> {
        protected readonly _name: N;
        protected constructor(name: N);
        /**
         * {@link https://tools.ietf.org/html/bcp47#section-3.1.3}
         */
        abstract get type(): T;
        /**
         * {@link https://tools.ietf.org/html/bcp47#section-3.1.4}
         */
        get name(): N;
        abstract equals<T extends string, N extends string>(value: Subtag<T, N>): boolean;
        abstract equals(value: unknown): value is this;
        abstract toJSON(): Subtag.JSON<T, N>;
        toString(): string;
    }
    namespace Subtag {
        interface JSON<T extends string = string, N extends string = string> {
            [key: string]: json.JSON;
            type: T;
            name: N;
        }
    }
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-2.2.1}
     */
    class Primary extends Subtag<"primary", Primary.Name> {
        static of(name: Primary.Name): Primary;
        protected constructor(name: Primary.Name);
        get type(): "primary";
        /**
         * {@link https://tools.ietf.org/html/bcp47#section-3.1.11}
         */
        get scope(): Option<Scope>;
        equals(value: Primary): boolean;
        equals(value: unknown): value is this;
        toJSON(): Primary.JSON;
    }
    namespace Primary {
        type Name = keyof Languages["primary"];
        interface JSON extends Subtag.JSON<"primary", Name> {
            scope: Scope | null;
        }
        function isPrimary(value: unknown): value is Primary;
        function isName(name: string): name is Name;
    }
    const primary: typeof Primary.of, isPrimary: typeof Primary.isPrimary, isPrimaryName: typeof Primary.isName;
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-2.2.2}
     */
    class Extended extends Subtag<"extended", Extended.Name> {
        static of(name: Extended.Name): Extended;
        protected constructor(name: Extended.Name);
        get type(): "extended";
        /**
         * {@link https://tools.ietf.org/html/bcp47#section-3.1.8}
         */
        get prefix(): Primary.Name;
        equals(value: Extended): boolean;
        equals(value: unknown): value is this;
        toJSON(): Extended.JSON;
    }
    namespace Extended {
        type Name = keyof Languages["extended"];
        interface JSON extends Subtag.JSON<"extended", Name> {
            prefix: Primary.Name;
        }
        function isExtended(value: unknown): value is Extended;
        function isName(name: string): name is Name;
    }
    const extended: typeof Extended.of, isExtended: typeof Extended.isExtended, isExtendedName: typeof Extended.isName;
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-2.2.3}
     */
    class Script extends Subtag<"script", Script.Name> {
        static of(name: Script.Name): Script;
        protected constructor(name: Script.Name);
        get type(): "script";
        equals(value: Script): boolean;
        equals(value: unknown): value is this;
        toJSON(): Script.JSON;
    }
    namespace Script {
        type Name = keyof Languages["script"];
        interface JSON extends Subtag.JSON<"script", Name> {
        }
        function isScript(value: unknown): value is Script;
        function isName(name: string): name is Name;
    }
    const script: typeof Script.of, isScript: typeof Script.isScript, isScriptName: typeof Script.isName;
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-2.2.4}
     */
    class Region extends Subtag<"region", Region.Name> {
        static of(name: Region.Name): Region;
        protected constructor(name: Region.Name);
        get type(): "region";
        equals(value: Region): boolean;
        equals(value: unknown): value is this;
        toJSON(): Region.JSON;
    }
    namespace Region {
        type Name = keyof Languages["region"];
        interface JSON extends Subtag.JSON<"region", Name> {
        }
        function isRegion(value: unknown): value is Region;
        function isName(name: string): name is Name;
    }
    const region: typeof Region.of, isRegion: typeof Region.isRegion, isRegionName: typeof Region.isName;
    /**
     * {@link https://tools.ietf.org/html/bcp47#section-2.2.5}
     */
    class Variant extends Subtag<"variant", Variant.Name> {
        static of(name: Variant.Name): Variant;
        protected constructor(name: Variant.Name);
        get type(): "variant";
        /**
         * {@link https://tools.ietf.org/html/bcp47#section-3.1.8}
         */
        get prefixes(): ReadonlyArray<string>;
        equals(value: Variant): boolean;
        equals(value: unknown): value is this;
        toJSON(): Variant.JSON;
    }
    namespace Variant {
        type Name = keyof Languages["variant"];
        interface JSON extends Subtag.JSON<"variant", Name> {
            prefixes: Array<string>;
        }
        function isVariant(value: unknown): value is Variant;
        function isName(name: string): name is Name;
    }
    const variant: typeof Variant.of, isVariant: typeof Variant.isVariant, isVariantName: typeof Variant.isName;
}
/**
 * @public
 */
export declare namespace Language {
    function parse(input: string): Result<Language, string>;
}
//# sourceMappingURL=language.d.ts.map