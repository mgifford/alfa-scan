import { Array } from "@siteimprove/alfa-array";
import type { Comparison } from "@siteimprove/alfa-comparable";
import type { Equatable } from "@siteimprove/alfa-equatable";
import { Element } from "@siteimprove/alfa-dom";
import type { Serializable } from "@siteimprove/alfa-json";
import { Sequence } from "@siteimprove/alfa-sequence";
import type * as json from "@siteimprove/alfa-json";
import { Anchored } from "./anchored.js";
import type { Slot } from "./slot.js";
import type { Scope } from "./scope.js";
import * as predicate from "./cell/predicate.js";
/**
 * {@link https://html.spec.whatwg.org/#concept-cell}
 *
 * @public
 */
export declare abstract class Cell implements Anchored, Equatable, Serializable<Cell.JSON> {
    protected readonly _element: Element;
    protected readonly _anchor: Slot;
    protected readonly _width: number;
    protected readonly _height: number;
    protected readonly _headers: Array<Slot>;
    protected constructor(element: Element, anchor: Slot, width: number, height: number, headers: Array<Slot>);
    get element(): Element;
    get anchor(): Slot;
    get x(): number;
    get y(): number;
    get width(): number;
    get height(): number;
    get headers(): Sequence<Slot>;
    /**
     * {@link https://html.spec.whatwg.org/#empty-cell}
     */
    isEmpty(): boolean;
    abstract isData(): this is Cell.Data;
    abstract isHeader(): this is Cell.Header;
    compare(anchored: Anchored): Comparison;
    equals(cell: Cell): boolean;
    equals(value: unknown): value is this;
    abstract toJSON(): Cell.JSON;
}
/**
 * @public
 */
export declare namespace Cell {
    interface JSON {
        [key: string]: json.JSON;
        element: string;
        anchor: Slot.JSON;
        width: number;
        height: number;
        headers: Array<Slot.JSON>;
    }
    function isCell(value: unknown): value is Cell;
    const hasElement: typeof predicate.hasElement;
    class Data extends Cell {
        static of(element: Element, anchor: Slot, width: number, height: number, headers?: Iterable<Slot>): Data;
        protected constructor(element: Element, anchor: Slot, width: number, height: number, headers: Array<Slot>);
        isData(): this is Data;
        isHeader(): this is never;
        equals(cell: Data): boolean;
        equals(value: unknown): value is this;
        toJSON(): Data.JSON;
    }
    namespace Data {
        interface JSON extends Cell.JSON {
            type: "data";
        }
        function isData(value: unknown): value is Data;
    }
    const data: typeof Data.of, isData: typeof Data.isData;
    class Header extends Cell {
        static of(element: Element, anchor: Slot, width: number, height: number, headers?: Iterable<Slot>, scope?: Scope): Header;
        private readonly _scope;
        protected constructor(element: Element, anchor: Slot, width: number, height: number, headers: Array<Slot>, scope: Scope);
        get scope(): Scope;
        isData(): this is never;
        isHeader(): this is Header;
        equals(cell: Header): boolean;
        equals(value: unknown): value is this;
        toJSON(): Header.JSON;
    }
    namespace Header {
        interface JSON extends Cell.JSON {
            type: "header";
            scope: Scope;
        }
        function isHeader(value: unknown): value is Header;
    }
    const header: typeof Header.of, isHeader: typeof Header.isHeader;
}
//# sourceMappingURL=cell.d.ts.map