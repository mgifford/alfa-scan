import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Map } from "@siteimprove/alfa-map";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Set } from "@siteimprove/alfa-set";
/**
 * @public
 */
export class Graph {
    static of(nodes) {
        return new Graph(nodes);
    }
    static _empty = new Graph(Map.empty());
    static empty() {
        return this._empty;
    }
    _nodes;
    constructor(nodes) {
        this._nodes = nodes;
    }
    get size() {
        return this._nodes.size;
    }
    isEmpty() {
        return this._nodes.isEmpty();
    }
    nodes() {
        return this._nodes.keys();
    }
    neighbors(node) {
        return this._nodes.get(node).getOr([]);
    }
    has(node) {
        return this._nodes.has(node);
    }
    add(node) {
        if (this.has(node)) {
            return this;
        }
        return new Graph(this._nodes.set(node, Set.empty()));
    }
    delete(node) {
        const nodes = this._nodes;
        if (!nodes.has(node)) {
            return this;
        }
        return new Graph(nodes.delete(node).map((neighbors) => neighbors.delete(node)));
    }
    connect(from, to) {
        let nodes = this._nodes;
        if (!nodes.has(from)) {
            nodes = nodes.set(from, Set.empty());
        }
        if (!nodes.has(to)) {
            nodes = nodes.set(to, Set.empty());
        }
        return new Graph(nodes.set(from, nodes
            .get(from)
            .map((from) => from.add(to))
            // Presence of from is guaranteed by first test.
            .getUnsafe()));
    }
    disconnect(from, to) {
        if (!this.has(from) || !this.has(to)) {
            return this;
        }
        const nodes = this._nodes;
        return new Graph(nodes.set(from, nodes
            .get(from)
            .map((from) => from.delete(to))
            // presence of from is guaranteed by first test.
            .getUnsafe()));
    }
    traverse(root, traversal = Graph.DepthFirst) {
        return Sequence.from(traversal(this, root));
    }
    path(from, to, traversal = Graph.BreadthFirst) {
        const parents = Map.from(traversal(this, from));
        const path = [];
        while (parents.has(to)) {
            const parent = parents
                .get(to)
                // presence of to is guaranteed by the loop condition
                .getUnsafe();
            path.unshift(to);
            to = parent;
        }
        return Sequence.from(path);
    }
    hasPath(from, to) {
        if (!this.has(from) || !this.has(to)) {
            return false;
        }
        return this.traverse(from)
            .map(([node]) => node)
            .includes(to);
    }
    reverse() {
        let reversed = Graph.empty();
        for (const [node, neighbors] of this._nodes) {
            reversed = reversed.add(node);
            for (const neighbor of neighbors) {
                reversed = reversed.connect(neighbor, node);
            }
        }
        return reversed;
    }
    *sort() {
        let incoming = this.reverse();
        const queue = incoming
            .toArray()
            .filter(([, edges]) => edges.length === 0)
            .map(([node]) => node);
        while (queue.length > 0) {
            const next = queue.shift();
            yield next;
            for (const neighbor of this.neighbors(next)) {
                incoming = incoming.disconnect(neighbor, next);
                if (Iterable.isEmpty(incoming.neighbors(neighbor))) {
                    queue.push(neighbor);
                }
            }
        }
    }
    equals(value) {
        return value instanceof Graph && value._nodes.equals(this._nodes);
    }
    hash(hash) {
        hash.writeHashable(this._nodes);
    }
    *iterator() {
        yield* this._nodes;
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toArray() {
        return [...this].map(([node, neighbors]) => [node, [...neighbors]]);
    }
    toJSON(options) {
        return this.toArray().map(([node, neighbors]) => [
            Serializable.toJSON(node, options),
            neighbors.map((node) => Serializable.toJSON(node, options)),
        ]);
    }
    toString() {
        const entries = this.toArray()
            .map(([node, edges]) => {
            const entries = edges.join(", ");
            return `${node}${entries === "" ? "" : ` => [ ${entries} ]`}`;
        })
            .join(", ");
        return `Graph {${entries === "" ? "" : ` ${entries} `}}`;
    }
}
/**
 * @public
 */
(function (Graph) {
    function isGraph(value) {
        return value instanceof Graph;
    }
    Graph.isGraph = isGraph;
    function from(iterable) {
        if (isGraph(iterable)) {
            return iterable;
        }
        return Graph.of(Map.from(Iterable.map(iterable, ([node, neighbours]) => [
            node,
            Set.from(neighbours),
        ])));
    }
    Graph.from = from;
    /**
     * {@link https://en.wikipedia.org/wiki/Depth-first_search}
     */
    Graph.DepthFirst = function* (graph, root) {
        const stack = [...graph.neighbors(root)].map((node) => [node, root]);
        let seen = Set.of(root);
        while (stack.length > 0) {
            const next = stack.pop();
            if (seen.has(next[0])) {
                continue;
            }
            yield next;
            seen = seen.add(next[0]);
            for (const neighbor of graph.neighbors(next[0])) {
                stack.push([neighbor, next[0]]);
            }
        }
    };
    /**
     * {@link https://en.wikipedia.org/wiki/Breadth-first_search}
     */
    Graph.BreadthFirst = function* (graph, root) {
        const queue = [...graph.neighbors(root)].map((node) => [node, root]);
        let seen = Set.of(root, ...graph.neighbors(root));
        while (queue.length > 0) {
            const next = queue.shift();
            yield next;
            for (const neighbor of graph.neighbors(next[0])) {
                if (seen.has(neighbor)) {
                    continue;
                }
                seen = seen.add(neighbor);
                queue.push([neighbor, next[0]]);
            }
        }
    };
})(Graph || (Graph = {}));
//# sourceMappingURL=graph.js.map