import type { Callback } from "@siteimprove/alfa-callback";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Predicate } from "@siteimprove/alfa-predicate";
/**
 * @public
 */
export type Refinement<T, U extends T, A extends Array<unknown> = []> = (value: T, ...args: A) => value is U;
/**
 * @public
 */
export declare namespace Refinement {
    interface Test {
        <T, U extends T, A extends Array<unknown> = []>(refinement: Refinement<T, U, A>, value: T, ...args: A): value is U;
        <T, A extends Array<unknown> = []>(predicate: Predicate<T, A>, value: T, ...args: A): boolean;
    }
    export const test: Test;
    interface Fold {
        <T, U extends T, A extends Array<unknown> = [], V = U, W = T>(refinement: Refinement<T, U, A>, ifTrue: Mapper<U, V>, ifFalse: Mapper<T, W>, value: T, ...args: A): V | W;
        <T, A extends Array<unknown> = [], V = T, W = T>(predicate: Predicate<T, A>, ifTrue: Mapper<T, V>, ifFalse: Mapper<T, W>, value: T, ...args: A): V | W;
    }
    export const fold: Fold;
    interface Not {
        <T, U extends T, A extends Array<unknown> = []>(refinement: Refinement<T, U, A>): Refinement<T, Exclude<T, U>, A>;
        <T, A extends Array<unknown> = []>(predicate: Predicate<T, A>): Predicate<T, A>;
    }
    export const not: Not;
    interface And {
        <T, U extends T, V extends U, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<U, V, A>): Refinement<T, V, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<U, A>): Refinement<T, U, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U, A>;
        <T, A extends Array<unknown> = []>(...predicates: Array<Predicate<T, A>>): Predicate<T, A>;
    }
    export const and: And;
    interface Or {
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, U | V, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, U | T, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U | T, A>;
        <T, A extends Array<unknown> = []>(...predicates: Array<Predicate<T, A>>): Predicate<T, A>;
    }
    export const or: Or;
    interface Xor {
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, U | V, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, U | T, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U | T, A>;
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    export const xor: Xor;
    interface Nor {
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, Exclude<T, U | V>, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, Exclude<T, U>, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, Exclude<T, U>, A>;
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    export const nor: Nor;
    interface Nand {
        <T, U extends T, V extends U, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, Exclude<T, U> | Exclude<T, V>, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Predicate<T, A>;
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Predicate<T, A>;
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    export const nand: Nand;
    interface Equals {
        <T, U extends T>(...values: Array<U>): Refinement<T, U>;
        <T>(...values: Array<T>): Predicate<unknown>;
    }
    export const equals: Equals;
    interface Tee {
        <T, U extends T, A extends Array<unknown> = []>(refinement: Refinement<T, U, A>, callback: Callback<T, void, [result: boolean, ...args: A]>): Refinement<T, U, A>;
        <T, A extends Array<unknown> = []>(predicate: Predicate<T, A>, callback: Callback<T, void, [result: boolean, ...args: A]>): Predicate<T, A>;
    }
    export const tee: Tee;
    export function isString(value: unknown): value is string;
    export function isNumber(value: unknown): value is number;
    export function isBigInt(value: unknown): value is bigint;
    export function isBoolean(value: unknown): value is boolean;
    export function isNull(value: unknown): value is null;
    export function isUndefined(value: unknown): value is undefined;
    export function isSymbol(value: unknown): value is symbol;
    export function isFunction(value: unknown): value is Function;
    export function isObject(value: unknown): value is {
        [key: string]: unknown;
    };
    export const isPrimitive: Refinement<unknown, string | number | bigint | boolean | symbol | null | undefined, []>;
    export {};
}
//# sourceMappingURL=refinement.d.ts.map