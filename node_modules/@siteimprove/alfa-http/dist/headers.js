import { Iterable } from "@siteimprove/alfa-iterable";
import { Map } from "@siteimprove/alfa-map";
import { Header } from "./header.js";
/**
 * @public
 */
export class Headers {
    /**
     * @remarks
     * If the iterable contains headers with duplicate names, the last header with
     * a given name will take precedence.
     */
    static of(headers) {
        return new Headers(Map.from(Iterable.map(headers, (header) => [header.name, header])));
    }
    static _empty = new Headers(Map.empty());
    static empty() {
        return this._empty;
    }
    _headers;
    constructor(headers) {
        this._headers = headers;
    }
    get(name) {
        return this._headers.get(name);
    }
    has(name) {
        return this._headers.has(name);
    }
    add(header) {
        return new Headers(this._headers.set(header.name, header));
    }
    delete(name) {
        return new Headers(this._headers.delete(name));
    }
    *[Symbol.iterator]() {
        yield* this._headers.values();
    }
    toArray() {
        return [...this];
    }
    toJSON(options) {
        return this.toArray().map((header) => header.toJSON(options));
    }
    toEARL() {
        return {
            "@context": {
                http: "http://www.w3.org/2011/http#",
            },
            "@list": this.toArray().map((header) => header.toEARL()),
        };
    }
    toString() {
        return this.toArray()
            .map((header) => header.toString())
            .join("\n");
    }
}
/**
 * @public
 */
(function (Headers) {
    function from(json) {
        return Headers.of(json.map((header) => Header.from(header)));
    }
    Headers.from = from;
    function isHeaders(value) {
        return value instanceof Headers;
    }
    Headers.isHeaders = isHeaders;
})(Headers || (Headers = {}));
//# sourceMappingURL=headers.js.map