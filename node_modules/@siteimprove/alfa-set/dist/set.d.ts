import { Array } from "@siteimprove/alfa-array";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Collection } from "@siteimprove/alfa-collection";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Map } from "@siteimprove/alfa-map";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @public
 */
export declare class Set<T> implements Collection.Unkeyed<T> {
    static of<T>(...values: Array<T>): Set<T>;
    private static _empty;
    static empty<T>(): Set<T>;
    private readonly _values;
    protected constructor(values: Map<T, T>);
    get size(): number;
    isEmpty(): this is Set<never>;
    forEach(callback: Callback<T>): void;
    map<U>(mapper: Mapper<T, U>): Set<U>;
    apply<U>(mapper: Set<Mapper<T, U>>): Set<U>;
    flatMap<U>(mapper: Mapper<T, Set<U>>): Set<U>;
    flatten<T>(this: Set<Set<T>>): Set<T>;
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    filter<U extends T>(refinement: Refinement<T, U>): Set<U>;
    filter(predicate: Predicate<T>): Set<T>;
    reject<U extends T>(refinement: Refinement<T, U>): Set<Exclude<T, U>>;
    reject(predicate: Predicate<T>): Set<T>;
    find<U extends T>(refinement: Refinement<T, U>): Option<U>;
    find(predicate: Predicate<T>): Option<T>;
    includes(value: T): boolean;
    collect<U>(mapper: Mapper<T, Option<U>>): Set<U>;
    collectFirst<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    some(predicate: Predicate<T>): boolean;
    none(predicate: Predicate<T>): boolean;
    every(predicate: Predicate<T>): boolean;
    count(predicate: Predicate<T>): number;
    /**
     * @remarks
     * As sets don't contain duplicate values, they will only ever contain
     * distinct values.
     */
    distinct(): Set<T>;
    get(value: T): Option<T>;
    has(value: T): boolean;
    add(value: T): Set<T>;
    delete(value: T): Set<T>;
    concat(iterable: Iterable<T>): Set<T>;
    subtract(iterable: Iterable<T>): Set<T>;
    intersect(iterable: Iterable<T>): Set<T>;
    tee<A extends Array<unknown> = []>(callback: Callback<this, void, [...args: A]>, ...args: A): this;
    equals<T>(value: Set<T>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    iterator(): Iterator<T>;
    [Symbol.iterator](): Iterator<T>;
    toArray(): Array<T>;
    toJSON(options?: Serializable.Options): Set.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Set {
    type JSON<T> = Collection.Unkeyed.JSON<T>;
    function isSet<T>(value: Iterable<T>): value is Set<T>;
    function isSet<T>(value: unknown): value is Set<T>;
    function from<T>(iterable: Iterable<T>): Set<T>;
    function fromArray<T>(array: ReadonlyArray<T>): Set<T>;
    function fromIterable<T>(iterable: Iterable<T>): Set<T>;
}
//# sourceMappingURL=set.d.ts.map