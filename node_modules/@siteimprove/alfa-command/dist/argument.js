import { Option, None } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Result, Err } from "@siteimprove/alfa-result";
import { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @public
 */
export class Argument {
    static of(name, description, parse) {
        const options = {
            default: None,
            optional: false,
            repeatable: false,
        };
        return new Argument(name, description.replace(/\s+/g, " ").trim(), options, parse);
    }
    _name;
    _description;
    _options;
    _parse;
    constructor(name, description, options, parse) {
        this._name = name;
        this._description = description;
        this._options = options;
        this._parse = parse;
    }
    get name() {
        return this._name;
    }
    get description() {
        return this._description;
    }
    get options() {
        return this._options;
    }
    get parse() {
        return this._parse;
    }
    map(mapper) {
        return new Argument(this._name, this._description, this._options, Parser.map(this._parse, mapper));
    }
    filter(predicate, ifError = () => "Incorrect value") {
        return new Argument(this._name, this._description, this._options, Parser.filter(this._parse, predicate, ifError));
    }
    optional() {
        return new Argument(this._name, this._description, {
            ...this._options,
            optional: true,
        }, Parser.option(this._parse));
    }
    repeatable() {
        return new Argument(this._name, this._description, {
            ...this._options,
            repeatable: true,
        }, Parser.oneOrMore(this._parse));
    }
    default(value, label = `${value}`) {
        label = label.replace(/\s+/g, " ").trim();
        return new Argument(this._name, this._description, {
            ...this._options,
            optional: true,
            default: label === "" ? None : Option.of(label),
        }, this._parse);
    }
    choices(...choices) {
        return this.filter(Refinement.equals(...choices));
    }
    toJSON() {
        return {
            name: this._name,
            description: this._description,
            options: {
                ...this._options,
                default: this._options.default.getOr(null),
            },
        };
    }
}
/**
 * @public
 */
(function (Argument) {
    function string(name, description) {
        return Argument.of(name, description, (argv) => {
            const [value] = argv;
            if (value === undefined) {
                return Err.of("Missing value");
            }
            return Result.of([argv.slice(1), value]);
        });
    }
    Argument.string = string;
    function number(name, description) {
        return Argument.of(name, description, (argv) => {
            const [value] = argv;
            if (value === undefined) {
                return Err.of("Missing value");
            }
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return Err.of(`${value} is not a number`);
            }
            return Result.of([argv.slice(1), number]);
        });
    }
    Argument.number = number;
    function integer(name, description) {
        return Argument.of(name, description, (argv) => {
            const [value] = argv;
            if (value === undefined) {
                return Err.of("Missing value");
            }
            const number = Number(value);
            if (!Number.isInteger(number)) {
                return Err.of(`${value} is not an integer`);
            }
            return Result.of([argv.slice(1), number]);
        });
    }
    Argument.integer = integer;
    function boolean(name, description) {
        return Argument.of(name, description, (argv) => {
            const [value] = argv;
            if (value === undefined) {
                return Err.of("Missing value");
            }
            if (value !== "true" && value !== "false") {
                return Err.of(`Incorrect value, expected one of "true", "false"`);
            }
            return Result.of([argv.slice(1), value === "true"]);
        });
    }
    Argument.boolean = boolean;
})(Argument || (Argument = {}));
//# sourceMappingURL=argument.js.map