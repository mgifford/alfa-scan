import type { Functor } from "@siteimprove/alfa-functor";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import { Refinement } from "@siteimprove/alfa-refinement";
import type { Thunk } from "@siteimprove/alfa-thunk";
import type * as json from "@siteimprove/alfa-json";
import type * as parser from "@siteimprove/alfa-parser";
/**
 * @public
 */
export declare class Flag<T = unknown> implements Functor<T>, Serializable<Flag.JSON> {
    static of<T>(name: string, description: string, parse: Flag.Parser<T, [Predicate<string>]>): Flag<T>;
    private readonly _name;
    private readonly _description;
    private readonly _options;
    private readonly _parse;
    protected constructor(name: string, description: string, options: Flag.Options, parse: Flag.Parser<T, [Predicate<string>]>);
    get name(): string;
    get description(): string;
    get options(): Flag.Options;
    get parse(): Flag.Parser<T>;
    matches(name: string): boolean;
    map<U>(mapper: Mapper<T, U>): Flag<U>;
    filter<U extends T>(refinement: Refinement<T, U>, ifError?: Thunk<string>): Flag<U>;
    filter(predicate: Predicate<T>, ifError?: Thunk<string>): Flag<T>;
    type(type: string): Flag<T>;
    alias(alias: string): Flag<T>;
    default(value: T, label?: string): Flag<T>;
    optional(): Flag<Option<T>>;
    repeatable(): Flag<Array<T>>;
    negatable(mapper: Mapper<T>): Flag<T>;
    choices<U extends T>(...choices: Array<U>): Flag<U>;
    toJSON(): Flag.JSON;
}
/**
 * @public
 */
export declare namespace Flag {
    interface JSON {
        [key: string]: json.JSON;
        name: string;
        description: string;
        options: {
            [key: string]: json.JSON;
            type: string | null;
            aliases: Array<string>;
            default: json.JSON | null;
            optional: boolean;
            repeatable: boolean;
        };
    }
    type Parser<T, A extends Array<unknown> = []> = parser.Parser<Array<string>, Set<T>, string, A>;
    interface Options {
        readonly type: Option<string>;
        readonly aliases: Array<string>;
        readonly default: Option<string>;
        readonly optional: boolean;
        readonly repeatable: boolean;
        readonly negatable: boolean;
    }
    /**
     * The `Set<T>` class, from the concept of "flag sets", acts as a container
     * for parsed flag values. As flags can be specified multiple times, this
     * class allows us to encapsulate the current value of a given flag and a
     * parser to parse another instance of the flag value and determine how to
     * combine the two.
     */
    class Set<T> implements Functor<T> {
        static of<T>(value: T, parse: Flag.Parser<T>): Set<T>;
        private readonly _value;
        private readonly _parse;
        protected constructor(value: T, parse: Flag.Parser<T>);
        get value(): T;
        get parse(): Flag.Parser<T>;
        map<U>(mapper: Mapper<T, U>): Set<U>;
    }
    function string(name: string, description: string): Flag<string>;
    function number(name: string, description: string): Flag<number>;
    function integer(name: string, description: string): Flag<number>;
    function boolean(name: string, description: string): Flag<boolean>;
    function empty(name: string, description: string): Flag<void>;
    const Help: unique symbol;
    function help(description: string): Flag<Option<symbol>>;
    const Version: unique symbol;
    function version(description: string): Flag<Option<symbol>>;
}
//# sourceMappingURL=flag.d.ts.map