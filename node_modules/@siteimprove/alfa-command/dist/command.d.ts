import type { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Result } from "@siteimprove/alfa-result";
import type * as json from "@siteimprove/alfa-json";
import type { Argument } from "./argument.js";
import { Flag } from "./flag.js";
/**
 * @public
 */
export declare class Command<F extends Command.Flags = {}, A extends Command.Arguments = {}, S extends Command.Subcommands = {}> implements Serializable<Command.JSON> {
    static withArguments<F extends Command.Flags, A extends Command.Arguments>(name: string, version: string, description: string, flags: F, args: A, parent?: Option<Command>, run?: (command: Command<F, A, {}>) => Command.Runner<F, A>): Command<F, A, {}>;
    static withSubcommands<F extends Command.Flags, S extends Command.Subcommands>(name: string, version: string, description: string, flags: F, subcommands: Mapper<Command, S>, parent?: Option<Command>, run?: (command: Command<F, {}, S>) => Command.Runner<F, {}>): Command<F, {}, S>;
    private readonly _name;
    private readonly _version;
    private readonly _description;
    private readonly _flags;
    private readonly _arguments;
    private readonly _subcommands;
    private readonly _parent;
    private readonly _run;
    protected constructor(name: string, version: string, description: string, flags: F, args: A, subcommands: Mapper<Command, S>, parent: Option<Command>, run?: (command: Command<F, A, S>) => Command.Runner<F, A>);
    get name(): string;
    get version(): string;
    get description(): string;
    get flags(): F;
    get arguments(): A;
    get subcommands(): S;
    run(input: Array<string> | Command.Input<F, A>): Command.Output;
    toJSON(): Command.JSON;
    private _parseFlags;
    private _parseArguments;
    private _invocation;
    private _help;
    private _helpUsage;
    private _helpVersion;
    private _helpArguments;
    private _helpCommands;
    private _helpFlags;
}
/**
 * @public
 */
export declare namespace Command {
    interface JSON {
        [key: string]: json.JSON;
        name: string;
        description: string;
        flags: Array<Flag.JSON>;
        arguments: Array<Argument.JSON>;
        subcommands: Array<Command.JSON>;
    }
    interface Flags {
        [name: string]: Flag<any>;
    }
    namespace Flags {
        type Values<F extends Flags> = {
            [N in keyof F]: F[N] extends Flag<infer T> ? T : never;
        };
    }
    interface Arguments {
        [name: string]: Argument<any>;
    }
    namespace Arguments {
        type Values<A extends Arguments> = {
            [N in keyof A]: A[N] extends Argument<infer T> ? T : never;
        };
    }
    interface Subcommands {
        [name: string]: Command<any, any, any>;
    }
    interface Input<F extends Flags, A extends Arguments> {
        flags: Flags.Values<F>;
        args: Arguments.Values<A>;
    }
    type Output = Promise<Result<string>>;
    type Runner<F extends Flags, A extends Arguments> = (input: Input<F, A>) => Output;
}
//# sourceMappingURL=command.d.ts.map