import { Option, None } from "@siteimprove/alfa-option";
import { Result, Err } from "@siteimprove/alfa-result";
import chalk from "chalk";
import { Flag } from "./flag.js";
import { Text } from "./text.js";
const { values, entries } = Object;
/**
 * @public
 */
export class Command {
    static withArguments(name, version, description, flags, args, parent = None, run) {
        return new Command(name, version, description, flags, args, () => ({}), parent, run);
    }
    static withSubcommands(name, version, description, flags, subcommands, parent = None, run) {
        return new Command(name, version, description, flags, {}, subcommands, parent, run);
    }
    _name;
    _version;
    _description;
    _flags;
    _arguments;
    _subcommands;
    _parent;
    _run;
    constructor(name, version, description, flags, args, subcommands, parent, run) {
        this._name = name;
        this._version = version;
        this._description = description;
        this._flags = flags;
        this._arguments = args;
        this._subcommands = subcommands(this);
        this._parent = parent;
        this._run = run?.(this) ?? (async () => Result.of(this._help()));
    }
    get name() {
        return this._name;
    }
    get version() {
        return this._version;
    }
    get description() {
        return this._description;
    }
    get flags() {
        return this._flags;
    }
    get arguments() {
        return this._arguments;
    }
    get subcommands() {
        return this._subcommands;
    }
    async run(input) {
        if (Array.isArray(input)) {
            let argv = input;
            input = {};
            const flags = this._parseFlags(argv);
            if (!flags.isOk()) {
                return flags;
            }
            [argv, input.flags] = flags.get();
            for (const name in this._flags) {
                const value = input.flags[name];
                if (Option.isOption(value) && value.isSome()) {
                    switch (value.get()) {
                        case Flag.Help:
                            return Result.of(this._help());
                        case Flag.Version:
                            return Result.of(this._version);
                    }
                }
            }
            if (argv[0] === "--") {
                argv = argv.slice(1);
            }
            for (const command of values(this._subcommands)) {
                if (command.name === argv[0]) {
                    return command.run(argv.slice(1));
                }
            }
            const args = this._parseArguments(argv);
            if (!args.isOk()) {
                return args;
            }
            [argv, input.args] = args.get();
            if (argv.length !== 0) {
                const [argument] = argv;
                return Err.of(`Unknown ${argument[0] === "-" ? "flag" : "argument"}: ${argument}`);
            }
        }
        return this._run(input);
    }
    toJSON() {
        return {
            name: this._name,
            description: this._description,
            flags: values(this._flags).map((flag) => flag.toJSON()),
            arguments: values(this._arguments).map((argument) => argument.toJSON()),
            subcommands: values(this._subcommands).map((command) => command.toJSON()),
        };
    }
    _parseFlags(argv) {
        const flags = entries(this._flags);
        const sets = {};
        while (argv.length > 0) {
            const [argument] = argv;
            if (argument[0] !== "-") {
                break;
            }
            const match = flags.find(([, flag]) => flag.matches(argument));
            if (match === undefined) {
                return Err.of(`Unknown flag: ${argument}`);
            }
            const [name, flag] = match;
            const parse = name in sets ? sets[name].parse : flag.parse;
            const value = parse(argv);
            if (value.isOk()) {
                [argv, sets[name]] = value.get();
            }
            else {
                return Err.of(`${argument}: ${value.getErrUnsafe()}`);
            }
        }
        const values = {};
        for (const [name, flag] of flags) {
            if (name in sets) {
                values[name] = sets[name].value;
            }
            else {
                const result = flag.parse([]);
                if (result.isErr()) {
                    return Err.of(`--${flag.name}: ${result.getErr()}`);
                }
                const [, { value }] = result.getUnsafe();
                values[name] = value;
            }
        }
        return Result.of([argv, values]);
    }
    _parseArguments(argv) {
        const values = {};
        for (const [name, argument] of entries(this._arguments)) {
            const result = argument.parse(argv);
            if (result.isOk()) {
                [argv, values[name]] = result.get();
            }
            else {
                return Err.of(`${argument.name}: ${result.getErrUnsafe()}`);
            }
        }
        return Result.of([argv, values]);
    }
    _invocation() {
        const invocation = this._name;
        for (const parent of this._parent) {
            return parent._invocation() + " " + invocation;
        }
        return invocation;
    }
    _help() {
        return [
            this._description,
            this._helpVersion(),
            this._helpUsage(),
            ...this._helpArguments(),
            ...this._helpCommands(),
            ...this._helpFlags(),
        ].join("\n\n");
    }
    _helpUsage() {
        return `
${chalk.bold("Usage:")}

  ${chalk.bold("$")} ${this._invocation()} [flags] ${[
            ...values(this._arguments),
        ]
            .map((argument) => argument.options.optional
            ? `[<${argument.name}>]`
            : `<${argument.name}>`)
            .join(" ")}
    `.trim();
    }
    _helpVersion() {
        return `
${chalk.bold("Version:")}

  ${this._version}
    `.trim();
    }
    _helpArguments() {
        const args = values(this._arguments);
        if (args.length === 0) {
            return None;
        }
        return Option.of(`
${chalk.bold("Arguments:")}

${args
            .map((argument) => {
            const { options } = argument;
            let help = "  ";
            help += chalk.bold(`${argument.name}`);
            if (!options.optional) {
                help += " " + chalk.dim("(required)");
            }
            for (const value of options.default) {
                help += " " + chalk.dim(`[default: ${value}]`);
            }
            help += "\n";
            help += Text.indent(Text.wrap(argument.description, 76), 4);
            return help;
        })
            .join("\n\n")}
      `.trim());
    }
    _helpCommands() {
        const commands = values(this._subcommands);
        if (commands.length === 0) {
            return None;
        }
        return Option.of(`
${chalk.bold("Commands:")}

${[...values(this._subcommands)]
            .map((command) => `  ${chalk.bold(command.name)}\n${Text.indent(Text.wrap(command.description, 76), 4)}`)
            .join("\n\n")}
      `.trim());
    }
    _helpFlags() {
        const flags = values(this._flags);
        if (flags.length === 0) {
            return None;
        }
        return Option.of(`
${chalk.bold("Flags:")}

${[...values(this._flags)]
            .map((flag) => {
            const { options } = flag;
            let help = "  ";
            if (options.aliases.length > 0) {
                help +=
                    options.aliases
                        .map((alias) => chalk.bold(alias.length === 1 ? `-${alias}` : `--${alias}`))
                        .join(", ") + ", ";
            }
            help += chalk.bold(`--${options.negatable ? "[no-]" : ""}${flag.name}`);
            for (const type of options.type) {
                help += ` <${chalk.underline(type)}>`;
            }
            if (!options.optional) {
                help += " " + chalk.dim("(required)");
            }
            for (const value of options.default) {
                help += " " + chalk.dim(`[default: ${value}]`);
            }
            help += "\n";
            help += Text.indent(Text.wrap(flag.description, 76), 4);
            return help;
        })
            .join("\n\n")}
      `.trim());
    }
}
//# sourceMappingURL=command.js.map