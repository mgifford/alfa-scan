import { Serializable } from "@siteimprove/alfa-json";
import { Option, None } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Result, Err } from "@siteimprove/alfa-result";
import { Refinement } from "@siteimprove/alfa-refinement";
/**
 * @public
 */
export class Flag {
    static of(name, description, parse) {
        const options = {
            type: None,
            aliases: [],
            optional: false,
            repeatable: false,
            negatable: false,
            default: None,
        };
        return new Flag(name, description.replace(/\s+/g, " ").trim(), options, parse);
    }
    _name;
    _description;
    _options;
    _parse;
    constructor(name, description, options, parse) {
        this._name = name;
        this._description = description;
        this._options = options;
        this._parse = parse;
    }
    get name() {
        return this._name;
    }
    get description() {
        return this._description;
    }
    get options() {
        return this._options;
    }
    get parse() {
        return (argv) => this._parse(argv, (name) => this.matches(name));
    }
    matches(name) {
        name = name.length === 2 ? name.replace(/^-/, "") : name.replace(/^--/, "");
        if (this._options.negatable) {
            name = name.replace(/^no-/, "");
        }
        return (this._name === name ||
            this._options.aliases.some((alias) => alias === name));
    }
    map(mapper) {
        return new Flag(this._name, this._description, this._options, Parser.map(this._parse, (set) => set.map(mapper)));
    }
    filter(predicate, ifError = () => "Incorrect value") {
        const filter = (previous) => (argv) => previous
            .parse(argv)
            .flatMap(([argv, set]) => predicate(set.value)
            ? Result.of([
                argv,
                Flag.Set.of(set.value, (argv) => filter(set)(argv)),
            ])
            : Err.of(ifError()));
        const parse = (argv, matches) => this._parse(argv, matches).flatMap(([argv, set]) => predicate(set.value)
            ? Result.of([
                argv,
                Flag.Set.of(set.value, (argv) => filter(set)(argv)),
            ])
            : Err.of(ifError()));
        return new Flag(this._name, this._description, this._options, parse);
    }
    type(type) {
        return new Flag(this._name, this._description, {
            ...this._options,
            type: Option.of(type),
        }, this._parse);
    }
    alias(alias) {
        return new Flag(this._name, this._description, {
            ...this._options,
            aliases: [...this._options.aliases, alias],
        }, this._parse);
    }
    default(value, label = `${value}`) {
        label = label.replace(/\s+/g, " ").trim();
        const options = {
            ...this._options,
            optional: true,
            default: label === "" ? None : Option.of(label),
        };
        const missing = (previous) => (argv, matches) => {
            const [name] = argv;
            if (name === undefined || !matches(name)) {
                return Result.of([
                    argv,
                    Flag.Set.of(previous.value, (argv) => missing(previous)(argv, matches)),
                ]);
            }
            return previous
                .parse(argv)
                .map(([argv, set]) => [
                argv,
                Flag.Set.of(set.value, (argv) => missing(set)(argv, matches)),
            ]);
        };
        const parse = (argv, matches) => {
            const [name] = argv;
            if (name === undefined || !matches(name)) {
                return Result.of([
                    argv,
                    Flag.Set.of(value, (argv) => parse(argv, matches)),
                ]);
            }
            return this._parse(argv, matches).map(([argv, set]) => [
                argv,
                Flag.Set.of(set.value, (argv) => missing(set)(argv, matches)),
            ]);
        };
        return new Flag(this._name, this._description, options, parse);
    }
    optional() {
        const options = { ...this._options, optional: true };
        const missing = (previous) => (argv, matches) => {
            const [name] = argv;
            if (name === undefined || !matches(name)) {
                return Result.of([
                    argv,
                    Flag.Set.of(previous.value, (argv) => missing(previous)(argv, matches)),
                ]);
            }
            return previous
                .parse(argv)
                .map(([argv, set]) => [
                argv,
                Flag.Set.of(set.value, (argv) => missing(set)(argv, matches)),
            ]);
        };
        const parse = (argv, matches) => {
            const [name] = argv;
            if (name === undefined || !matches(name)) {
                return Result.of([
                    argv,
                    Flag.Set.of(Option.empty(), (argv) => parse(argv, matches)),
                ]);
            }
            return this._parse(argv, matches).map(([argv, set]) => [
                argv,
                Flag.Set.of(Option.of(set.value), (argv) => missing(set.map(Option.of))(argv, matches)),
            ]);
        };
        return new Flag(this._name, this._description, options, parse);
    }
    repeatable() {
        const options = { ...this._options, repeatable: true };
        const repeat = (previous) => (argv) => previous
            .parse(argv)
            .map(([argv, set]) => [
            argv,
            Flag.Set.of([...previous.value, ...set.value], (argv) => repeat(set)(argv)),
        ]);
        const parse = (argv, matches) => this._parse(argv, matches).map(([argv, set]) => [
            argv,
            Flag.Set.of([set.value], (argv) => repeat(set.map((value) => [value]))(argv)),
        ]);
        return new Flag(this._name, this._description, options, parse);
    }
    negatable(mapper) {
        const options = { ...this._options, negatable: true };
        const negate = (previous) => (argv, matches) => {
            const [name] = argv;
            const isNegated = name !== undefined && name.startsWith("--no-");
            if (isNegated) {
                argv = [name.replace("--no-", "--"), ...argv.slice(1)];
            }
            return previous
                .parse(argv)
                .map(([argv, set]) => [
                argv,
                Flag.Set.of(isNegated ? mapper(set.value) : set.value, (argv) => negate(set)(argv, matches)),
            ]);
        };
        const parse = (argv, matches) => {
            const [name] = argv;
            const isNegated = name !== undefined && name.startsWith("--no-");
            if (isNegated) {
                argv = [name.replace("--no-", "--"), ...argv.slice(1)];
            }
            return this._parse(argv, matches).map(([argv, set]) => [
                argv,
                Flag.Set.of(isNegated ? mapper(set.value) : set.value, (argv) => negate(set)(argv, matches)),
            ]);
        };
        return new Flag(this._name, this._description, options, parse);
    }
    choices(...choices) {
        return this.filter(Refinement.equals(...choices), () => `Incorrect value, expected one of ${choices
            .map((choice) => `"${choice}"`)
            .join(", ")}`).type(choices.join("|"));
    }
    toJSON() {
        return {
            name: this._name,
            description: this._description,
            options: {
                ...this._options,
                type: this._options.type.getOr(null),
                default: this._options.default.map(Serializable.toJSON).getOr(null),
            },
        };
    }
}
/**
 * @public
 */
(function (Flag) {
    /**
     * The `Set<T>` class, from the concept of "flag sets", acts as a container
     * for parsed flag values. As flags can be specified multiple times, this
     * class allows us to encapsulate the current value of a given flag and a
     * parser to parse another instance of the flag value and determine how to
     * combine the two.
     */
    class Set {
        static of(value, parse) {
            return new Set(value, parse);
        }
        _value;
        _parse;
        constructor(value, parse) {
            this._value = value;
            this._parse = parse;
        }
        get value() {
            return this._value;
        }
        get parse() {
            return this._parse;
        }
        map(mapper) {
            return new Set(mapper(this._value), (argv) => this._parse(argv).map(([argv, set]) => [argv, set.map(mapper)]));
        }
    }
    Flag.Set = Set;
    function string(name, description) {
        const parse = (argv, matches) => {
            const [name, value] = argv;
            if (name === undefined || !matches(name)) {
                return Err.of("Missing flag");
            }
            if (value === undefined) {
                return Err.of("Missing value");
            }
            return Result.of([
                argv.slice(2),
                Flag.Set.of(value, (argv) => parse(argv, matches)),
            ]);
        };
        return Flag.of(name, description, parse).type("string");
    }
    Flag.string = string;
    function number(name, description) {
        const parse = (argv, matches) => {
            const [name, value] = argv;
            if (name === undefined || !matches(name)) {
                return Err.of("Missing flag");
            }
            if (value === undefined) {
                return Err.of("Missing value");
            }
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return Err.of(`${value} is not a number`);
            }
            return Result.of([
                argv.slice(2),
                Flag.Set.of(number, (argv) => parse(argv, matches)),
            ]);
        };
        return Flag.of(name, description, parse).type("number");
    }
    Flag.number = number;
    function integer(name, description) {
        const parse = (argv, matches) => {
            const [name, value] = argv;
            if (name === undefined || !matches(name)) {
                return Err.of("Missing flag");
            }
            if (value === undefined) {
                return Err.of("Missing value");
            }
            const number = Number(value);
            if (!Number.isInteger(number)) {
                return Err.of(`${value} is not an integer`);
            }
            return Result.of([
                argv.slice(2),
                Flag.Set.of(number, (argv) => parse(argv, matches)),
            ]);
        };
        return Flag.of(name, description, parse).type("integer");
    }
    Flag.integer = integer;
    function boolean(name, description) {
        const parse = (argv, matches) => {
            const [name, value] = argv;
            if (name === undefined || !matches(name)) {
                return Err.of("Missing flag");
            }
            if (value === undefined || (value !== "true" && value !== "false")) {
                return Result.of([
                    argv.slice(1),
                    Flag.Set.of(true, (argv) => parse(argv, matches)),
                ]);
            }
            return Result.of([
                argv.slice(2),
                Flag.Set.of(value === "true", (argv) => parse(argv, matches)),
            ]);
        };
        return Flag.of(name, description, parse)
            .type("boolean")
            .negatable((value) => !value);
    }
    Flag.boolean = boolean;
    function empty(name, description) {
        const parse = (argv, matches) => {
            const [name] = argv;
            if (name === undefined || !matches(name)) {
                return Err.of("Missing flag");
            }
            return Result.of([
                argv.slice(1),
                Flag.Set.of(undefined, (argv) => parse(argv, matches)),
            ]);
        };
        return Flag.of(name, description, parse);
    }
    Flag.empty = empty;
    Flag.Help = Symbol("--help");
    function help(description) {
        return empty("help", description)
            .map(() => Flag.Help)
            .optional();
    }
    Flag.help = help;
    Flag.Version = Symbol("--version");
    function version(description) {
        return empty("version", description)
            .map(() => Flag.Version)
            .optional();
    }
    Flag.version = version;
})(Flag || (Flag = {}));
//# sourceMappingURL=flag.js.map