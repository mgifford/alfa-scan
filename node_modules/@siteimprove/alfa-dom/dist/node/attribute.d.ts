import { Option } from "@siteimprove/alfa-option";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import { Namespace } from "../namespace.js";
import { Node } from "../node.js";
import type { Element } from "./element.js";
import * as predicate from "./attribute/predicate.js";
import * as autocomplete from "./attribute/autocomplete.js";
/**
 * @public
 */
export declare class Attribute<N extends string = string> extends Node<"attribute"> {
    static of<N extends string = string>(namespace: Option<Namespace>, prefix: Option<string>, name: N, value: string, externalId?: string, internalId?: string, extraData?: any): Attribute<N>;
    private readonly _namespace;
    private readonly _prefix;
    private readonly _name;
    private readonly _value;
    private _owner;
    protected constructor(namespace: Option<Namespace>, prefix: Option<string>, name: N, value: string, externalId?: string, internalId?: string, extraData?: any);
    get namespace(): Option<Namespace>;
    get prefix(): Option<string>;
    get name(): N | Lowercase<N>;
    get qualifiedName(): string;
    get value(): string;
    get owner(): Option<Element>;
    /**
     * {@link https://html.spec.whatwg.org/#boolean-attribute}
     */
    isBoolean(): boolean;
    /**
     * @internal
     **/
    protected _internalPath(options?: Node.Traversal): string;
    /**
     * {@link https://html.spec.whatwg.org/#space-separated-tokens}
     */
    tokens(separator?: string | RegExp): Sequence<string>;
    /**
     * {@link https://html.spec.whatwg.org/#enumerated-attribute}
     */
    enumerate(): Option<string>;
    /**
     * {@link https://html.spec.whatwg.org/#enumerated-attribute}
     */
    enumerate<T extends string>(valid: T, ...rest: Array<T>): Option<T>;
    toJSON(options: Node.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal | json.Serializable.Verbosity.Low;
    }): Attribute.MinimalJSON;
    toJSON(options?: Node.SerializationOptions): Attribute.JSON<N>;
    toString(): string;
    /**
     * @internal
     */
    _attachParent(): boolean;
    /**
     * @internal
     */
    _attachOwner(owner: Element): boolean;
}
/**
 * @public
 */
export declare namespace Attribute {
    interface MinimalJSON extends Node.JSON<"attribute"> {
    }
    interface JSON<N extends string = string> extends Node.JSON<"attribute"> {
        namespace: string | null;
        prefix: string | null;
        name: N;
        value: string;
    }
    function isAttribute(value: unknown): value is Attribute;
    /**
     * @internal
     */
    function fromAttribute<N extends string = string>(attribute: JSON<N>): Trampoline<Attribute<N>>;
    /**
     * @internal
     */
    function cloneAttribute<N extends string = string>(attribute: Attribute<N>): Trampoline<Attribute<N | Lowercase<N>>>;
    /**
     * Conditionally fold the case of an attribute name based on its owner; HTML
     * attributes are case insensitive while attributes in other namespaces aren't.
     *
     * @internal
     */
    function foldCase<N extends string = string>(name: N, owner: Option<Element>): N | Lowercase<N>;
    const hasName: typeof predicate.hasName;
    export import Autocomplete = autocomplete.Autocomplete;
}
//# sourceMappingURL=attribute.d.ts.map