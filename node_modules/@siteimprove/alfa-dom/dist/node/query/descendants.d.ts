import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Node } from "../../node.js";
import { Element } from "../element.js";
import { Text } from "../text.js";
/**
 * Get all descendants of a node that satisfy a given refinement.
 *
 * @remarks
 * In order to properly cache results for improved performance, care must be taken
 * to use the exact same refinement (JS object) and not merely a clone of it.
 *
 * @public
 */
export declare function getDescendants<T extends Node>(refinement: Refinement<Node, T>): (node: Node, options?: Node.Traversal) => Sequence<T>;
/**
 * Get all descendants of a node that satisfy a given predicate.
 *
 * @remarks
 * In order to properly cache results for improved performance, care must be taken
 * to use the exact same predicate (JS object) and not merely a clone of it.
 *
 * @public
 */
export declare function getDescendants(predicate: Predicate<Node>): (node: Node, options?: Node.Traversal) => Sequence<Node>;
/**
 * @public
 */
export declare const getElementDescendants: (node: Node, options?: Node.Traversal) => Sequence<Element<string>>;
/**
 * @public
 */
export declare function getInclusiveElementDescendants(node: Element, options?: Node.Traversal): Sequence<Element>;
/**
 * A group of text nodes with an associated label.
 *
 * @public
 */
export interface TextGroup {
    label: string;
    text: Sequence<Text>;
}
/**
 * Options for grouping text descendants.
 *
 * @public
 */
export interface TextGroupOptions<N extends Node = Node> {
    startsGroup: Refinement<Node, N>;
    getLabel: (node: N) => string;
}
/**
 * Get all text descendants of a node, optionally grouping some into labeled groups.
 *
 * @remarks
 * When a descendant matches `startsGroup`, all of its text descendants are collected
 * into a {@link TextGroup} with a label from `getLabel`. Text nodes outside such
 * sub-trees are returned as plain {@link Text} nodes.
 *
 * Groups are not nested: if a `startsGroup` node contains another `startsGroup` node,
 * the inner node's text is included in the outer group, not as a separate group.
 *
 * @public
 */
export declare function getTextDescendants<N extends Node = Node>(textOptions?: TextGroupOptions<N>): (node: Node, options?: Node.Traversal) => Sequence<Text | TextGroup>;
//# sourceMappingURL=descendants.d.ts.map