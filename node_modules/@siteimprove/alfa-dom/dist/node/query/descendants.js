import { Cache } from "@siteimprove/alfa-cache";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Node } from "../../node.js";
import { Element } from "../element.js";
import { Text } from "../text.js";
const _descendantsCache = Cache.empty();
export function getDescendants(predicate) {
    return (node, options = Node.Traversal.empty) => {
        const optionsMap = _descendantsCache
            .get(predicate, Cache.empty)
            .get(node, () => []);
        if (optionsMap[options.value] === undefined) {
            optionsMap[options.value] = node.descendants(options).filter(predicate);
        }
        return optionsMap[options.value];
    };
}
/**
 * @public
 */
export const getElementDescendants = getDescendants(Element.isElement);
/**
 * @public
 */
export function getInclusiveElementDescendants(node, options = Node.Traversal.empty) {
    return getElementDescendants(node, options).prepend(node);
}
const _textCache = Cache.empty();
const defaultTextOptions = {
    startsGroup: (node) => false,
    getLabel: () => "",
};
/**
 * Get all text descendants of a node, optionally grouping some into labeled groups.
 *
 * @remarks
 * When a descendant matches `startsGroup`, all of its text descendants are collected
 * into a {@link TextGroup} with a label from `getLabel`. Text nodes outside such
 * sub-trees are returned as plain {@link Text} nodes.
 *
 * Groups are not nested: if a `startsGroup` node contains another `startsGroup` node,
 * the inner node's text is included in the outer group, not as a separate group.
 *
 * @public
 */
export function getTextDescendants(textOptions = defaultTextOptions) {
    return (node, options = Node.Traversal.empty) => {
        const optionsMap = _textCache
            .get(textOptions, Cache.empty)
            .get(node, () => []);
        if (optionsMap[options.value] === undefined) {
            optionsMap[options.value] = Sequence.from(_getTextDescendants(node, textOptions, options));
        }
        return optionsMap[options.value];
    };
}
function* _getTextDescendants(node, textOptions, traversalOptions) {
    const { startsGroup, getLabel } = textOptions;
    for (const child of node.children(traversalOptions)) {
        if (startsGroup(child)) {
            const groupText = getDescendants(Text.isText)(child, traversalOptions);
            yield {
                label: getLabel(child),
                text: groupText,
            };
        }
        else if (Text.isText(child)) {
            yield child;
        }
        else {
            yield* _getTextDescendants(child, textOptions, traversalOptions);
        }
    }
}
//# sourceMappingURL=descendants.js.map