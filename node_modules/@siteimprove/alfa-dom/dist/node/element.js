import { Cache } from "@siteimprove/alfa-cache";
import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option, Some } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Rectangle } from "@siteimprove/alfa-rectangle";
import { Sequence } from "@siteimprove/alfa-sequence";
import { String } from "@siteimprove/alfa-string";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import { Node } from "../node.js";
import { Block } from "../style/block.js";
import { Declaration } from "../style/declaration.js";
import { Attribute } from "./attribute.js";
import { Document } from "./document.js";
import { Shadow } from "./shadow.js";
import { Slot } from "./slot.js";
import { Slotable } from "./slotable.js";
import * as predicate from "./element/predicate.js";
const { isEmpty } = Iterable;
const { and, not, or, test } = Predicate;
/**
 * @public
 */
export class Element extends Node {
    static of(namespace, prefix, name, attributes = [], children = [], style = None, box = None, device = None, externalId, internalId, extraData) {
        return new Element(namespace, prefix, name, Array.from(attributes), Array.from(children), style, box, device, externalId, internalId, extraData);
    }
    _namespace;
    _prefix;
    _name;
    _attributes;
    _style;
    _shadow = None;
    _content = None;
    _id;
    _classes;
    _boxes;
    constructor(namespace, prefix, name, attributes, children, style, box, device, externalId, internalId, extraData) {
        super(children, "element", externalId, internalId, extraData);
        this._namespace = namespace;
        this._prefix = prefix;
        this._name = name;
        this._attributes = new Map(attributes
            .filter((attribute) => attribute._attachOwner(this))
            .map((attribute) => [attribute.qualifiedName, attribute]));
        style.forEach((block) => Iterable.forEach(block, (declaration) => declaration._attachOwner(this)));
        this._style = style;
        this._id = this.attribute("id").map((attr) => attr.value);
        this._classes = this.attribute("class")
            .map((attr) => attr.value.trim().split(/\s+/))
            .getOr([]);
        this._boxes = Cache.from(device.isSome() && box.isSome() ? [[device.get(), box.get()]] : []);
    }
    get namespace() {
        return this._namespace;
    }
    get prefix() {
        return this._prefix;
    }
    get name() {
        return this._name;
    }
    get qualifiedName() {
        return this._prefix.reduce((name, prefix) => `${prefix}:${name}`, this._name);
    }
    get attributes() {
        return Sequence.from(this._attributes.values());
    }
    get style() {
        return this._style;
    }
    get shadow() {
        return this._shadow;
    }
    get content() {
        return this._content;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-id}
     */
    get id() {
        return this._id;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-class}
     */
    get classes() {
        return Sequence.from(this._classes);
    }
    getBoundingBox(device) {
        return this._boxes.get(device);
    }
    children(options = Node.Traversal.empty) {
        const treeChildren = this._children;
        const children = [];
        if (options.isSet(Node.Traversal.flattened)) {
            if (this._shadow.isSome()) {
                return this._shadow.get().children(options);
            }
            if (Slot.isSlot(this)) {
                return Sequence.from(this.assignedNodes());
            }
            for (const child of treeChildren) {
                if (Slot.isSlot(child)) {
                    children.push(...child.children(options));
                }
                else {
                    children.push(child);
                }
            }
        }
        else {
            if (options.isSet(Node.Traversal.composed) && this._shadow.isSome()) {
                children.push(this._shadow.get());
            }
            children.push(...treeChildren);
        }
        if (options.isSet(Node.Traversal.nested) && this._content.isSome()) {
            children.push(this._content.get());
        }
        return Sequence.from(children);
    }
    attribute(nameOrPredicate) {
        if (typeof nameOrPredicate === "string") {
            return Option.from(this._attributes.get(nameOrPredicate));
        }
        else {
            return Iterable.find(this._attributes.values(), nameOrPredicate);
        }
    }
    /**
     * {@link https://html.spec.whatwg.org/#void-elements}
     */
    isVoid() {
        switch (this._name) {
            case "area":
            case "base":
            case "basefont":
            case "bgsound":
            case "br":
            case "col":
            case "embed":
            case "frame":
            case "hr":
            case "img":
            case "input":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
                return true;
            default:
                return false;
        }
    }
    /**
     * {@link https://html.spec.whatwg.org/#dom-tabindex}
     */
    tabIndex() {
        for (const tabIndex of this.attribute("tabindex")) {
            const number = parseInt(tabIndex.value, 10);
            //Checking if tabindex isn't NaN, undefined, null, Infinity
            if (number === number && number === (number | 0)) {
                return Some.of(number);
            }
        }
        if (Element.isSuggestedFocusable(this)) {
            return Some.of(0);
        }
        return None;
    }
    /**
     * Computes inertness of an element based on the `inert` attribute.
     *
     * {@link https://html.spec.whatwg.org/#the-inert-attribute}
     *
     * @privateRemarks
     * According to {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/inert}
     * only open dialogs can escape inertness (except when they have the `inert` attribute).
     */
    isInert() {
        if (this._isInert === undefined) {
            this._isInert = test(or(
            // Explicitly inert;
            Element.hasAttribute("inert"), and(
            // or not an open dialog,
            not(and(Element.hasName("dialog"), Element.hasAttribute("open"))), 
            // and with an inert ancestor.
            (element) => element
                .parent(Node.flatTree)
                .filter(Element.isElement)
                .some((parent) => parent.isInert()))), this);
        }
        return this._isInert;
    }
    /*
     * This collects caches for methods that are specific to some kind of elements.
     * The actual methods are declared in element/augment.ts to de-clutter this
     * class. However, we need to declare the variables here as they would
     * otherwise be public which exposes too much. And they must be `protected`
     * to be accessible by the augments.
     */
    _inputType;
    _displaySize;
    _optionsList;
    _isInert;
    /*
     * End of caches for methods specific to some kind of elements.
     */
    /**
     * {@link https://dom.spec.whatwg.org/#dom-slotable-assignedslot}
     */
    assignedSlot() {
        return Slotable.findSlot(this);
    }
    /**
     * {@link https://html.spec.whatwg.org/#dom-slot-assignednodes}
     */
    assignedNodes() {
        return Slot.findSlotables(this);
    }
    /**
     * @internal
     **/
    _internalPath(options) {
        let path = this.parent(options)
            .map((parent) => parent.path(options))
            .getOr("/");
        path += path === "/" ? "" : "/";
        path += this._name;
        const index = this.index(options, (node) => Element.isElement(node) && node._name === this._name);
        path += `[${index + 1}]`;
        return path;
    }
    toJSON(options) {
        const verbosity = options?.verbosity ?? json.Serializable.Verbosity.Medium;
        const result = super.toJSON(options);
        if (verbosity < json.Serializable.Verbosity.Medium) {
            return result;
        }
        if (verbosity >= json.Serializable.Verbosity.High) {
            result.assignedSlot = this.assignedSlot()
                .map((slot) => slot.toJSON({ verbosity: json.Serializable.Verbosity.Minimal }))
                .getOr(null);
        }
        return {
            ...result,
            namespace: this._namespace.getOr(null),
            prefix: this._prefix.getOr(null),
            name: this._name,
            attributes: [...this._attributes.values()].map((attribute) => attribute.toJSON(options)),
            style: this._style.map((style) => style.toJSON()).getOr(null),
            shadow: this._shadow.map((shadow) => shadow.toJSON(options)).getOr(null),
            content: this._content
                .map((content) => content.toJSON(options))
                .getOr(null),
            box: options?.device === undefined
                ? null
                : this._boxes
                    .get(options.device)
                    .map((box) => box.toJSON())
                    .getOr(null),
        };
    }
    toString() {
        const name = this.qualifiedName;
        const attributes = [...this._attributes.values()]
            .map((attribute) => ` ${attribute.toString()}`)
            .join("");
        if (this.isVoid()) {
            return `<${name}${attributes}>`;
        }
        const children = [...this._shadow, ...this._children, ...this._content]
            .map((child) => {
            const value = child.toString();
            // If the child is only spaces, we do not want to trim them to nothingness.
            if (value.match(/\s+/) !== null) {
                return value;
            }
            return value.trim();
        })
            .filter(not(isEmpty))
            .map(String.indent)
            .join("\n");
        return `<${name}${attributes}>${children === "" ? "" : `\n${children}\n`}</${name}>`;
    }
    /**
     * @internal
     */
    _attachShadow(shadow) {
        if (this._frozen || this._shadow.isSome() || !shadow._attachHost(this)) {
            return false;
        }
        this._shadow = Option.of(shadow);
        return true;
    }
    /**
     * @internal
     */
    _attachContent(document) {
        if (this._frozen ||
            this._content.isSome() ||
            !document._attachFrame(this)) {
            return false;
        }
        this._content = Option.of(document);
        return true;
    }
}
/**
 * @public
 */
(function (Element) {
    function isElement(value) {
        return value instanceof Element;
    }
    Element.isElement = isElement;
    /**
     * @internal
     */
    function fromElement(json, device) {
        return Trampoline.traverse(json.children ?? [], (child) => Node.fromNode(child, device)).map((children) => {
            const element = Element.of(Option.from(json.namespace), Option.from(json.prefix), json.name, json.attributes.map((attribute) => Attribute.fromAttribute(attribute).run()), children, json.style?.length === 0
                ? None
                : Option.from(json.style).map(Block.from), Option.from(json.box).map(Rectangle.from), Option.from(device), json.externalId, json.internalId);
            if (json.shadow !== null) {
                element._attachShadow(Shadow.fromShadow(json.shadow, device).run());
            }
            if (json.content !== null) {
                element._attachContent(Document.fromDocument(json.content, device).run());
            }
            return element;
        });
    }
    Element.fromElement = fromElement;
    /**
     * @internal
     */
    function cloneElement(options, device) {
        return (element) => Trampoline.traverse(element.children(), (child) => {
            if (Element.isElement(child) && options.predicate(child)) {
                return Trampoline.done(Array.from(options.newElements));
            }
            return Node.cloneNode(child, options, device).map((node) => [node]);
        }).map((children) => {
            const deviceOption = Option.from(device);
            const clonedElement = Element.of(element.namespace, element.prefix, element.name, element.attributes.map((attribute) => Attribute.clone(attribute, options, device)), Iterable.flatten(children), element.style.map((block) => {
                return Block.of(Iterable.map(block.declarations, (declaration) => Declaration.of(declaration.name, declaration.value, declaration.important)));
            }), deviceOption.flatMap((d) => element.getBoundingBox(d)), deviceOption, element.externalId, element.internalId, element.extraData);
            if (element.shadow.isSome()) {
                clonedElement._attachShadow(Shadow.clone(element.shadow.get(), options, device));
            }
            if (element.content.isSome()) {
                clonedElement._attachContent(Document.clone(element.content.get(), options, device));
            }
            return clonedElement;
        });
    }
    Element.cloneElement = cloneElement;
    Element.hasAttribute = predicate.hasAttribute, Element.hasDisplaySize = predicate.hasDisplaySize, Element.hasId = predicate.hasId, Element.hasInputType = predicate.hasInputType, Element.hasName = predicate.hasName, Element.hasNamespace = predicate.hasNamespace, Element.hasTabIndex = predicate.hasTabIndex, Element.hasUniqueId = predicate.hasUniqueId, Element.isBrowsingContextContainer = predicate.isBrowsingContextContainer, Element.isContent = predicate.isContent, Element.isActuallyDisabled = predicate.isActuallyDisabled, Element.isDocumentElement = predicate.isDocumentElement, Element.isDraggable = predicate.isDraggable, Element.isEditingHost = predicate.isEditingHost, Element.isFallback = predicate.isFallback, Element.isScopedTo = predicate.isScopedTo, Element.isSuggestedFocusable = predicate.isSuggestedFocusable, Element.isReplaced = predicate.isReplaced;
})(Element || (Element = {}));
//# sourceMappingURL=element.js.map