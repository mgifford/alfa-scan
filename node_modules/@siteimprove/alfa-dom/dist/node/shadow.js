import { None, Option } from "@siteimprove/alfa-option";
import { String } from "@siteimprove/alfa-string";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import { Iterable } from "@siteimprove/alfa-iterable";
import * as json from "@siteimprove/alfa-json";
import { Node } from "../node.js";
import { Sheet } from "../style/sheet.js";
import { Element } from "./element.js";
/**
 * @public
 */
export class Shadow extends Node {
    static of(children, style = [], mode = Shadow.Mode.Open, externalId, internalId, extraData) {
        return new Shadow(Array.from(children), Array.from(style), mode, externalId, internalId, extraData);
    }
    static empty() {
        return new Shadow([], [], Shadow.Mode.Open);
    }
    _mode;
    _host = None;
    _style;
    constructor(children, style, mode, externalId, internalId, extraData) {
        super(children, "shadow", externalId, internalId, extraData);
        this._mode = mode;
        this._style = style;
    }
    get mode() {
        return this._mode;
    }
    get host() {
        return this._host;
    }
    get style() {
        return this._style;
    }
    parent(options = Node.Traversal.empty) {
        // We only "land" on Shadow roots when traversing the composed tree.
        // Notably, flattening the tree "jumps" over them.
        if (options.isSet(Node.Traversal.composed)) {
            return this._host;
        }
        return None;
    }
    /**
     * @internal
     **/
    _internalPath(options = Node.Traversal.empty) {
        if (options.isSet(Node.Traversal.composed)) {
            return (this._host.map((host) => host.path(options)).getOr("") +
                "/shadow-root()");
        }
        if (options.isSet(Node.Traversal.flattened)) {
            return this._host.map((host) => host.path(options)).getOr("/");
        }
        return "/";
    }
    toJSON(options) {
        const result = {
            ...super.toJSON(options),
        };
        const verbosity = options?.verbosity ?? json.Serializable.Verbosity.Medium;
        if (verbosity < json.Serializable.Verbosity.Medium) {
            return result;
        }
        result.mode = this._mode;
        result.style = this._style.map((sheet) => sheet.toJSON());
        return result;
    }
    toString() {
        const children = this._children
            .map((child) => String.indent(child.toString()))
            .join("\n");
        return `#shadow-root (${this._mode})${children === "" ? "" : `\n${children}`}`;
    }
    /**
     * @internal
     */
    _attachParent() {
        return false;
    }
    /**
     * @internal
     */
    _attachHost(host) {
        if (this._frozen || this._host.isSome()) {
            return false;
        }
        this._host = Option.of(host);
        this._frozen = true;
        return true;
    }
}
/**
 * @public
 */
(function (Shadow) {
    let Mode;
    (function (Mode) {
        Mode["Open"] = "open";
        Mode["Closed"] = "closed";
    })(Mode = Shadow.Mode || (Shadow.Mode = {}));
    function isShadow(value) {
        return value instanceof Shadow;
    }
    Shadow.isShadow = isShadow;
    /**
     * @internal
     */
    function fromShadow(json, device) {
        return Trampoline.traverse(json.children ?? [], (child) => Node.fromNode(child, device)).map((children) => Shadow.of(children, json.style.map(Sheet.from), json.mode, json.externalId, json.internalId));
    }
    Shadow.fromShadow = fromShadow;
    /**
     * @internal
     */
    function cloneShadow(options, device) {
        return (shadow) => Trampoline.traverse(shadow.children(), (child) => {
            if (Element.isElement(child) && options.predicate(child)) {
                return Trampoline.done(Array.from(options.newElements));
            }
            return Node.cloneNode(child, options, device).map((node) => [node]);
        }).map((children) => {
            return Shadow.of(Iterable.flatten(children), shadow.style, shadow.mode, shadow.externalId, shadow.extraData, shadow.internalId);
        });
    }
    Shadow.cloneShadow = cloneShadow;
})(Shadow || (Shadow = {}));
//# sourceMappingURL=shadow.js.map