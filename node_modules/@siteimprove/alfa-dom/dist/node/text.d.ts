import type { Device } from "@siteimprove/alfa-device";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Rectangle } from "@siteimprove/alfa-rectangle";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import { Node } from "../node.js";
import type { Slot } from "./slot.js";
import { Slotable } from "./slotable.js";
/**
 * @public
 */
export declare class Text extends Node<"text"> implements Slotable {
    static of(data: string, box?: Option<Rectangle>, device?: Option<Device>, externalId?: string, internalId?: string, extraData?: any): Text;
    static empty(): Text;
    private readonly _data;
    private readonly _boxes;
    protected constructor(data: string, box: Option<Rectangle>, device: Option<Device>, externalId?: string, internalId?: string, extraData?: any);
    get data(): string;
    assignedSlot(): Option<Slot>;
    getBoundingBox(device: Device): Option<Rectangle>;
    is(predicate: Predicate<string>): boolean;
    /**
     * @internal
     **/
    protected _internalPath(options?: Node.Traversal): string;
    toJSON(options: Node.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal | json.Serializable.Verbosity.Low;
    }): Text.MinimalJSON;
    toJSON(options?: Node.SerializationOptions): Text.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Text {
    interface MinimalJSON extends Node.JSON<"text"> {
    }
    interface JSON extends Node.JSON<"text"> {
        data: string;
        box: Rectangle.JSON | null;
    }
    function isText(value: unknown): value is Text;
    function is(predicate: Predicate<string>): Predicate<Text>;
    /**
     * @internal
     */
    function fromText(json: JSON, device?: Device): Trampoline<Text>;
    /**
     * @internal
     */
    function cloneText(device?: Device): (text: Text) => Trampoline<Text>;
}
//# sourceMappingURL=text.d.ts.map