import { Cache } from "@siteimprove/alfa-cache";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Rectangle } from "@siteimprove/alfa-rectangle";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import { Node } from "../node.js";
import { Slotable } from "./slotable.js";
/**
 * @public
 */
export class Text extends Node {
    static of(data, box = None, device = None, externalId, internalId, extraData) {
        return new Text(data, box, device, externalId, internalId, extraData);
    }
    static empty() {
        return new Text("", None, None);
    }
    _data;
    _boxes;
    constructor(data, box, device, externalId, internalId, extraData) {
        super([], "text", externalId, internalId, extraData);
        this._data = data;
        this._boxes = Cache.from(device.isSome() && box.isSome() ? [[device.get(), box.get()]] : []);
    }
    get data() {
        return this._data;
    }
    assignedSlot() {
        return Slotable.findSlot(this);
    }
    getBoundingBox(device) {
        return this._boxes.get(device);
    }
    is(predicate) {
        return predicate(this._data);
    }
    /**
     * @internal
     **/
    _internalPath(options) {
        let path = this.parent(options)
            .map((parent) => parent.path(options))
            .getOr("/");
        path += path === "/" ? "" : "/";
        path += "text()";
        const index = this.index(options, Text.isText);
        path += `[${index + 1}]`;
        return path;
    }
    toJSON(options) {
        const result = {
            ...super.toJSON(options),
        };
        delete result.children;
        const verbosity = options?.verbosity ?? json.Serializable.Verbosity.Medium;
        if (verbosity < json.Serializable.Verbosity.Medium) {
            return result;
        }
        result.data = this.data;
        result.box =
            options?.device === undefined
                ? null
                : this._boxes
                    .get(options.device)
                    .map((box) => box.toJSON())
                    .getOr(null);
        return result;
    }
    toString() {
        const value = this.data;
        // If the child is only spaces, we do not want to trim them to nothingness.
        if (value.match(/\s+/) !== null) {
            return value;
        }
        return value.trim();
    }
}
/**
 * @public
 */
(function (Text) {
    function isText(value) {
        return value instanceof Text;
    }
    Text.isText = isText;
    function is(predicate) {
        return (text) => text.is(predicate);
    }
    Text.is = is;
    /**
     * @internal
     */
    function fromText(json, device) {
        return Trampoline.done(Text.of(json.data, Option.from(json.box).map(Rectangle.from), Option.from(device), json.externalId, undefined, json.internalId));
    }
    Text.fromText = fromText;
    /**
     * @internal
     */
    function cloneText(device) {
        return (text) => Trampoline.done(Text.of(text.data, Option.from(device).flatMap((d) => text.getBoundingBox(d)), Option.from(device), text.externalId, text.extraData, text.internalId));
    }
    Text.cloneText = cloneText;
})(Text || (Text = {}));
//# sourceMappingURL=text.js.map