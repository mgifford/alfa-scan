import type { Device } from "@siteimprove/alfa-device";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Rectangle } from "@siteimprove/alfa-rectangle";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import type { Namespace } from "../namespace.js";
import { Node } from "../node.js";
import { Block } from "../style/block.js";
import { Attribute } from "./attribute.js";
import { Document } from "./document.js";
import { Shadow } from "./shadow.js";
import { Slot } from "./slot.js";
import { Slotable } from "./slotable.js";
import type * as helpers from "./element/input-type.js";
import * as predicate from "./element/predicate.js";
/**
 * @public
 */
export declare class Element<N extends string = string> extends Node<"element"> implements Slot, Slotable {
    static of<N extends string = string>(namespace: Option<Namespace>, prefix: Option<string>, name: N, attributes?: Iterable<Attribute>, children?: Iterable<Node>, style?: Option<Block>, box?: Option<Rectangle>, device?: Option<Device>, externalId?: string, internalId?: string, extraData?: any): Element<N>;
    private readonly _namespace;
    private readonly _prefix;
    private readonly _name;
    private readonly _attributes;
    private readonly _style;
    private _shadow;
    private _content;
    private readonly _id;
    private readonly _classes;
    private readonly _boxes;
    protected constructor(namespace: Option<Namespace>, prefix: Option<string>, name: N, attributes: Array<Attribute>, children: Array<Node>, style: Option<Block>, box: Option<Rectangle>, device: Option<Device>, externalId?: string, internalId?: string, extraData?: any);
    get namespace(): Option<Namespace>;
    get prefix(): Option<string>;
    get name(): N;
    get qualifiedName(): string;
    get attributes(): Sequence<Attribute>;
    get style(): Option<Block>;
    get shadow(): Option<Shadow>;
    get content(): Option<Document>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-id}
     */
    get id(): Option<string>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-class}
     */
    get classes(): Sequence<string>;
    getBoundingBox(device: Device): Option<Rectangle>;
    children(options?: Node.Traversal): Sequence<Node>;
    attribute<A extends string = string>(name: A): Option<Attribute<A>>;
    attribute<A extends string = string>(predicate: Predicate<Attribute<A>>): Option<Attribute<A>>;
    /**
     * {@link https://html.spec.whatwg.org/#void-elements}
     */
    isVoid(): boolean;
    /**
     * {@link https://html.spec.whatwg.org/#dom-tabindex}
     */
    tabIndex(): Option<number>;
    /**
     * Computes inertness of an element based on the `inert` attribute.
     *
     * {@link https://html.spec.whatwg.org/#the-inert-attribute}
     *
     * @privateRemarks
     * According to {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/inert}
     * only open dialogs can escape inertness (except when they have the `inert` attribute).
     */
    isInert(): boolean;
    protected _inputType: helpers.InputType | undefined;
    protected _displaySize: number | undefined;
    protected _optionsList: Sequence<Element<"option">> | undefined;
    private _isInert;
    /**
     * {@link https://dom.spec.whatwg.org/#dom-slotable-assignedslot}
     */
    assignedSlot(): Option<Slot>;
    /**
     * {@link https://html.spec.whatwg.org/#dom-slot-assignednodes}
     */
    assignedNodes(): Iterable<Slotable>;
    /**
     * @internal
     **/
    protected _internalPath(options?: Node.Traversal): string;
    toJSON(options: Node.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal | json.Serializable.Verbosity.Low;
    }): Element.MinimalJSON;
    toJSON(options: Node.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.High;
    }): Element.JSON & {
        assignedSlot: Element.MinimalJSON | null;
    };
    toJSON(options?: Node.SerializationOptions): Element.JSON<N>;
    toString(): string;
    /**
     * @internal
     */
    _attachShadow(shadow: Shadow): boolean;
    /**
     * @internal
     */
    _attachContent(document: Document): boolean;
}
/**
 * @public
 */
export declare namespace Element {
    interface MinimalJSON extends Node.JSON<"element"> {
    }
    interface JSON<N extends string = string> extends Node.JSON<"element"> {
        namespace: string | null;
        prefix: string | null;
        name: N;
        attributes: Array<Attribute.JSON>;
        style: Block.JSON | string | null;
        shadow: Shadow.JSON | null;
        content: Document.JSON | null;
        box: Rectangle.JSON | null;
    }
    function isElement(value: unknown): value is Element;
    /**
     * @internal
     */
    function fromElement<N extends string = string>(json: JSON<N>, device?: Device): Trampoline<Element<N>>;
    /**
     * @internal
     */
    function cloneElement(options: Node.ElementReplacementOptions, device?: Device): (element: Element) => Trampoline<Element>;
    const hasAttribute: typeof predicate.hasAttribute, hasDisplaySize: typeof predicate.hasDisplaySize, hasId: typeof predicate.hasId, hasInputType: typeof predicate.hasInputType, hasName: typeof predicate.hasName, hasNamespace: typeof predicate.hasNamespace, hasTabIndex: typeof predicate.hasTabIndex, hasUniqueId: Predicate<Element<string>>, isBrowsingContextContainer: typeof predicate.isBrowsingContextContainer, isContent: typeof predicate.isContent, isActuallyDisabled: typeof predicate.isActuallyDisabled, isDocumentElement: typeof predicate.isDocumentElement, isDraggable: typeof predicate.isDraggable, isEditingHost: typeof predicate.isEditingHost, isFallback: typeof predicate.isFallback, isScopedTo: typeof predicate.isScopedTo, isSuggestedFocusable: typeof predicate.isSuggestedFocusable, isReplaced: typeof predicate.isReplaced;
    type InputType = helpers.InputType;
}
//# sourceMappingURL=element.d.ts.map