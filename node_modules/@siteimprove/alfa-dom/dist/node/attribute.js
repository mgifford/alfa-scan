import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Sequence } from "@siteimprove/alfa-sequence";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import * as json from "@siteimprove/alfa-json";
import { Namespace } from "../namespace.js";
import { Node } from "../node.js";
import * as predicate from "./attribute/predicate.js";
import * as autocomplete from "./attribute/autocomplete.js";
const { isEmpty } = Iterable;
const { equals, not } = Predicate;
/**
 * @public
 */
export class Attribute extends Node {
    static of(namespace, prefix, name, value, externalId, internalId, extraData) {
        return new Attribute(namespace, prefix, name, value, externalId, internalId, extraData);
    }
    _namespace;
    _prefix;
    _name;
    _value;
    _owner = None;
    constructor(namespace, prefix, name, value, externalId, internalId, extraData) {
        super([], "attribute", externalId, internalId, extraData);
        this._namespace = namespace;
        this._prefix = prefix;
        this._name = name;
        this._value = value;
    }
    get namespace() {
        return this._namespace;
    }
    get prefix() {
        return this._prefix;
    }
    get name() {
        return Attribute.foldCase(this._name, this._owner);
    }
    get qualifiedName() {
        return this._prefix.reduce((name, prefix) => `${prefix}:${name}`, this._name);
    }
    get value() {
        return this._value;
    }
    get owner() {
        return this._owner;
    }
    /**
     * {@link https://html.spec.whatwg.org/#boolean-attribute}
     */
    isBoolean() {
        switch (this.name) {
            case "allowfullscreen":
            case "allowpaymentrequest":
            case "async":
            case "autofocus":
            case "autoplay":
            case "checked":
            case "controls":
            case "default":
                return true;
            default:
                return false;
        }
    }
    /**
     * @internal
     **/
    _internalPath(options) {
        let path = this.owner.map((owner) => owner.path(options)).getOr("/");
        path += path === "/" ? "" : "/";
        path += `@${this.name}`;
        return path;
    }
    /**
     * {@link https://html.spec.whatwg.org/#space-separated-tokens}
     */
    tokens(separator = /\s+/) {
        return Sequence.from(this._value.trim().split(separator).filter(not(isEmpty)));
    }
    enumerate(...valid) {
        const value = this._value.toLowerCase();
        return valid.length === 0 || valid.includes(value)
            ? Option.of(value)
            : None;
    }
    toJSON(options) {
        const result = {
            ...super.toJSON(options),
        };
        delete result.children;
        const verbosity = options?.verbosity ?? json.Serializable.Verbosity.Medium;
        if (verbosity < json.Serializable.Verbosity.Medium) {
            return result;
        }
        result.namespace = this._namespace.getOr(null);
        result.prefix = this._prefix.getOr(null);
        result.name = this._name;
        result.value = this._value;
        return result;
    }
    toString() {
        const name = this.qualifiedName;
        if (this.isBoolean()) {
            return name;
        }
        return `${name}="${this._value.replace(/"/g, "&quot;")}"`;
    }
    /**
     * @internal
     */
    _attachParent() {
        return false;
    }
    /**
     * @internal
     */
    _attachOwner(owner) {
        if (this._frozen || this._owner.isSome()) {
            return false;
        }
        this._owner = Option.of(owner);
        this._frozen = true;
        return true;
    }
}
/**
 * @public
 */
(function (Attribute) {
    function isAttribute(value) {
        return value instanceof Attribute;
    }
    Attribute.isAttribute = isAttribute;
    /**
     * @internal
     */
    function fromAttribute(attribute) {
        return Trampoline.done(Attribute.of(Option.from(attribute.namespace), Option.from(attribute.prefix), attribute.name, attribute.value, attribute.externalId, attribute.internalId));
    }
    Attribute.fromAttribute = fromAttribute;
    /**
     * @internal
     */
    function cloneAttribute(attribute) {
        return Trampoline.done(Attribute.of(attribute.namespace, attribute.prefix, attribute.name, attribute.value, attribute.externalId, attribute.internalId, attribute.extraData));
    }
    Attribute.cloneAttribute = cloneAttribute;
    /**
     * Conditionally fold the case of an attribute name based on its owner; HTML
     * attributes are case insensitive while attributes in other namespaces aren't.
     *
     * @internal
     */
    function foldCase(name, owner) {
        return owner.some((owner) => owner.namespace.some(equals(Namespace.HTML)))
            ? name.toLowerCase()
            : name;
    }
    Attribute.foldCase = foldCase;
    Attribute.hasName = predicate.hasName;
    Attribute.Autocomplete = autocomplete.Autocomplete;
})(Attribute || (Attribute = {}));
//# sourceMappingURL=attribute.js.map