import { Declaration as CSSDeclaration, Lexer } from "@siteimprove/alfa-css";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Option } from "@siteimprove/alfa-option";
import { Declaration } from "./declaration.js";
/**
 * @public
 */
export class Block {
    static of(declarations) {
        return new Block(Array.from(declarations));
    }
    _declarations;
    constructor(declarations) {
        this._declarations = declarations;
    }
    get declarations() {
        return this._declarations;
    }
    get size() {
        return this._declarations.length;
    }
    isEmpty() {
        return this._declarations.length === 0;
    }
    declaration(predicate) {
        return Option.from(this._declarations.find(typeof predicate === "string"
            ? (declaration) => declaration.name === predicate
            : predicate));
    }
    equals(value) {
        return (value instanceof Block &&
            value._declarations.length === this._declarations.length &&
            value._declarations.every((declaration, i) => declaration.equals(this._declarations[i])));
    }
    *[Symbol.iterator]() {
        yield* this._declarations;
    }
    toJSON() {
        return this._declarations.map((declaration) => declaration.toJSON());
    }
    toString() {
        return this._declarations.join(";\n");
    }
}
/**
 * @public
 */
(function (Block) {
    function from(jsonOrText) {
        if (typeof jsonOrText === "string") {
            return Block.of(Iterable.map(CSSDeclaration.parseList(Lexer.lex(jsonOrText)).getUnsafe(`Could not parse CSS declarations "${jsonOrText}"`)[1], (declaration) => Declaration.from({
                name: declaration.name,
                value: declaration.value.join(""),
                important: declaration.important,
            })));
        }
        else {
            return Block.of(jsonOrText.map(Declaration.from));
        }
    }
    Block.from = from;
})(Block || (Block = {}));
//# sourceMappingURL=block.js.map