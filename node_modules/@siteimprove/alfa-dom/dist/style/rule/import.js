import { Lexer } from "@siteimprove/alfa-css";
import { Feature } from "@siteimprove/alfa-css-feature";
import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import { Rule } from "../rule.js";
import { Sheet } from "../sheet.js";
import { ConditionRule } from "./condition.js";
const { and } = Predicate;
/**
 * @public
 */
export class ImportRule extends ConditionRule {
    static of(href, sheet, mediaCondition = None, supportCondition = None, layer = None) {
        return new ImportRule(href, sheet, mediaCondition, supportCondition, layer);
    }
    _href;
    _sheet;
    _mediaQueries;
    _supportCondition;
    // There may be no support condition, or an unparsable (i.e. non-supported) one.
    // The former is None, the later is Some(None).
    _supportQuery;
    // Anonymous layers are represented with the empty string, matching the
    // CSSImportRule interface
    _layer;
    constructor(href, sheet, mediaCondition, supportCondition, layer) {
        super("import", mediaCondition.getOr("all"), []);
        this._href = href;
        this._sheet = sheet;
        this._supportCondition = supportCondition;
        this._layer = layer;
        this._mediaQueries = mediaCondition
            .flatMap((condition) => Feature.parseMediaQuery(Lexer.lex(condition)).ok())
            .map(([, queries]) => queries)
            .getOr(Feature.Media.List.of([]));
        this._supportQuery = supportCondition.map((condition) => Feature.parseSupportsQuery(
        // We're not sure where the condition comes from, but Alfa only parses
        // them when they are parenthesised, while CSSImportRule.supportsText
        // provides the raw text. Extra parenthesis don't block parsing.
        // In doubt, adding some to avoid potential problems.
        Lexer.lex(`(${condition})`))
            .ok()
            .map(([, query]) => query));
    }
    get supportCondition() {
        return this._supportCondition;
    }
    get mediaQueries() {
        return this._mediaQueries;
    }
    get supportQuery() {
        return this._supportQuery;
    }
    get layer() {
        return this._layer;
    }
    get rules() {
        return this._sheet.rules;
    }
    get href() {
        return this._href;
    }
    get sheet() {
        return this._sheet;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            href: this._href,
            // We match the CSSImportRule interface returning null when no support
            // text exist
            supportText: this._supportCondition.getOr(null),
            // We match the CSSImportRule interface returning null when no layer
            // is declared, and "" for an anonymous layer.
            layer: this._layer.getOr(null),
            rules: Iterable.toJSON(this.rules),
        };
    }
    toString() {
        return (`@import url(${this._href}) ` +
            `${this._layer.map((layer) => `layer${layer === "" ? "" : `(${layer}) `}`)}` +
            `${this._supportCondition.map((condition) => `supports(${condition}) `).getOr("")}` +
            `${this._condition}`);
    }
}
/**
 * @public
 */
(function (ImportRule) {
    function isImportRule(value) {
        return value instanceof ImportRule;
    }
    ImportRule.isImportRule = isImportRule;
    function matchesMedia(device) {
        return (rule) => rule.mediaQueries.matches(device);
    }
    function matchesSupport(device) {
        // If there is no support condition (None), it is matched.
        // If there is an unparsable one (Some(None)), it is not matched.
        return (rule) => rule.supportQuery.every((option) => option.some((query) => query.matches(device)));
    }
    function matches(device) {
        return and(matchesMedia(device), matchesSupport(device));
    }
    ImportRule.matches = matches;
    /**
     * @internal
     */
    function fromImportRule(json) {
        return Trampoline.traverse(json.rules, Rule.fromRule).map((rules) => ImportRule.of(json.href, Sheet.of(rules), Option.of(json.condition), Option.from(json.supportText), Option.from(json.layer)));
    }
    ImportRule.fromImportRule = fromImportRule;
})(ImportRule || (ImportRule = {}));
//# sourceMappingURL=import.js.map