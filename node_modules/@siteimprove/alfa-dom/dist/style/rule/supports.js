import { Lexer } from "@siteimprove/alfa-css";
import { Feature } from "@siteimprove/alfa-css-feature";
import { String } from "@siteimprove/alfa-string";
import { Trampoline } from "@siteimprove/alfa-trampoline";
import { Rule } from "../rule.js";
import { ConditionRule } from "./condition.js";
/**
 * @public
 */
export class SupportsRule extends ConditionRule {
    static of(condition, rules) {
        return new SupportsRule(condition, Array.from(rules));
    }
    _query;
    constructor(condition, rules) {
        super("supports", condition, rules);
        this._query = Feature.parseSupportsQuery(Lexer.lex(condition))
            .map(([, query]) => query)
            .ok();
    }
    get query() {
        return this._query;
    }
    toJSON() {
        return super.toJSON();
    }
    toString() {
        const rules = this._rules
            .map((rule) => String.indent(rule.toString()))
            .join("\n\n");
        return `@supports ${this._condition} {${rules === "" ? "" : `\n${rules}\n`}}`;
    }
}
/**
 * @public
 */
(function (SupportsRule) {
    function isSupportsRule(value) {
        return value instanceof SupportsRule;
    }
    SupportsRule.isSupportsRule = isSupportsRule;
    function matches(device) {
        // If rule.query is None, Alfa couldn't parse the query which
        // means it does not support it.
        return (rule) => rule.query.some((query) => query.matches(device));
    }
    SupportsRule.matches = matches;
    /**
     * @internal
     */
    function fromSupportsRule(json) {
        return Trampoline.traverse(json.rules, Rule.fromRule).map((rules) => SupportsRule.of(json.condition, rules));
    }
    SupportsRule.fromSupportsRule = fromSupportsRule;
})(SupportsRule || (SupportsRule = {}));
//# sourceMappingURL=supports.js.map