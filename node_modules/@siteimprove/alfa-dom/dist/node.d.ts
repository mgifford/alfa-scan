import type { Device } from "@siteimprove/alfa-device";
import { Flags } from "@siteimprove/alfa-flags";
import { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { Sequence } from "@siteimprove/alfa-sequence";
import type { Trampoline } from "@siteimprove/alfa-trampoline";
import type * as earl from "@siteimprove/alfa-earl";
import * as json from "@siteimprove/alfa-json";
import type * as sarif from "@siteimprove/alfa-sarif";
import * as tree from "@siteimprove/alfa-tree";
import { Attribute, Comment, Document, Element, Fragment, Shadow, Text, Type } from "./index.js";
import * as predicate from "./node/predicate.js";
import * as traversal from "./node/traversal.js";
/**
 * @public
 */
export declare abstract class Node<T extends string = string> extends tree.Node<"DOM traversal", Node.TraversalFlags, T> implements earl.Serializable<Node.EARL>, json.Serializable<tree.Node.JSON<T>>, sarif.Serializable<sarif.Location> {
    protected constructor(children: Array<Node>, type: T, externalId?: string, internalId?: string, extraData?: any);
    /**
     * {@link https://dom.spec.whatwg.org/#concept-descendant-text-content}
     */
    textContent(options?: Node.Traversal): string;
    /**
     * Construct a sequence of descendants of this node sorted by tab index. Only
     * nodes with a non-negative tab index are included in the sequence.
     *
     * {@link https://html.spec.whatwg.org/multipage/#tabindex-value}
     */
    tabOrder(): Sequence<Element>;
    private _path;
    /**
     * @internal
     */
    protected _internalPath(options?: Node.Traversal): string;
    /**
     * Get an XPath that uniquely identifies the node across descendants of its
     * root.
     */
    path(options?: Node.Traversal): string;
    equals(value: Node): boolean;
    equals(value: unknown): value is this;
    toJSON(options?: Serializable.Options): Node.JSON<T>;
    toEARL(): Node.EARL;
    toSARIF(): sarif.Location;
}
/**
 * @public
 */
export interface Node {
    parent(options?: Node.Traversal): Option<Node>;
    isParentOf(node: Node, options?: Node.Traversal): boolean;
    root(options?: Node.Traversal): Node;
    isRootOf(node: Node, options?: Node.Traversal): boolean;
    children(options?: Node.Traversal): Sequence<Node>;
    isChildOf(node: Node, options?: Node.Traversal): boolean;
    descendants(options?: Node.Traversal): Sequence<Node>;
    isDescendantOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveDescendants(options?: Node.Traversal): Sequence<Node>;
    isInclusiveDescendantsOf(node: Node, options?: Node.Traversal): boolean;
    ancestors(options?: Node.Traversal): Sequence<Node>;
    isAncestorOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveAncestors(options?: Node.Traversal): Sequence<Node>;
    isInclusiveAncestorOf(node: Node, options?: Node.Traversal): boolean;
    siblings(options?: Node.Traversal): Sequence<Node>;
    isSiblingOf(node: Node, options?: Node.Traversal): boolean;
    inclusiveSiblings(options?: Node.Traversal): Sequence<Node>;
    isInclusiveSiblingOf(node: Node, options?: Node.Traversal): boolean;
    preceding(options?: Node.Traversal): Sequence<Node>;
    following(options?: Node.Traversal): Sequence<Node>;
    first(options?: Node.Traversal): Option<Node>;
    last(options?: Node.Traversal): Option<Node>;
    previous(options?: Node.Traversal): Option<Node>;
    next(options?: Node.Traversal): Option<Node>;
    index(options?: Node.Traversal, predicate?: Predicate<Node>): number;
    closest<T extends Node>(refinement: Refinement<Node, T>, options?: Node.Traversal): Option<T>;
    closest(predicate: Predicate<Node>, options?: Node.Traversal): Option<Node>;
}
/**
 * @public
 */
export declare namespace Node {
    interface JSON<T extends string = string> extends tree.Node.JSON<T> {
        path?: string;
    }
    interface SerializationOptions extends json.Serializable.Options {
        device?: Device;
    }
    interface EARL extends earl.EARL {
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        "@type": [
            "ptr:Pointer",
            "ptr:SinglePointer",
            "ptr:ExpressionPointer",
            "ptr:XPathPointer"
        ];
        "ptr:expression": string;
        "ptr:reference"?: {
            "@id": string;
        };
    }
    function isNode(value: unknown): value is Node;
    const Traversal: {
        of: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => {
            has(flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested"): boolean;
            isSet: (flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested") => boolean;
            add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
            set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
            remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
            unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
            is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): boolean;
            equals(value: any): boolean;
            equals(value: unknown): value is any;
            toString(): string;
            toJSON(): Flags.JSON<"DOM traversal"> & {
                composed: boolean;
                flattened: boolean;
                nested: boolean;
            };
            readonly value: number;
            readonly kind: "DOM traversal";
        } & {
            composed: boolean;
            flattened: boolean;
            nested: boolean;
        };
        readonly none: 0;
        readonly empty: {
            has(flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested"): boolean;
            isSet: (flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested") => boolean;
            add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
            set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
            remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
            unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
            is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): boolean;
            equals(value: any): boolean;
            equals(value: unknown): value is any;
            toString(): string;
            toJSON(): Flags.JSON<"DOM traversal"> & {
                composed: boolean;
                flattened: boolean;
                nested: boolean;
            };
            readonly value: number;
            readonly kind: "DOM traversal";
        } & {
            composed: boolean;
            flattened: boolean;
            nested: boolean;
        };
        readonly allFlags: [1, 2, 4];
        nameOf: (flag: 1 | 2 | 4) => "composed" | "flattened" | "nested";
        reduce: (...flags: import("@siteimprove/alfa-array").Array<number>) => number;
        named: <K extends string, A extends import("@siteimprove/alfa-array").Array<string>>(kind: K, ...flags: A) => {
            [x: string]: any;
        };
        composed: 1 | 2 | 4;
        flattened: 1 | 2 | 4;
        nested: 1 | 2 | 4;
    };
    type Traversal = ReturnType<(typeof Traversal)["of"]>;
    type TraversalFlags = (typeof Node.Traversal.allFlags)[number];
    /**
     * Traversal options to traverse the flat tree.
     *
     * {@link https://drafts.csswg.org/css-scoping-1/#flattening}
     */
    const flatTree: {
        has(flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested"): boolean;
        isSet: (flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested") => boolean;
        add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): boolean;
        equals(value: any): boolean;
        equals(value: unknown): value is any;
        toString(): string;
        toJSON(): Flags.JSON<"DOM traversal"> & {
            composed: boolean;
            flattened: boolean;
            nested: boolean;
        };
        readonly value: number;
        readonly kind: "DOM traversal";
    } & {
        composed: boolean;
        flattened: boolean;
        nested: boolean;
    };
    /**
     * Traversal options to traverse all relevant nodes (flat tree and inside
     * nested browsing container), a very frequent use case.
     */
    const fullTree: {
        has(flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested"): boolean;
        isSet: (flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested") => boolean;
        add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): boolean;
        equals(value: any): boolean;
        equals(value: unknown): value is any;
        toString(): string;
        toJSON(): Flags.JSON<"DOM traversal"> & {
            composed: boolean;
            flattened: boolean;
            nested: boolean;
        };
        readonly value: number;
        readonly kind: "DOM traversal";
    } & {
        composed: boolean;
        flattened: boolean;
        nested: boolean;
    };
    /**
     * Traversal options to traverse in shadow-including tree order and inside
     * nested browsing context container, a common use case.
     */
    const composedNested: {
        has(flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested"): boolean;
        isSet: (flag: 0 | 1 | 2 | 4 | "composed" | "flattened" | "nested") => boolean;
        add(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        set: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        remove(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): any;
        unset: (...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">) => any;
        is(...flags: import("@siteimprove/alfa-array").Array<0 | 1 | 2 | 4 | "composed" | "flattened" | "nested">): boolean;
        equals(value: any): boolean;
        equals(value: unknown): value is any;
        toString(): string;
        toJSON(): Flags.JSON<"DOM traversal"> & {
            composed: boolean;
            flattened: boolean;
            nested: boolean;
        };
        readonly value: number;
        readonly kind: "DOM traversal";
    } & {
        composed: boolean;
        flattened: boolean;
        nested: boolean;
    };
    function from(json: Element.JSON, device?: Device): Element;
    function from(json: Attribute.JSON, device?: Device): Attribute;
    function from(json: Text.JSON, device?: Device): Text;
    function from(json: Comment.JSON, device?: Device): Comment;
    function from(json: Document.JSON, device?: Device): Document;
    function from(json: Type.JSON, device?: Device): Document;
    function from(json: Fragment.JSON, device?: Device): Fragment;
    function from(json: JSON, device?: Device): Node;
    /**
     * @internal
     */
    function fromNode(json: JSON, device?: Device): Trampoline<Node>;
    interface ElementReplacementOptions {
        predicate: Predicate<Element>;
        newElements: Iterable<Element>;
    }
    /**
     * Creates a new `Element` instance with the same value as the original and
     * deeply referentially non-equal. Optionally replaces child elements based
     * on a predicate.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Element, options?: ElementReplacementOptions, device?: Device): Element;
    /**
     * Creates a new `Attribute` instance with the same value as the original and
     * referentially non-equal.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Attribute, options?: ElementReplacementOptions, device?: Device): Attribute;
    /**
     * Creates a new `Text` instance with the same value as the original and
     * referentially non-equal.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Text, options?: ElementReplacementOptions, device?: Device): Text;
    /**
     * Creates a new `Comment` instance with the same value as the original and
     * referentially non-equal.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Comment, options?: ElementReplacementOptions, device?: Device): Comment;
    /**
     * Creates a new `Document` instance with the same value as the original and
     * deeply referentially non-equal. Optionally replaces child elements based
     * on a predicate.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Document, options?: ElementReplacementOptions, device?: Device): Document;
    /**
     * Creates a new `Type` instance with the same value as the original and
     * referentially non-equal.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Type, options?: ElementReplacementOptions, device?: Device): Document;
    /**
     * Creates a new `Fragment` instance with the same value as the original and
     * deeply referentially non-equal. Optionally replaces child elements based
     * on a predicate.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Fragment, options?: ElementReplacementOptions, device?: Device): Fragment;
    /**
     * Creates a new `Shadow` instance with the same value as the original and
     * deeply referentially non-equal. Optionally replaces child elements based
     * on a predicate.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     * `undefined`.
     */
    function clone(node: Shadow, options?: ElementReplacementOptions, device?: Device): Shadow;
    /**
     * Creates a new `Node` instance with the same value as the original and
     * deeply referentially non-equal. Optionally replaces child elements based
     * on a predicate.
     *
     * @remarks
     * The clone will have the same `externalId` as the original.
     * The clone will *not* get `extraData` from the original, instead it will be
     *   `undefined`.
     */
    function clone(node: Node, options?: ElementReplacementOptions, device?: Device): Node;
    /**
     * @internal
     */
    function cloneNode(node: Node, options?: ElementReplacementOptions, device?: Device): Trampoline<Node>;
    const getNodesBetween: typeof traversal.getNodesBetween;
    const hasBox: typeof predicate.hasBox, hasChild: typeof predicate.hasChild, hasDescendant: typeof predicate.hasDescendant, hasInclusiveDescendant: typeof predicate.hasInclusiveDescendant, hasTextContent: typeof predicate.hasTextContent, isRoot: typeof predicate.isRoot;
}
//# sourceMappingURL=node.d.ts.map