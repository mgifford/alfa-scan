import { Token } from "@siteimprove/alfa-css";
import { Parser } from "@siteimprove/alfa-parser";
import { Err, Ok } from "@siteimprove/alfa-result";
const { delimited, map, option, separated } = Parser;
/**
 * @public
 */
export class Property {
    static of(name, value) {
        return new Property(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
        this._name = name;
        this._value = value;
    }
    get name() {
        return this._name;
    }
    get value() {
        return this._value;
    }
    matches() {
        // We pretend to support all standard CSS properties.
        // When this is not the case, and it impacts our audit, we need to
        // add support for the missing property…
        // https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
        // The value might be totally invalid. We assume this won't create problem,
        // that is nobody is relying on a @supports rule with invalid value being
        // rejected to ensure their styling.
        return !this._name.startsWith("-");
    }
    *iterator() {
        yield this;
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    equals(value) {
        return (value instanceof Property &&
            value._name === this._name &&
            value._value === this._value);
    }
    toJSON() {
        return {
            type: "property",
            name: this._name,
            value: this._value,
        };
    }
    toString() {
        return `${this._name}: ${this._value}`;
    }
}
/**
 * @public
 */
(function (Property) {
    function isProperty(value) {
        return value instanceof Property;
    }
    Property.isProperty = isProperty;
    /**
     * @remarks
     * We do not want to actually parse the value at this point, since it would
     * create a circular dependency with `siteimprove/alfa-style` who knows about
     * this.
     * Therefore, we accept any OK-ish string as a decent value… This creates challenges
     * to be reasonably sure that the value is actually terminated.
     *
     * As per grammar, the declaration is enclosed in parentheses. So we stop as soon as we've seen
     * more `)` than `(`.
     */
    const parseValue = (input) => {
        let count = 0;
        let value = "";
        let rest = input;
        while (!rest.isEmpty()) {
            const token = rest.first().getUnsafe();
            if (Token.isOpenParenthesis(token) || Token.isFunction(token)) {
                count++;
            }
            else if (Token.isCloseParenthesis(token)) {
                count--;
            }
            if (count < 0) {
                break;
            }
            // Do not consume the last closing parenthesis.
            rest = rest.rest();
            value += token.toString();
        }
        return count < 0
            ? Ok.of([rest, value.trim()])
            : Err.of("Unexpected end of input");
    };
    Property.parse = map(separated(Token.parseIdent(), delimited(option(Token.parseWhitespace), Token.parseColon), parseValue), ([name, value]) => Property.of(name.value, value));
})(Property || (Property = {}));
//# sourceMappingURL=property.js.map