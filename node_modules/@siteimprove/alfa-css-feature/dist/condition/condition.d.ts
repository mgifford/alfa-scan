import { type Parser as CSSParser } from "@siteimprove/alfa-css";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Feature } from "../feature.js";
import { And } from "./and.js";
import { Not } from "./not.js";
import { Or } from "./or.js";
/**
 * {@link https://drafts.csswg.org/mediaqueries-5/#media-conditions}
 */
export type Condition<F extends Feature<F>> = F | And<F> | Or<F> | Not<F>;
export declare namespace Condition {
    type JSON<F extends Feature<F>> = Serializable.ToJSON<F> | And.JSON<F> | Or.JSON<F> | Not.JSON<F>;
    function isCondition<T extends Feature<T>>(value: unknown): value is Condition<T>;
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-media-condition}
     *
     * @privateRemarks
     * We absolutely must defer evaluation of the parseInParens computation as lazily as
     * possible to avoid infinite recursion.
     */
    function parse<F extends Feature<F>>(featureParser: CSSParser<F>): CSSParser<Condition<F>>;
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-media-condition-without-or}
     */
    function parseWithoutOr<F extends Feature<F>>(featureParser: CSSParser<F>): CSSParser<Condition<F>>;
}
//# sourceMappingURL=condition.d.ts.map