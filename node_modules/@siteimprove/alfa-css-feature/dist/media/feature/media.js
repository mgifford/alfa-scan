import { Keyword, Length, Token, } from "@siteimprove/alfa-css";
import { None, Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Value } from "./value/index.js";
import { Comparison } from "./comparison.js";
const { delimited, either, filter, left, map, option, pair, right, separated } = Parser;
/**
 * {@link https://drafts.csswg.org/mediaqueries-5/#mq-features}
 *
 * @remarks
 * Media features all have a name and a value.
 *
 * @public
 */
export class Media {
    _name;
    _value;
    constructor(name, value) {
        this._name = name;
        this._value = value;
    }
    get name() {
        return this._name;
    }
    get value() {
        return this._value;
    }
    equals(value) {
        return (value instanceof Media &&
            value.name === this.name &&
            value._value.equals(this._value));
    }
    *iterator() {
        yield this;
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toJSON() {
        return {
            type: "feature",
            name: this._name,
            value: this._value.map((value) => value.toJSON()).getOr(null),
        };
    }
    toString() {
        return `${this.name}${this._value.map((value) => `: ${value}`).getOr("")}`;
    }
}
(function (Media) {
    function isMedia(value) {
        return value instanceof Media;
    }
    Media.isMedia = isMedia;
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-mf-name}
     */
    function parseName(name, withRange = false) {
        return filter(map(Token.parseIdent(), (ident) => ident.value.toLowerCase()), (parsed) => parsed === name ||
            (withRange && (parsed === `min-${name}` || parsed === `max-${name}`)), (parsed) => `Unknown feature ${parsed}`);
    }
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-mf-plain}
     */
    function parsePlain(name, parseValue, withRange, from) {
        return map(separated(parseName(name, withRange), delimited(option(Token.parseWhitespace), Token.parseColon), parseValue), ([name, value]) => {
            if (withRange && (name.startsWith("min-") || name.startsWith("max-"))) {
                const range = name.startsWith("min-")
                    ? Value.minimumRange
                    : Value.maximumRange;
                return from(Option.of(range(Value.bound(value, /* isInclusive */ true))));
            }
            else {
                return from(Option.of(Value.discrete(value)));
            }
        });
    }
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-mf-boolean}
     */
    function parseBoolean(name, from) {
        return map(parseName(name), () => from(None));
    }
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-mf-value}
     *
     * @remarks
     * We currently do not support calculations in media queries
     * We currently only support media features whose value is keyword
     * or length, keyword parsing uses the `@siteimprove/alfa-css` parser.
     */
    const parseLength = filter(Length.parse, (length) => !length.hasCalculation(), () => "Calculations no supported in media queries");
    function parseComparisonLengthBound(parseComparison) {
        return map(pair(parseComparison, parseLength), ([comparison, value]) => [
            Value.bound(value, Comparison.isInclusive(comparison)),
            comparison,
        ]);
    }
    function parseLengthComparisonBound(parseComparison) {
        return map(pair(parseLength, parseComparison), ([value, comparison]) => [
            Value.bound(value, Comparison.isInclusive(comparison)),
            comparison,
        ]);
    }
    /**
     * {@link https://drafts.csswg.org/mediaqueries-5/#typedef-mf-range}
     */
    function parseRange(name, from) {
        return either(
        // <mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value>
        map(pair(parseLengthComparisonBound(Comparison.parseLessThan), right(delimited(option(Token.parseWhitespace), parseName(name)), parseComparisonLengthBound(Comparison.parseLessThan))), ([[minimum], [maximum]]) => from(Option.of(Value.range(minimum, maximum)))), 
        // <mf-value> <mf-gt> <mf-name> <mf-gt> <mf-value>
        map(pair(parseLengthComparisonBound(Comparison.parseGreaterThan), right(delimited(option(Token.parseWhitespace), parseName(name)), parseComparisonLengthBound(Comparison.parseGreaterThan))), ([[maximum], [minimum]]) => from(Option.of(Value.range(minimum, maximum)))), 
        // <mf-name> <mf-comparison> <mf-value>
        map(right(parseName(name), parseComparisonLengthBound(Comparison.parse)), ([bound, comparison]) => {
            switch (comparison) {
                case Comparison.Equal:
                    return from(Option.of(Value.range(bound, bound)));
                case Comparison.LessThan:
                case Comparison.LessThanOrEqual:
                    return from(Option.of(Value.maximumRange(bound)));
                case Comparison.GreaterThan:
                case Comparison.GreaterThanOrEqual:
                    return from(Option.of(Value.minimumRange(bound)));
            }
        }), 
        // <mf-value> <mf-comparison> <mf-name>
        map(left(parseLengthComparisonBound(Comparison.parse), parseName(name)), ([bound, comparison]) => {
            switch (comparison) {
                case Comparison.Equal:
                    return from(Option.of(Value.range(bound, bound)));
                case Comparison.LessThan:
                case Comparison.LessThanOrEqual:
                    return from(Option.of(Value.minimumRange(bound)));
                case Comparison.GreaterThan:
                case Comparison.GreaterThanOrEqual:
                    return from(Option.of(Value.maximumRange(bound)));
            }
        }));
    }
    /**
     * @internal
     */
    function parseContinuous(name, from) {
        return either(parseRange(name, from), parsePlain(name, parseLength, true, from), parseBoolean(name, from));
    }
    Media.parseContinuous = parseContinuous;
    /**
     * @internal
     */
    function parseDiscrete(name, from, ...values) {
        return either(parsePlain(name, Keyword.parse(...values), false, from), parseBoolean(name, from));
    }
    Media.parseDiscrete = parseDiscrete;
})(Media || (Media = {}));
//# sourceMappingURL=media.js.map