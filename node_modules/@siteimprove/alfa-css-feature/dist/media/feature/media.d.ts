import { Keyword, Length, type Parser as CSSParser } from "@siteimprove/alfa-css";
import type { Device } from "@siteimprove/alfa-device";
import type * as json from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type { Feature } from "../../feature.js";
import { Value } from "./value/index.js";
/**
 * {@link https://drafts.csswg.org/mediaqueries-5/#mq-features}
 *
 * @remarks
 * Media features all have a name and a value.
 *
 * @public
 */
export declare abstract class Media<N extends string = string, T = unknown> implements Feature<Media<N, T>> {
    private readonly _name;
    protected readonly _value: Option<Value<T>>;
    protected constructor(name: N, value: Option<Value<T>>);
    get name(): string;
    get value(): Option<Value<T>>;
    abstract matches(device: Device): boolean;
    equals(value: unknown): value is this;
    private iterator;
    [Symbol.iterator](): Iterator<Media<N, T>>;
    toJSON(): Media.JSON<N>;
    toString(): string;
}
export declare namespace Media {
    interface JSON<N extends string = string> {
        [key: string]: json.JSON;
        type: "feature";
        name: N;
        value: Value.JSON | null;
    }
    function isMedia(value: unknown): value is Media;
    /**
     * @internal
     */
    function parseContinuous<N extends string = string>(name: N, from: (value: Option<Value<Length.Fixed>>) => Media<N, Length.Fixed>): CSSParser<Media<N, Length.Fixed>>;
    /**
     * @internal
     */
    function parseDiscrete<N extends string = string, K extends string = string>(name: N, from: (value: Option<Value<Keyword<K>>>) => Media<N, Keyword<K>>, ...values: Array<K>): CSSParser<Media<N, Keyword<K>>>;
}
//# sourceMappingURL=media.d.ts.map