import { Length } from "@siteimprove/alfa-css";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { Option } from "@siteimprove/alfa-option";
import { Refinement } from "@siteimprove/alfa-refinement";
import type * as json from "@siteimprove/alfa-json";
import type { Bound } from "./bound.js";
import type { Discrete } from "./discrete.js";
import type { Value } from "./value.js";
/**
 * A range, with an optional minimum and maximum bound, both of which may be
 * inclusive or exclusive.
 *
 * @public
 */
export declare class Range<T = unknown> implements Value<T>, Serializable<Range.JSON<T>> {
    static of<T>(minimum: Bound<T>, maximum: Bound<T>): Range<T>;
    static minimum<T>(minimum: Bound<T>): Range<T>;
    static maximum<T>(maximum: Bound<T>): Range<T>;
    private readonly _minimum;
    private readonly _maximum;
    protected constructor(minimum: Option<Bound<T>>, maximum: Option<Bound<T>>);
    get minimum(): Option<Bound<T>>;
    get maximum(): Option<Bound<T>>;
    map<U>(mapper: Mapper<T, U>): Range<U>;
    toLength(): Range<T | Length<"px">>;
    matches(value: T): boolean;
    hasValue<U extends T>(refinement: Refinement<T, U>): this is Discrete<U>;
    toJSON(): Range.JSON<T>;
}
/**
 * @public
 */
export declare namespace Range {
    interface JSON<T> {
        [key: string]: json.JSON;
        type: "range";
        minimum: Bound.JSON<T> | null;
        maximum: Bound.JSON<T> | null;
    }
    function isRange<T>(value: unknown): value is Range<T>;
}
//# sourceMappingURL=range.d.ts.map