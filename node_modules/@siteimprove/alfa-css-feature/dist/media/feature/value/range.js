import { Comparable } from "@siteimprove/alfa-comparable";
import { Length, Number } from "@siteimprove/alfa-css";
import { None, Option } from "@siteimprove/alfa-option";
import { Refinement } from "@siteimprove/alfa-refinement";
/**
 * A range, with an optional minimum and maximum bound, both of which may be
 * inclusive or exclusive.
 *
 * @public
 */
export class Range {
    static of(minimum, maximum) {
        return new Range(Option.of(minimum), Option.of(maximum));
    }
    static minimum(minimum) {
        return new Range(Option.of(minimum), None);
    }
    static maximum(maximum) {
        return new Range(None, Option.of(maximum));
    }
    _minimum;
    _maximum;
    constructor(minimum, maximum) {
        this._minimum = minimum;
        this._maximum = maximum;
    }
    get minimum() {
        return this._minimum;
    }
    get maximum() {
        return this._maximum;
    }
    map(mapper) {
        return new Range(this._minimum.map((bound) => bound.map(mapper)), this._maximum.map((bound) => bound.map(mapper)));
    }
    toLength() {
        return this.map((bound) => Refinement.and(Number.isNumber, (value) => !value.hasCalculation() && value.value === 0)(bound)
            ? Length.of(0, "px")
            : bound);
    }
    matches(value) {
        if (!Comparable.isComparable(value)) {
            return false;
        }
        // Since we need to match both bounds, we return false if one is not
        // matched and keep true for the default return at the end.
        for (const minimum of this._minimum) {
            if (minimum.isInclusive) {
                // value is inclusively larger than the minimum if it is not
                // strictly smaller than it.
                if (value.compare(minimum.value) < 0) {
                    return false;
                }
            }
            else {
                if (value.compare(minimum.value) <= 0) {
                    return false;
                }
            }
        }
        for (const maximum of this._maximum) {
            if (maximum.isInclusive) {
                if (value.compare(maximum.value) > 0) {
                    return false;
                }
            }
            else {
                if (value.compare(maximum.value) >= 0) {
                    return false;
                }
            }
        }
        return true;
    }
    hasValue(refinement) {
        return (this._minimum.every((bound) => refinement(bound.value)) &&
            this._maximum.every((bound) => refinement(bound.value)));
    }
    toJSON() {
        return {
            type: "range",
            minimum: this._minimum.map((bound) => bound.toJSON()).getOr(null),
            maximum: this._maximum.map((bound) => bound.toJSON()).getOr(null),
        };
    }
}
/**
 * @public
 */
(function (Range) {
    function isRange(value) {
        return value instanceof Range;
    }
    Range.isRange = isRange;
})(Range || (Range = {}));
//# sourceMappingURL=range.js.map