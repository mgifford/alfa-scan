import type { Element } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import { Option } from "@siteimprove/alfa-option";
import type * as json from "@siteimprove/alfa-json";
import { Block } from "./block.js";
/**
 * The rule tree is a data structure used for storing the rules that match each
 * element when computing cascade for a document.
 *
 * @remarks
 * Rules are stored in order from most to least precedence (according to cascade
 * sorting order); rules lower in the tree have therefore higher precedence than
 * rules higher in the tree. Each element gets a pointer to the highest
 * precedence rule it matched and can then follow pointers up the rule tree to
 * locate rules of decreasing precedence that the element also matches. This
 * allows elements that share matched rules to also share a path in the rule tree.
 *
 * As an example, consider elements `A = <div class="foo" href="A">`  and
 * `B = <div class="foo bar">`. Element A matches rules `div`, `.foo` and
 * `.foo[href]` whereas element B matches rules `div`, `.foo` and `.bar`. The
 * na√Øve approach to associating these matched rules with elements
 * would be to associate an array of `[".foo[href]", ".foo", "div"]` with
 * element A and an array of `[".bar", ".foo", "div"]` with element B. With the
 * rule tree, we instead start by inserting the matched rules for element A into
 * the tree:
 *
 *  "div"
 *  +-- ".foo"
 *      +-- ".foo[href]"     (A)
 *
 * We then associate rule `".foo[href]"` with element A and insert the matched
 * rules for element B into the tree:
 *
 *  "div"
 *  +-- ".foo"
 *      +-- ".foo[href]"    (A)
 *      +-- ".bar"          (B)
 *
 * We then associate the rule `".bar"` with element B, and we're done. Notice how
 * the tree branches at rule `".foo"`, allowing the two elements to share the
 * path in the rule tree that they have in common. This approach is conceptually
 * similar to associating arrays of matched rules with elements with the
 * difference being that we use linked lists instead of arrays, allowing us to
 * share parts of the list between elements. This allows for a much more memory
 * efficient way of associating matched rules with elements, in particular for
 * rules that match most elements, such as the universal selector or `html` and
 * `body`.
 *
 * Note that the resulting rule tree depends greatly on the order in which
 * rules are inserted, which must then be by increasing precedence. The `.foo`
 * and `.bar` selectors are not directly comparable; the example above assumes
 * that the `.bar` rule came later in the style sheet order and therefore wins
 * the cascade sort by "Order of Appearance". This information is not available
 * for the rule tree which relies on rules being fed to it in increasing
 * precedence for each element. If `.bar` came before `.foo`, the resulting tree
 * would be (notice that `.foo` is not sharable anymore):
 *
 * "div"
 * +-- ".foo"
 *     +-- ".foo[href]"   (A)
 * +-- ".bar"
 *     +-- ".foo"         (B)
 *
 * {@link http://doc.servo.org/style/rule_tree/struct.RuleTree.html}
 *
 * @privateRemarks
 * The rules tree is actually a forest of nodes since many elements do not share
 * any matched selector. We artificially root it at a fake node with no
 * declarations, hence no impact on style. The fake root is not serialized.
 *
 * @public
 */
export declare class RuleTree implements Serializable {
    static empty(): RuleTree;
    private readonly _root;
    protected constructor();
    /**
     * Add a bunch of items to the tree. Returns the last node created, which is
     * the highest precedence node for that list of items.
     *
     * @remarks
     * The rules are assumed to be:
     * 1. all matching the same element; and
     * 2. be all the rules matching that element.
     *
     * It is up to the caller to ensure this is true, as the tree itself cannot
     * check that (notably, it has no access to the DOM tree to ensure the rules
     * match the same element; nor to the origin or order of the rules to check
     * cascade order).
     *
     * @privateRemarks
     * This is stateful. Adding rules to a rule tree does mutate it!
     *
     * @internal
     */
    add(rules: Iterable<Block<Element | Block.Source, true>>): RuleTree.Node;
    toJSON(): RuleTree.JSON;
}
/**
 * @public
 */
export declare namespace RuleTree {
    type JSON = Array<Node.JSON>;
    class Node implements Serializable {
        static of(block: Block, children: Array<Node>, parent: Option<Node>): Node;
        private readonly _block;
        private readonly _children;
        private readonly _parent;
        protected constructor(block: Block, children: Array<Node>, parent: Option<Node>);
        get block(): Block;
        get children(): Array<Node>;
        get parent(): Option<Node>;
        ancestors(): Iterable<Node>;
        inclusiveAncestors(): Iterable<Node>;
        /**
         * Adds style rule to a node in the tree. Returns the node where the rule
         * was added.
         *
         * @remarks
         * Blocks with no selector, aka coming from a style attribute, will always be
         * added as new nodes.
         *
         * @privateRemarks
         * This is stateful. Adding a rule to a node mutates the node!
         *
         * @internal
         */
        add(block: Block): Node;
        toJSON(): Node.JSON;
    }
    namespace Node {
        interface JSON {
            [key: string]: json.JSON;
            block: Block.JSON;
            children: Array<Node.JSON>;
        }
    }
}
//# sourceMappingURL=rule-tree.d.ts.map