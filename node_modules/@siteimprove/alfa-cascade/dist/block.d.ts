import { Array } from "@siteimprove/alfa-array";
import { type Comparer } from "@siteimprove/alfa-comparable";
import type { Declaration, Rule, StyleRule } from "@siteimprove/alfa-dom";
import { Element } from "@siteimprove/alfa-dom";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { type Complex, type Compound, type Simple } from "@siteimprove/alfa-selector";
import type * as json from "@siteimprove/alfa-json";
import { Layer, Precedence } from "./precedence/index.js";
/**
 * While resolving cascade, a Block is a style rule that has been expanded with
 * its selector pre-parsed, its declarations extracted, and extra information
 * about Cascade Sorting Precedence.
 *
 * @remarks
 * Blocks simply couple between the different parts and are thus grouped into
 * a single structure.
 *
 * Blocks form the data stored in the rule tree and selector map. Upon building the
 * cascade, style rules are turned into Blocks which are inserted into the selector
 * map; and then relevant Blocks are inserted into the rule tree upon matching elements.
 *
 * @internal
 */
export declare class Block<S extends Element | Block.Source = Element | Block.Source, LAYERED extends boolean = boolean> implements Equatable, Serializable<Block.JSON<S>> {
    /**
     * Create a block.
     *
     * @remarks
     * This does not validate coupling of the data. Prefer using Block.from()
     *
     * @privateRemarks
     * We need to accept unlayered blocks since this is how they are built.
     */
    static of<S extends Element | Block.Source = Element | Block.Source, LAYERED extends boolean = boolean>(source: S, declarations: Iterable<Declaration>, precedence: Precedence<LAYERED>): Block<S, LAYERED>;
    private static _empty;
    /**
     * @internal
     */
    static empty(): Block;
    private readonly _rule;
    private readonly _selector;
    private readonly _owner;
    private readonly _declarations;
    private readonly _precedence;
    constructor(source: S, declarations: Array<Declaration>, precedence: Precedence<LAYERED>);
    get source(): S;
    get rule(): S extends Block.Source ? StyleRule : null;
    get selector(): S extends Block.Source ? Compound | Complex | Simple : null;
    get owner(): S extends Element ? Element : null;
    get declarations(): Iterable<Declaration>;
    get precedence(): Readonly<Precedence<LAYERED>>;
    equals(value: Block): boolean;
    equals(value: unknown): value is this;
    toJSON(): Block.JSON<S>;
}
/**
 * @internal
 */
export declare namespace Block {
    interface JSON<S extends Element | Source = Element | Source> {
        [key: string]: json.JSON;
        source: S extends Element ? Element.JSON : {
            rule: Rule.JSON;
            selector: Serializable.ToJSON<S>;
        };
        declarations: Array<Declaration.JSON>;
        precedence: Precedence.JSON;
    }
    /**
     * @internal
     */
    interface Source {
        rule: StyleRule;
        selector: Compound | Complex | Simple;
    }
    /**
     * Build Blocks from a style rule. Returns the last order used, that is unchanged
     * if selector couldn't be parsed, increased by 1 otherwise.
     *
     * @remarks
     * Order is relative to the list of all style rules and thus cannot be inferred
     * from the rule itself.
     *
     * A single rule creates more than one block.
     * * Declarations inside the rule are split by importance.
     * * Rules with a list selector are split into their components.
     *   E.g., a `div, span { color: red }` rule will create one block
     *   for `div { color: red }`, and a similar one for `span`.
     * Since all these blocks are declared at the same time, and are either declaring
     * the exact same declarations, or non-conflicting ones (due to importance), they can
     * share the exact same order.
     */
    function from(rule: StyleRule, order: number, encapsulationDepth: number, layer: {
        normal: Layer;
        important: Layer;
    }): [Array<Block<Source>>, number];
    /**
     * Turns the style attribute of an element into blocks (one for important
     * declarations, one for normal declarations).
     */
    function fromStyle(element: Element, encapsulationDepth: number): Iterable<Block<Element, true>>;
    const compare: Comparer<Block<Element | Source, true>>;
}
//# sourceMappingURL=block.d.ts.map