import type { Device } from "@siteimprove/alfa-device";
import type { Document } from "@siteimprove/alfa-dom";
import { Element, Shadow } from "@siteimprove/alfa-dom";
import type { Serializable } from "@siteimprove/alfa-json";
import { Context } from "@siteimprove/alfa-selector";
import type * as json from "@siteimprove/alfa-json";
import { RuleTree } from "./rule-tree.js";
import { SelectorMap } from "./selector-map.js";
/**
 * {@link https://drafts.csswg.org/css-cascade-5/}
 *
 * @remarks
 * The cascade associates to each element a node into a rule tree.
 * A single rule tree is built for each document or shadow root. The cascade
 * lazily fills it upon need and caches the associated node for each element.
 *
 * Upon creating a cascade, the full rule tree is built for the empty context
 * in order to leverage the ancestor filter during tree traversal. This assumes
 * that we will often query style of elements in an empty context (the default)
 * and thus benefit from pre-building it for all elements.
 *
 * For specific contexts, we only add the nodes in the rule tree as needed. We
 * assume that we mostly query only a few elements in a specific context, and
 * that the cost of rebuilding a full cascade would be too expensive.
 *
 * The cascade automatically includes the user agent style sheet.
 *
 * @public
 */
export declare class Cascade implements Serializable {
    private static readonly _cascades;
    static from(node: Document | Shadow, device: Device): Cascade;
    private readonly _root;
    private readonly _depth;
    private readonly _device;
    private readonly _selectors;
    private readonly _rules;
    private readonly _entries;
    protected constructor(root: Document | Shadow, device: Device);
    /**
     * Adds an element to the rules tree, return the associated node.
     */
    private add;
    /**
     * Get the rule tree node associated with an element.
     *
     * @remarks
     * This also adds the element to the rule tree if needed. That is, the rule
     * tree is build lazily upon need. For the empty context, we pre-build the
     * full tree, so we can benefit from an ancestor filter as we traverse the
     * full DOM tree.
     *
     * For other contexts, we assume that we will only need the style of a few elements
     * (e.g., when a link is focused we normally only need the style of the link
     * itself). Therefore, pre-building the full tree is not worth the cost.
     */
    get(element: Element, context?: Context): RuleTree.Node;
    toJSON(): Cascade.JSON;
}
/**
 * @public
 */
export declare namespace Cascade {
    interface JSON {
        [key: string]: json.JSON;
        root: Document.JSON | Shadow.JSON;
        device: Device.JSON;
        selectors: SelectorMap.JSON;
        rules: RuleTree.JSON;
    }
}
//# sourceMappingURL=cascade.d.ts.map