import type { Array } from "@siteimprove/alfa-array";
import type { Device } from "@siteimprove/alfa-device";
import type { Element, Sheet } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Context } from "@siteimprove/alfa-selector";
import type * as json from "@siteimprove/alfa-json";
import type { AncestorFilter } from "./ancestor-filter.js";
import { Block } from "./block.js";
/**
 * The selector map is a data structure used for providing indexed access to
 * the rules that are likely to match a given element.
 *
 * @remarks
 * Rules are indexed according to their key selector, which is the selector
 * that a given element MUST match in order for the rest of the selector to also
 * match. A key selector can be either an ID selector, a class selector, or a
 * type selector. In a complex selector, the key selector will be the
 * right-most selector, e.g. given `main .foo + div` the key selector would be
 * `div`. In a compound selector, the key selector will be left-most selector,
 * e.g. given `div.foo` the key selector would also be `div`.
 *
 * Any element matching a selector must match its key selector. E.g., anything
 * matching `main .foo + div` must be a `div`. Reciprocally, a
 * `<div class="bar">` can only match selectors whose key selector is `div` or
 * `.bar`. Thus, filtering on key selectors decrease the search space for
 * matching selector before the computation heavy steps of traversing the DOM
 * to look for siblings or ancestors.
 *
 * @privateRemarks
 * Internally, the selector map has three maps and two lists in one of which it
 * will store a given selector.
 * * The three maps are used for selectors for which a key selector exist;
 *   one for ID selectors, one for class selectors, and one for type selectors.
 * * The first list is used for any remaining selectors (e.g., pseudo-classes
 *   and -elements selectors have no key selector).
 * * The second list is used for the special shadow selectors that can select
 *   into the light tree. These should never be matched against elements of the
 *   same tree, but against the host tree.
 *
 * When looking up the rules that match an element, the ID, class names, and
 * type of the element are used for looking up potentially matching selectors
 * in the three maps. Selector matching is then performed against this list
 * of potentially matching selectors, plus the list of remaining selectors,
 * in order to determine the final set of matches.
 *
 * {@link http://doc.servo.org/style/selector_map/struct.SelectorMap.html}
 *
 * @internal
 */
export declare class SelectorMap implements Serializable {
    static of(ids: SelectorMap.Bucket, classes: SelectorMap.Bucket, types: SelectorMap.Bucket, other: Array<Block<Block.Source>>, shadow: Array<Block<Block.Source>>): SelectorMap;
    private readonly _ids;
    private readonly _classes;
    private readonly _types;
    private readonly _other;
    private readonly _shadow;
    protected constructor(ids: SelectorMap.Bucket, classes: SelectorMap.Bucket, types: SelectorMap.Bucket, other: Array<Block<Block.Source>>, shadow: Array<Block<Block.Source>>);
    /**
     * Get all blocks matching a given element and context, an optional
     * ancestor filter can be provided to optimize performances.
     *
     * @remarks
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     */
    get(element: Element, context: Context, filter: AncestorFilter): Iterable<Block<Block.Source, true>>;
    /**
     * Get all blocks from the "shadow" selectors that match a shadow host.
     *
     * @remarks
     * The host must be the shadow host of the tree whose style sheets define
     * this selector map.
     *
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     *
     * @privateRemarks
     * Because `:host-context` is searching for shadow-including ancestors of the
     * host, we cannot use the ancestor filter that does not escape its tree.
     * This is therefore fairly costly, and hopefully not too frequent.
     */
    getForHost(host: Element, context: Context): Iterable<Block<Block.Source, true>>;
    /**
     * Get all blocks from the "shadow" selectors that match a slotted element.
     *
     * @remarks
     * `slotted` should be a light node slotted in the tree whose style sheets
     * define this selector map. If this is not the case, all matches will fail.
     *
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     *
     * @privateRemarks
     * Because this navigates (partly) in the flat tree rather than the normal DOM
     * tree, we cannot easily re-use the ancestor filter.
     */
    getForSlotted(slotted: Element, context: Context): Iterable<Block<Block.Source, true>>;
    toJSON(): SelectorMap.JSON;
}
/**
 * @internal
 */
export declare namespace SelectorMap {
    interface JSON {
        [key: string]: json.JSON;
        ids: Bucket.JSON;
        classes: Bucket.JSON;
        types: Bucket.JSON;
        other: Array<Block.JSON>;
        shadow: Array<Block.JSON>;
    }
    function from(sheets: Iterable<Sheet>, device: Device, encapsulationDepth: number): SelectorMap;
    /**
     * @remarks
     * Selector maps only store selectors from rules, not style attribute.
     * So, they always receive Blocks with a Source.
     *
     * @internal
     */
    class Bucket implements Serializable {
        static empty(): Bucket;
        private readonly _nodes;
        protected constructor(nodes: Map<string, Array<Block<Block.Source>>>);
        add(key: string, node: Block<Block.Source>): void;
        get(key: string): Array<Block<Block.Source>>;
        toJSON(): Bucket.JSON;
    }
    /**
     * @internal
     */
    namespace Bucket {
        type JSON = Array<[string, Array<Block.JSON<Block.Source>>]>;
    }
}
//# sourceMappingURL=selector-map.d.ts.map