import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Flags } from "@siteimprove/alfa-flags";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import type { Predicate } from "@siteimprove/alfa-predicate";
import { Option } from "@siteimprove/alfa-option";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Sequence } from "@siteimprove/alfa-sequence";
import * as json from "@siteimprove/alfa-json";
/**
 * Model for n-ary trees with some traversal flags.
 *
 * In order to have a parent pointers, nodes are allowed to attach themselves
 * to a parent node. To prevent mutation of an existing tree, the child is then
 * "frozen".
 *
 * Since it is not possible to add children after node creation, and it is not
 * possible to re-attach an already attached node, this means that the trees are
 * effectively downward frozen. In turn, this allows a bunch of optimisation
 * since any traversal function that does not look upward can be cached.
 *
 * The full tree (all nodes) must accept the same set of traversal flags, but
 * the node type is not constrained.
 *
 * @public
 */
export declare abstract class Node<K extends string, F extends Flags.allFlags, T extends string = string> implements Iterable<Node<K, F>>, Equatable, Hashable, json.Serializable<Node.JSON<T>> {
    protected readonly _children: Array<Node<K, F>>;
    protected _parent: Option<Node<K, F>>;
    protected readonly _type: T;
    private readonly _externalId;
    private readonly _extraData;
    private readonly _internalId;
    /**
     * Whether the node is frozen.
     *
     * @remarks
     * As nodes are initialized without a parent and possibly attached to a parent
     * after construction, this makes hierarchies of nodes mutable. That is, a
     * node without a parent node may be assigned one by being passed as a child
     * to a parent node. When this happens, a node becomes frozen. Nodes can also
     * become frozen before being assigned a parent by using the `Node#freeze()`
     * method.
     */
    protected _frozen: boolean;
    protected constructor(children: Array<Node<K, F>>, type: T, externalId?: string, internalId?: string, extraData?: any);
    get type(): T;
    get externalId(): string | undefined;
    get extraData(): any;
    get internalId(): string;
    /**
     * @deprecated Aliases to {@link Node#internalId}.
     */
    get serializationId(): string | undefined;
    get frozen(): boolean;
    /**
     * Freeze the node. This prevents further expansion of the node hierarchy,
     * meaning that the node can no longer be passed as a child to a parent node.
     */
    freeze(): this;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    parent(options?: Flags<K, F>): Option<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    isParentOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    private _lastKnownRoot;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    root(options?: Flags<K, F>): Node<K, F>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    isRootOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    children(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    isChildOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    private _descendants;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    descendants(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    isDescendantOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    inclusiveDescendants(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    isInclusiveDescendantsOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    ancestors(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    isAncestorOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    inclusiveAncestors(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    isInclusiveAncestorOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    siblings(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    isSiblingOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    inclusiveSiblings(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    isInclusiveSiblingOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    private _preceding;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-preceding}
     */
    preceding(options?: Flags<K, F>): Sequence<Node<K, F>>;
    private _following;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-following}
     */
    following(options?: Flags<K, F>): Sequence<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-first-child}
     */
    first(options?: Flags<K, F>): Option<Node<K, F>>;
    private _last;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-last-child}
     */
    last(options?: Flags<K, F>): Option<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-previous-sibling}
     */
    previous(options?: Flags<K, F>): Option<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-next-sibling}
     */
    next(options?: Flags<K, F>): Option<Node<K, F>>;
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-index}
     *
     * @param options - Traversal flags to control tree traversal behavior
     * @param predicate - Optional predicate to filter siblings when calculating the index
     */
    index(options?: Flags<K, F>, predicate?: Predicate<Node<K, F>>): number;
    /**
     * {@link https://dom.spec.whatwg.org/#dom-element-closest}
     */
    closest<T extends Node<K, F>>(refinement: Refinement<Node<K, F>, T>, options?: Flags<K, F>): Option<T>;
    /**
     * {@link https://dom.spec.whatwg.org/#dom-element-closest}
     */
    closest(predicate: Predicate<Node<K, F>>, options?: Flags<K, F>): Option<Node<K, F>>;
    [Symbol.iterator](): Iterator<Node<K, F>>;
    equals(value: Node<K, F>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: json.Serializable.Options): Node.JSON<T>;
    /**
     * @internal
     */
    _attachParent(parent: Node<K, F>): boolean;
}
/**
 * @public
 */
export declare namespace Node {
    interface JSON<T extends string = string> {
        [key: string]: json.JSON | undefined;
        type: T;
        children?: Array<JSON>;
        externalId?: string;
        internalId?: string;
        serializationId?: string;
    }
}
//# sourceMappingURL=tree.d.ts.map