import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Result } from "@siteimprove/alfa-result";
import type * as json from "@siteimprove/alfa-json";
import type { Unit } from "../../unit/index.js";
import type { Angle, Length, Number, Numeric, Percentage } from "../numeric/index.js";
import type { Kind } from "./kind.js";
/**
 * {@link https://drafts.csswg.org/css-values/#calculation-tree}
 *
 * @public
 */
export declare abstract class Expression<T extends string = string> implements Equatable, Serializable {
    protected readonly _type: T;
    protected readonly _kind: Kind;
    protected constructor(type: T, kind: Kind);
    get type(): T;
    get kind(): Kind;
    /**
     * {@link https://drafts.csswg.org/css-values/#simplify-a-calculation-tree}
     */
    abstract reduce<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric>(resolver: Expression.Resolver<L, P>): Expression;
    toAngle(): Result<Angle, string>;
    toLength(): Result<Length, string>;
    toNumber(): Result<Number, string>;
    toPercentage(): Result<Percentage, string>;
    abstract equals(value: unknown): value is this;
    toJSON(): Expression.JSON<T>;
    /**
     * {@link https://drafts.csswg.org/css-values/#serialize-a-calculation-tree}
     */
    abstract toString(): string;
}
/**
 * @public
 */
export declare namespace Expression {
    interface JSON<T extends string = string> {
        [key: string]: json.JSON;
        type: T;
    }
    /**
     * Absolute units can be resolved automatically.
     * Relative lengths and percentages need some help.
     */
    /**
     * Length may appear in any expression if they are canceled out by division
     * ("1em / 1px" is a number), so we always accept a length resolver.
     *
     * @internal
     */
    interface GenericResolver<L extends Unit.Length = Unit.Length.Canonical> {
        length?(value: Length<Unit.Length.Relative>): Length<L>;
    }
    /**
     * @internal
     */
    interface LengthResolver<L extends Unit.Length = Unit.Length.Canonical> {
        length(value: Length<Unit.Length.Relative>): Length<L>;
    }
    /**
     * @internal
     */
    interface PercentageResolver<P extends Numeric = Numeric> {
        percentage(value: Percentage): P;
    }
    type Resolver<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric> = LengthResolver<L> & PercentageResolver<P>;
}
//# sourceMappingURL=expression.d.ts.map