import { Parser } from "@siteimprove/alfa-parser";
import { Function as CSSFunction, } from "../../../syntax/index.js";
import { Unit } from "../../../unit/index.js";
import { Expression } from "../expression.js";
import { Value } from "../value.js";
import { Function } from "./function.js";
const { isValueExpression } = Value;
const { map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#calc-func}
 *
 * @public
 */
export class Calculation extends Function {
    static of(expression) {
        return new Calculation([expression], expression.kind);
    }
    constructor(args, kind) {
        super("calculation", args, kind);
    }
    reduce(resolver) {
        const reduced = this._args[0].reduce(resolver);
        // If the calculation reduces to a value, no need to keep
        // the `calc()` wrapper.
        return isValueExpression(reduced) ? reduced : Calculation.of(reduced);
    }
    toString() {
        return `calc(${this._args[0]})`;
    }
}
/** @public */
(function (Calculation) {
    function isCalculation(value) {
        return value instanceof Calculation;
    }
    Calculation.isCalculation = isCalculation;
    Calculation.parse = (parseSum) => map(CSSFunction.parse("calc", (input) => parseSum(input)), ([, expression]) => Calculation.of(expression));
})(Calculation || (Calculation = {}));
//# sourceMappingURL=calc.js.map