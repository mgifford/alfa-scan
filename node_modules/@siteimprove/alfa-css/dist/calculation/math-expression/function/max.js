import { Array } from "@siteimprove/alfa-array";
import { Parser } from "@siteimprove/alfa-parser";
import { Result } from "@siteimprove/alfa-result";
import { Function as CSSFunction, Token, } from "../../../syntax/index.js";
import { Unit } from "../../../unit/index.js";
import { Angle, Length, Number } from "../../numeric/index.js";
import { Expression } from "../expression.js";
import { Value } from "../value.js";
import { Function } from "./function.js";
const { isAngle } = Angle;
const { isLength } = Length;
const { isNumber } = Number;
const { isValueExpression } = Value;
const { delimited, mapResult, option, separatedList } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#comp-func}
 *
 * @public
 */
export class Max extends Function {
    static of(first, ...expressions) {
        // {@see https://drafts.csswg.org/css-values/#determine-the-type-of-a-calculation}
        const kind = expressions.reduce((old, cur) => old.flatMap((kind) => kind.add(cur.kind)), Result.of(first.kind));
        return kind.map((kind) => new Max([first, ...expressions], kind));
    }
    constructor(args, kind) {
        super("max", args, kind);
    }
    reduce(resolver) {
        // We know from the guard in Max.of that all args have the same kind.
        const reduced = this._args.map((expr) => expr.reduce(resolver));
        if (Array.every(reduced, isValueExpression)) {
            const values = reduced.map((expr) => expr.value);
            // At this point, reduced args should be either:
            // * numbers
            // * angle, in canonical unit (deg)
            // * absolute length, in canonical unit (px)
            // * percentages
            // * relative length, in any unit
            // The first three are reduce-able further; percentages aren't because it
            // may end up being percentages of negative values.
            if (values.every(isNumber)) {
                return Value.of(Number.of(Math.max(...values.map((value) => value.value))));
            }
            if (values.every(
            // The unit test is theoretically not needed since reduced angle values
            // should always be in the canonical unit (no relative angles)
            (value) => isAngle(value) && value.hasUnit(Unit.Angle.Canonical))) {
                return Value.of(Angle.of(Math.max(...values.map((value) => value.value)), Unit.Angle.Canonical));
            }
            if (values.every((value) => isLength(value) && value.hasUnit(Unit.Length.Canonical))) {
                return Value.of(Length.of(Math.max(...values.map((value) => value.value)), Unit.Length.Canonical));
            }
            // reduced contains percentages or relative lengths, we just fall through
            // to the default case.
        }
        // reduced contains unreduced calculations, we could eagerly compact on the
        // fully reduced ones, but it's easier to just keep everything
        return new Max(reduced, this._kind);
    }
    toString() {
        return `max(${this._args.map((expr) => expr.toString()).join(", ")})`;
    }
}
/** @public */
(function (Max) {
    function isMax(value) {
        return value instanceof Max;
    }
    Max.isMax = isMax;
    Max.parse = (parseSum) => mapResult(CSSFunction.parse("max", separatedList(parseSum, delimited(option(Token.parseWhitespace), Token.parseComma))), ([, args]) => Max.of(...args));
})(Max || (Max = {}));
//# sourceMappingURL=max.js.map