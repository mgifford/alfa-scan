import { Array } from "@siteimprove/alfa-array";
import { Result } from "@siteimprove/alfa-result";
import type { Slice } from "@siteimprove/alfa-slice";
import { Token, type Parser as CSSParser } from "../../syntax/index.js";
import { Unit } from "../../unit/index.js";
import type { Numeric } from "../numeric/index.js";
import { Expression } from "./expression.js";
import type { Kind } from "./kind.js";
/**
 * {@link https://drafts.csswg.org/css-values/#calculation-tree-operator-nodes}
 *
 * @public
 */
export declare abstract class Operation<T extends string = string, O extends Array<Expression> = Array<Expression>> extends Expression<T> {
    protected readonly _operands: Readonly<O>;
    protected constructor(type: T, operands: Readonly<O>, kind: Kind);
    get operands(): Readonly<O>;
    equals(value: Operation<T, O>): boolean;
    equals(value: unknown): value is this;
    toJSON(): Operation.JSON<T>;
}
/**
 * @public
 */
export declare namespace Operation {
    interface JSON<T extends string = string> extends Expression.JSON<T> {
        operands: Array<Expression.JSON>;
    }
    abstract class Unary<T extends string = string> extends Operation<T, [
        Expression
    ]> {
        protected constructor(type: T, operands: [Expression], kind: Kind);
    }
    abstract class Binary<T extends string = string> extends Operation<T, [
        Expression,
        Expression
    ]> {
        protected constructor(type: T, operands: [Expression, Expression], kind: Kind);
    }
    class Sum extends Binary<"sum"> {
        static of(...operands: [Expression, Expression]): Result<Sum, string>;
        protected constructor(operands: [Expression, Expression], kind: Kind);
        reduce<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric>(resolver: Expression.Resolver<L, P>): Expression;
        toString(): string;
    }
    namespace Sum {
        function isSumExpression(value: unknown): value is Sum;
        /**
         * {@link https://drafts.csswg.org/css-values/#typedef-calc-sum}
         */
        function parse(input: Slice<Token>): Result<[Slice<Token>, Expression<string>], string>;
    }
    const isSumExpression: typeof Sum.isSumExpression;
    class Negate extends Unary<"negate"> {
        static of(operand: Expression): Negate;
        protected constructor(operand: [Expression], kind: Kind);
        reduce<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric>(resolver: Expression.Resolver<L, P>): Expression;
        toString(): string;
    }
    function isNegateExpression(value: unknown): value is Negate;
    class Product extends Binary<"product"> {
        static of(...operands: [Expression, Expression]): Result<Product, string>;
        protected constructor(operands: [Expression, Expression], kind: Kind);
        reduce<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric>(resolver: Expression.Resolver<L, P>): Expression;
        toString(): string;
    }
    namespace Product {
        function isProductExpression(value: unknown): value is Product;
        /**
         * {@link https://drafts.csswg.org/css-values/#typedef-calc-product}
         */
        function parse(parseSum: CSSParser<Expression>): CSSParser<Expression>;
    }
    const isProductExpression: typeof Product.isProductExpression;
    class Invert extends Unary<"invert"> {
        static of(operand: Expression): Invert;
        protected constructor(operand: [Expression], kind: Kind);
        reduce<L extends Unit.Length = Unit.Length.Canonical, P extends Numeric = Numeric>(resolver: Expression.Resolver<L, P>): Expression;
        toString(): string;
    }
    function isInvertExpression(value: unknown): value is Invert;
}
//# sourceMappingURL=operation.d.ts.map