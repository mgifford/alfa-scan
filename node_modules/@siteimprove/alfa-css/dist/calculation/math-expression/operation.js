import { Array } from "@siteimprove/alfa-array";
import { Parser } from "@siteimprove/alfa-parser";
import { Result } from "@siteimprove/alfa-result";
import { Token } from "../../syntax/index.js";
import { Unit } from "../../unit/index.js";
import { Angle, Dimension, Length, Number, Percentage, } from "../numeric/index.js";
import { Expression } from "./expression.js";
import { Function } from "./function/index.js";
import { Value } from "./value.js";
const { isAngle } = Angle;
const { isDimension } = Dimension;
const { isLength } = Length;
const { isNumber } = Number;
const { isPercentage } = Percentage;
const { delimited, either, map, mapResult, option, pair, zeroOrMore } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#calculation-tree-operator-nodes}
 *
 * @public
 */
export class Operation extends Expression {
    _operands;
    constructor(type, operands, kind) {
        super(type, kind);
        this._operands = operands;
    }
    get operands() {
        return this._operands;
    }
    equals(value) {
        return (value instanceof Operation &&
            value._type === this._type &&
            value._operands.length === this._operands.length &&
            value._operands.every((operand, i) => operand.equals(this._operands[i])));
    }
    toJSON() {
        return { ...super.toJSON(), operands: Array.toJSON(this._operands) };
    }
}
/**
 * @public
 */
(function (Operation) {
    class Unary extends Operation {
        constructor(type, operands, kind) {
            super(type, operands, kind);
        }
    }
    Operation.Unary = Unary;
    class Binary extends Operation {
        constructor(type, operands, kind) {
            super(type, operands, kind);
        }
    }
    Operation.Binary = Binary;
    class Sum extends Binary {
        static of(...operands) {
            const [fst, snd] = operands;
            const kind = fst.kind.add(snd.kind);
            return kind.map((kind) => new Sum(operands, kind));
        }
        constructor(operands, kind) {
            super("sum", operands, kind);
        }
        reduce(resolver) {
            const [fst, snd] = this._operands.map((operand) => operand.reduce(resolver));
            if (Value.isValueExpression(fst) && Value.isValueExpression(snd)) {
                if (isNumber(fst.value) && isNumber(snd.value)) {
                    return Value.of(Number.of(fst.value.value + snd.value.value));
                }
                if (isPercentage(fst.value) && isPercentage(snd.value)) {
                    return Value.of(Percentage.of(fst.value.value + snd.value.value));
                }
                if (isDimension(fst.value) &&
                    isDimension(snd.value) &&
                    fst.value.unit === snd.value.unit) {
                    const { unit } = fst.value;
                    if (Unit.isLength(unit)) {
                        return Value.of(Length.of(fst.value.value + snd.value.value, unit));
                    }
                    if (Unit.isAngle(unit)) {
                        return Value.of(Angle.of(fst.value.value + snd.value.value, unit));
                    }
                }
            }
            return new Sum([fst, snd], this._kind);
        }
        toString() {
            const [fst, snd] = this._operands;
            if (isNegateExpression(snd)) {
                return `(${fst} - ${snd.operands[0]})`;
            }
            return `(${fst} + ${snd})`;
        }
    }
    Operation.Sum = Sum;
    (function (Sum) {
        function isSumExpression(value) {
            return value instanceof Sum;
        }
        Sum.isSumExpression = isSumExpression;
        /**
         * {@link https://drafts.csswg.org/css-values/#typedef-calc-sum}
         */
        function parse(input) {
            return mapResult(pair(Product.parse(parse), zeroOrMore(pair(delimited(Token.parseWhitespace, either(map(Token.parseDelim("+"), () => false), map(Token.parseDelim("-"), () => true))), Product.parse(parse)))), ([left, result]) => result
                .map(([invert, right]) => invert ? Operation.Negate.of(right) : right)
                .reduce((left, right) => left.flatMap((left) => Operation.Sum.of(left, right)), Result.of(left)))(input);
        }
        Sum.parse = parse;
    })(Sum = Operation.Sum || (Operation.Sum = {}));
    Operation.isSumExpression = Sum.isSumExpression;
    class Negate extends Unary {
        static of(operand) {
            return new Negate([operand], operand.kind);
        }
        constructor(operand, kind) {
            super("negate", operand, kind);
        }
        reduce(resolver) {
            const [operand] = this._operands.map((operand) => operand.reduce(resolver));
            if (Value.isValueExpression(operand)) {
                const { value } = operand;
                if (isNumber(value)) {
                    return Value.of(Number.of(0 - value.value));
                }
                if (isPercentage(value)) {
                    return Value.of(Percentage.of(0 - value.value));
                }
                if (isLength(value)) {
                    return Value.of(Length.of(0 - value.value, value.unit));
                }
                if (isAngle(value)) {
                    return Value.of(Angle.of(0 - value.value, value.unit));
                }
            }
            if (isNegateExpression(operand)) {
                return operand._operands[0];
            }
            return Negate.of(operand);
        }
        toString() {
            const [operand] = this._operands;
            return `(-1 * ${operand})`;
        }
    }
    Operation.Negate = Negate;
    function isNegateExpression(value) {
        return value instanceof Negate;
    }
    Operation.isNegateExpression = isNegateExpression;
    class Product extends Binary {
        static of(...operands) {
            const [fst, snd] = operands;
            const kind = fst.kind.multiply(snd.kind);
            return kind.map((kind) => new Product(operands, kind));
        }
        constructor(operands, kind) {
            super("product", operands, kind);
        }
        reduce(resolver) {
            const [fst, snd] = this._operands.map((operand) => operand.reduce(resolver));
            if (Value.isValueExpression(fst) && Value.isValueExpression(snd)) {
                // Both operands are values, we can hopefully do the product.
                if (fst.isCanonical() && snd.isCanonical()) {
                    // Both operands are fully resolved values in canonical units. We can do
                    // the product and drop the units, just remembering the dimension.
                    return Value.of(Number.of(fst.value.value * snd.value.value), fst.kind.multiply(snd.kind).getUnsafe()).simplify();
                }
                let multiplier;
                let value;
                // If one of them is a raw number (also, no recorded dimension), we can
                // do the product.
                if (isNumber(fst.value) && fst.kind.is()) {
                    multiplier = fst.value.value;
                    value = snd.value;
                }
                else if (isNumber(snd.value) && snd.kind.is()) {
                    multiplier = snd.value.value;
                    value = fst.value;
                }
                if (multiplier !== undefined) {
                    return Value.of(value.scale(multiplier));
                }
            }
            return new Product([fst, snd], this._kind);
        }
        toString() {
            const [fst, snd] = this._operands;
            return `${fst} * ${snd}`;
        }
    }
    Operation.Product = Product;
    (function (Product) {
        function isProductExpression(value) {
            return value instanceof Product;
        }
        Product.isProductExpression = isProductExpression;
        /**
         * {@link https://drafts.csswg.org/css-values/#typedef-calc-product}
         */
        function parse(parseSum) {
            return mapResult(pair(Value.parse(Function.parse, parseSum), zeroOrMore(pair(delimited(option(Token.parseWhitespace), either(map(Token.parseDelim("*"), () => false), map(Token.parseDelim("/"), () => true))), Value.parse(Function.parse, parseSum)))), ([left, result]) => result
                .map(([invert, right]) => invert ? Operation.Invert.of(right) : right)
                .reduce((left, right) => left.flatMap((left) => Operation.Product.of(left, right)), Result.of(left)));
        }
        Product.parse = parse;
    })(Product = Operation.Product || (Operation.Product = {}));
    Operation.isProductExpression = Product.isProductExpression;
    class Invert extends Unary {
        static of(operand) {
            return new Invert([operand], operand.kind.invert());
        }
        constructor(operand, kind) {
            super("invert", operand, kind);
        }
        reduce(resolver) {
            const [operand] = this._operands.map((operand) => operand.reduce(resolver));
            if (Value.isValueExpression(operand) && operand.isCanonical()) {
                // It's a value in canonical units, we can invert it.
                const { value } = operand;
                return Value.of(Number.of(1 / value.value), operand.kind.invert());
            }
            if (isInvertExpression(operand)) {
                return operand._operands[0];
            }
            return Invert.of(operand);
        }
        toString() {
            const [operand] = this._operands;
            return `(1 / ${operand})`;
        }
    }
    Operation.Invert = Invert;
    function isInvertExpression(value) {
        return value instanceof Invert;
    }
    Operation.isInvertExpression = isInvertExpression;
})(Operation || (Operation = {}));
//# sourceMappingURL=operation.js.map