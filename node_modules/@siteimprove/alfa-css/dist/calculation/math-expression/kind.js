import { None, Option } from "@siteimprove/alfa-option";
import { Record } from "@siteimprove/alfa-record";
import { Err, Result } from "@siteimprove/alfa-result";
/**
 * {@link https://drafts.css-houdini.org/css-typed-om/#numeric-typing}
 *
 * @remarks
 * The shared `Value` interface already uses the term "type" to denote the
 * different types of CSS values. We therefore use the term "kind" to denote
 * the type of a calculation.
 *
 * @internal
 */
export class Kind {
    static of(kind) {
        const kinds = this._empty._kinds;
        return new Kind(kind === undefined ? kinds : kinds.set(kind, 1), None);
    }
    static _empty = new Kind(Record.of({
        length: 0,
        angle: 0,
        percentage: 0,
    }), None);
    _kinds;
    _hint;
    constructor(kinds, hint) {
        this._kinds = kinds;
        this._hint = hint;
    }
    get kinds() {
        return this._kinds;
    }
    get hint() {
        return this._hint;
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    is(kind, value = 1, hinted = kind === "percentage") {
        for (const entry of this._kinds) {
            // this is not the dimension we're looking for, and it has power 0.
            if (entry[0] !== kind && entry[1] === 0) {
                continue;
            }
            // this is the dimension we're looking for, and it has the correct power.
            if (entry[0] === kind && entry[1] === value) {
                continue;
            }
            return false;
        }
        // All the entries have the correct value. Is a hint allowed?
        return this._hint.isNone() || hinted;
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-add-two-types}
     */
    add(kind) {
        let a = this;
        let b = kind;
        if (a._hint.some((a) => b._hint.some((b) => a !== b))) {
            return Err.of(`Cannot add types ${a} and ${b}`);
        }
        if (a._hint.isNone()) {
            for (const hint of b._hint) {
                a = a.apply(hint);
            }
        }
        if (b._hint.isNone()) {
            for (const hint of a._hint) {
                b = b.apply(hint);
            }
        }
        if (a._kinds.equals(b._kinds)) {
            return Result.of(a);
        }
        if ([a._kinds, b._kinds].some((kinds) => kinds.get("percentage").getOr(0) !== 0) &&
            [a._kinds, b._kinds].some((kinds) => kinds.some((value, kind) => kind !== "percentage" && value !== 0))) {
            for (const hint of ["length", "angle"]) {
                const kind = a.apply(hint);
                if (kind._kinds.equals(b.apply(hint)._kinds)) {
                    return Result.of(kind);
                }
            }
        }
        return Err.of(`Cannot add types ${a} and ${b}`);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-multiply-two-types}
     */
    multiply(kind) {
        let a = this;
        let b = kind;
        if (a._hint.some((a) => b._hint.some((b) => a !== b))) {
            return Err.of(`Cannot multiply types ${a} and ${b}`);
        }
        if (a._hint.isNone()) {
            for (const hint of b._hint) {
                a = a.apply(hint);
            }
        }
        if (b._hint.isNone()) {
            for (const hint of a._hint) {
                b = b.apply(hint);
            }
        }
        return Result.of(new Kind(b._kinds.reduce((kinds, value, kind) => kinds.set(kind, kinds.get(kind).getOr(0) + value), a._kinds), a._hint));
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-invert-a-type}
     */
    invert() {
        return new Kind(this._kinds.reduce((kinds, value, kind) => kinds.set(kind, -1 * value), this._kinds), None);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#apply-the-percent-hint}
     */
    apply(hint) {
        return new Kind(this._kinds
            .set(hint, this._kinds.get(hint).getOr(0) +
            this._kinds.get("percentage").getOr(0))
            .set("percentage", 0), Option.of(hint));
    }
    equals(value) {
        return (value instanceof Kind &&
            value._kinds.equals(this._kinds) &&
            value._hint.equals(this._hint));
    }
    toJSON() {
        return {
            kinds: this._kinds.toArray(),
            hint: this._hint.getOr(null),
        };
    }
}
//# sourceMappingURL=kind.js.map