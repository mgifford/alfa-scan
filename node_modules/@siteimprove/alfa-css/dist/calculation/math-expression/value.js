import { Parser } from "@siteimprove/alfa-parser";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Selective } from "@siteimprove/alfa-selective";
import { Token } from "../../syntax/index.js";
import { Unit } from "../../unit/index.js";
import { Angle, Length, Number, Percentage, } from "../numeric/index.js";
import { Expression } from "./expression.js";
import { Kind } from "./kind.js";
const { isAngle } = Angle;
const { isLength } = Length;
const { isNumber } = Number;
const { isPercentage } = Percentage;
const { delimited, either, map } = Parser;
/**
 * @public
 */
export class Value extends Expression {
    static of(value, kindHint) {
        const kind = Selective.of(value)
            .if(isPercentage, () => Kind.of("percentage"))
            .if(isLength, () => Kind.of("length"))
            .if(isAngle, () => Kind.of("angle"))
            .else(() => kindHint ?? Kind.of())
            .get();
        return new Value(value, kind);
    }
    _value;
    constructor(value, kind) {
        super("value", kind);
        this._value = value;
    }
    get value() {
        return this._value;
    }
    reduce(resolver) {
        // Percentage are special. If it resolves to a number, we must keep the
        // number instead of carrying the kind of the percentage.
        // That is, when 100% = 10, 50% must be converted to 5, not to 5%.
        if (isPercentage(this._value)) {
            return Value.of(resolver.percentage(this._value));
        }
        return Value.of(Selective.of(this._value)
            .if(isLength, Value.lengthResolver(resolver.length))
            .if(isAngle, Value.angleResolver)
            .get(), this._kind).simplify();
    }
    toAngle() {
        if (isAngle(this._value)) {
            return Ok.of(this._value);
        }
        if (this._kind.is("angle")) {
            return Ok.of(Angle.of(this._value.value, Unit.Angle.Canonical));
        }
        return Err.of(`${this} is not an angle`);
    }
    toLength() {
        if (isLength(this.value)) {
            return Ok.of(this.value);
        }
        if (this._kind.is("length")) {
            return Ok.of(Length.of(this._value.value, Unit.Length.Canonical));
        }
        return Err.of(`${this} is not a length`);
    }
    toNumber() {
        if (isNumber(this.value)) {
            return Ok.of(this.value);
        }
        return Err.of(`${this} is not a number`);
    }
    toPercentage() {
        if (isPercentage(this.value)) {
            return Ok.of(this.value);
        }
        if (this._kind.is("percentage")) {
            return Ok.of(Percentage.of(this._value.value));
        }
        return Err.of(`${this} is not a percentage`);
    }
    simplify() {
        return this.toAngle()
            .orElse(this.toLength.bind(this))
            .orElse(this.toPercentage.bind(this))
            .orElse(this.toNumber.bind(this))
            .map((value) => Value.of(value, this._kind))
            .getOr(this);
    }
    isCanonical() {
        return (Selective.of(this._value)
            .if(isAngle, (angle) => Unit.Angle.isCanonical(angle.unit))
            .if(isLength, (length) => Unit.Length.isCanonical(length.unit))
            // Either a raw number or a number with a kind, which only happens when
            // all units are canonical.
            .if(isNumber, () => true)
            .if(isPercentage, () => true)
            .else(() => false)
            .get());
    }
    equals(value) {
        return value instanceof Value && value._value.equals(this._value);
    }
    toJSON() {
        return {
            type: "value",
            value: this._value.toJSON(),
        };
    }
    toString() {
        return `${this._value}`;
    }
}
/**
 * @public
 */
(function (Value) {
    function isValueExpression(value) {
        return value instanceof Value;
    }
    Value.isValueExpression = isValueExpression;
    /**
     * @internal
     */
    function angleResolver(angle) {
        return angle.withUnit(Unit.Angle.Canonical);
    }
    Value.angleResolver = angleResolver;
    /**
     * @internal
     */
    function lengthResolver(resolver) {
        return (length) => length.isRelative()
            ? resolver(length)
            : length.withUnit(Unit.Length.Canonical);
    }
    Value.lengthResolver = lengthResolver;
    /**
     * {@link https://drafts.csswg.org/css-values/#typedef-calc-value}
     */
    function parse(parseFunction, parseSum) {
        return either(map(either(Number.parse, Percentage.parse, Length.parse, Angle.parse), Value.of), parseFunction(parseSum), delimited(Token.parseOpenParenthesis, parseSum, Token.parseCloseParenthesis));
    }
    Value.parse = parse;
})(Value || (Value = {}));
//# sourceMappingURL=value.js.map