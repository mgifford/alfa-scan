import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Angle, Length, Number, Percentage } from "../numeric/index.js";
import { Function } from "./function/index.js";
import { Operation } from "./operation.js";
const { filter, map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#math}
 *
 * @public
 */
export class Math {
    static of(expression) {
        return new Math(expression.reduce({
            length: (value) => value,
            percentage: (value) => value,
        }));
    }
    _expression;
    _type = "math expression";
    constructor(expression) {
        this._expression = expression;
    }
    get expression() {
        return this._expression;
    }
    get type() {
        return this._type;
    }
    reduce(resolver) {
        return new Math(this._expression.reduce(resolver));
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isDimension(dimension) {
        return this._expression.kind.is(dimension);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isDimensionPercentage(dimension) {
        return (
        // dimension-percentage are not just (dimension | percentage) because the
        // dimension does accept a percent hint in this case; while pure
        // dimensions may not be hinted.
        this._expression.kind.is(dimension, 1, true) ||
            this._expression.kind.is("percentage"));
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isNumber() {
        return this._expression.kind.is();
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isPercentage() {
        return this._expression.kind.is("percentage");
    }
    resolve(resolver) {
        try {
            const expression = this._expression.reduce({
                // If the expression is a length, and we can't resolve relative lengths,
                // abort.
                length: () => {
                    throw new Error(`Missing length resolver for ${this}`);
                },
                // If the expression is a percentage, and we can't resolve percentages,
                // we keep them as percentages.
                percentage: (p) => p,
                // override default values
                ...resolver,
            });
            return expression
                .toAngle()
                .orElse(expression.toLength.bind(expression))
                .orElse(expression.toPercentage.bind(expression))
                .orElse(expression.toNumber.bind(expression))
                .or(Err.of(`${this} does not resolve to a valid expression`));
        }
        catch (e) {
            if (e instanceof Error) {
                return Err.of(e.message);
            }
            else {
                return Err.of(`Unexpected error while resolving math expression ${this}`);
            }
        }
    }
    hash(hash) { }
    equals(value) {
        return value instanceof Math && value._expression.equals(this._expression);
    }
    toJSON() {
        return {
            type: "math expression",
            expression: this._expression.toJSON(),
        };
    }
    toString() {
        return this._expression.toString();
    }
}
/**
 * @public
 */
(function (Math) {
    function isCalculation(value) {
        return value instanceof Math;
    }
    Math.isCalculation = isCalculation;
    function isNumber(value) {
        return isCalculation(value) && value.isNumber();
    }
    Math.isNumber = isNumber;
    function isPercentage(value) {
        return isCalculation(value) && value.isPercentage();
    }
    Math.isPercentage = isPercentage;
    // Due to possibility of recursive expressions (`calc(1 + calc(2+3) )`), parsers
    // are mutually recursive. This is handled by injecting the top "sum"
    // parser in the lower level parsers that need it.
    Math.parse = map(Function.parse(Operation.Sum.parse), Math.of);
    // other parsers + filters can be added when needed
    Math.parseAngle = filter(Math.parse, (calculation) => calculation.isDimension("angle"), () => `calc() expression must be of type "angle"`);
    Math.parseAnglePercentage = filter(Math.parse, (calculation) => calculation.isDimensionPercentage("angle"), () => `calc() expression must be of type "angle" or "percentage"`);
    Math.parseLength = filter(Math.parse, (calculation) => calculation.isDimension("length"), () => `calc() expression must be of type "length"`);
    Math.parseLengthPercentage = filter(Math.parse, (calculation) => calculation.isDimensionPercentage("length"), () => `calc() expression must be of type "length" or "percentage"`);
    Math.parseNumber = filter(Math.parse, (calculation) => calculation.isNumber(), () => `calc() expression must be of type "number"`);
    Math.parsePercentage = filter(Math.parse, (calculation) => calculation.isPercentage(), () => `calc() expression must be of type "percentage"`);
})(Math || (Math = {}));
//# sourceMappingURL=math.js.map