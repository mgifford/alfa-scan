import type { Unit } from "../../unit/index.js";
import { Numeric } from "./numeric.js";
/**
 * {@link https://drafts.csswg.org/css-values/#dimensions}
 *
 * @public
 */
export declare abstract class Dimension<T extends Numeric.Dimension = Numeric.Dimension, U extends Dimension.ToUnit[T] = Dimension.ToUnit[T]> extends Numeric<T> {
    protected readonly _unit: U;
    protected constructor(value: number, unit: U, type: T);
    get unit(): U;
    hasUnit<V extends Dimension.ToUnit[T]>(unit: V): this is Dimension<T, V>;
    abstract withUnit<V extends Dimension.ToUnit[T]>(unit: V): Dimension<T, V>;
    equals(value: unknown): value is this;
    toJSON(): Dimension.JSON<T, U>;
}
/**
 * @public
 */
export declare namespace Dimension {
    interface JSON<T extends Numeric.Dimension = Numeric.Dimension, U extends ToUnit[T] = ToUnit[T]> extends Numeric.JSON<T> {
        unit: U;
    }
    function isDimension(value: unknown): value is Dimension;
    /**
     * Helper type to infer Unit sub-type based on its string representation.
     *
     * @remarks
     * This could probably be factored in within Unit themselves, which would need
     * to rearrange how Unit are built (i.e. not keep them as union of strings).
     *
     * @internal
     */
    type ToUnit = {
        angle: Unit.Angle;
        length: Unit.Length;
    };
}
//# sourceMappingURL=dimension.d.ts.map