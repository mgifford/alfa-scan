import { Parser } from "@siteimprove/alfa-parser";
import { Predicate } from "@siteimprove/alfa-predicate";
import { String } from "@siteimprove/alfa-string";
import { Token } from "../../syntax/index.js";
import { Ident } from "./ident.js";
const { map } = Parser;
const { equals } = Predicate;
/**
 * {@link https://drafts.csswg.org/css-values/#keywords}
 *
 * @public
 */
export class Keyword extends Ident {
    static of(value) {
        return new Keyword(value);
    }
    constructor(value) {
        super("keyword", value);
    }
    equals(value) {
        return value instanceof Keyword && super.equals(value);
    }
}
/**
 * @public
 */
(function (Keyword) {
    function isKeyword(value, ...names) {
        return (value instanceof Keyword && (names.length === 0 || value.is(...names)));
    }
    Keyword.isKeyword = isKeyword;
    function parse(...keywords) {
        return map(Token.parseIdent((ident) => keywords.some(equals(String.toLowerCase(ident.value)))), (ident) => 
        // Make sure each possible keyword is separated into its own type. For
        // example, we want `parse("foo", "bar")` to result in the type
        // `Keyword<"foo"> | Keyword<"bar">`, not `Keyword<"foo" | "bar">`. Why?
        // Because the former is assignable to the latter, but the latter isn't
        // assignable to the former.
        Keyword.of(String.toLowerCase(ident.value)));
    }
    Keyword.parse = parse;
})(Keyword || (Keyword = {}));
//# sourceMappingURL=keyword.js.map