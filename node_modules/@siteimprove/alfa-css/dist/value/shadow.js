import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Token } from "../syntax/index.js";
import { Unit } from "../unit/index.js";
import { Color } from "./color/index.js";
import { Keyword } from "./textual/keyword.js";
import { Length } from "./numeric/index.js";
import { Value } from "./value.js";
const { filter, separatedList } = Parser;
/**
 * @public
 */
export class Shadow extends Value {
    static of(horizontal, vertical, blur, spread, color, isInset) {
        return new Shadow(horizontal, vertical, blur, spread, color, isInset);
    }
    _horizontal;
    _vertical;
    _blur;
    _spread;
    _color;
    _isInset;
    constructor(horizontal, vertical, blur, spread, color, isInset) {
        super("shadow", Value.hasCalculation(horizontal, vertical, blur, spread, color));
        this._horizontal = horizontal;
        this._vertical = vertical;
        this._blur = blur;
        this._spread = spread;
        this._color = color;
        this._isInset = isInset;
    }
    get horizontal() {
        return this._horizontal;
    }
    get vertical() {
        return this._vertical;
    }
    get blur() {
        return this._blur;
    }
    get spread() {
        return this._spread;
    }
    get color() {
        return this._color;
    }
    get isInset() {
        return this._isInset;
    }
    resolve(resolver) {
        return new Shadow(this._horizontal.resolve(resolver), this._vertical.resolve(resolver), this._blur.resolve(resolver), this._spread.resolve(resolver), Color.resolve(resolver)(this._color), this._isInset);
    }
    equals(value) {
        return (value instanceof Shadow &&
            value._horizontal.equals(this._horizontal) &&
            value._vertical.equals(this._vertical) &&
            value._blur.equals(this._blur) &&
            value._spread.equals(this._spread) &&
            value._color.equals(this._color) &&
            value._isInset === this._isInset);
    }
    hash(hash) {
        hash
            .writeHashable(this._horizontal)
            .writeHashable(this._vertical)
            .writeHashable(this._blur)
            .writeHashable(this._spread)
            .writeHashable(this._color)
            .writeBoolean(this._isInset);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            horizontal: this._horizontal.toJSON(),
            vertical: this._vertical.toJSON(),
            blur: this._blur.toJSON(),
            spread: this._spread.toJSON(),
            color: this._color.toJSON(),
            isInset: this._isInset,
        };
    }
    toString() {
        return `${this._color} ${this._horizontal} ${this._vertical} ${this._blur} ${this._spread}${this._isInset ? " inset" : ""}`;
    }
}
/**
 * @public
 */
(function (Shadow) {
    function checkLength(max) {
        return (array) => array.length >= 2 && array.length <= max;
    }
    function parseLengths(max) {
        return filter(separatedList(Length.parse, Token.parseWhitespace), checkLength(max), () => `Shadows must have between 2 and ${max} lengths`);
    }
    function parse(options) {
        const { withInset = true, withSpread = true } = options ?? {};
        return (input) => {
            let horizontal;
            let vertical;
            let blur;
            let spread;
            let color;
            let isInset;
            const skipWhitespace = () => {
                for (const [remainder] of Token.parseWhitespace(input)) {
                    input = remainder;
                }
            };
            while (true) {
                skipWhitespace();
                if (horizontal === undefined) {
                    // horizontal vertical blur? spread?
                    const result = parseLengths(withSpread ? 4 : 3)(input);
                    if (result.isOk()) {
                        [input, [horizontal, vertical, blur, spread]] = result.get();
                        continue;
                    }
                }
                if (color === undefined) {
                    // color: <color>?
                    const result = Color.parse(input);
                    if (result.isOk()) {
                        [input, color] = result.get();
                        continue;
                    }
                }
                if (isInset === undefined) {
                    // isInset: inset?
                    const result = Keyword.parse("inset")(input);
                    if (result.isOk()) {
                        if (!withInset) {
                            return Err.of("Inset is not allowed in this shadow");
                        }
                        isInset = true;
                        [input] = result.get();
                        continue;
                    }
                }
                break;
            }
            if (horizontal === undefined || vertical === undefined) {
                return Err.of("Expected horizontal and vertical offset");
            }
            return Result.of([
                input,
                Shadow.of(horizontal, vertical, blur ?? Length.of(0, Unit.Length.Canonical), spread ?? Length.of(0, Unit.Length.Canonical), color ?? Keyword.of("currentcolor"), isInset ?? false),
            ]);
        };
    }
    Shadow.parse = parse;
})(Shadow || (Shadow = {}));
//# sourceMappingURL=shadow.js.map