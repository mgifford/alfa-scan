import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Comma, Function, Token, } from "../../../../syntax/index.js";
import { Keyword } from "../../../textual/keyword.js";
import { Position } from "../../../position/index.js";
import { Value } from "../../../value.js";
import { Item } from "../item/index.js";
import { Extent } from "./extent.js";
import { Shape } from "./shape.js";
const { map, either, pair, option, left, right, delimited } = Parser;
/**
 * {@link https://drafts.csswg.org/css-images/#radial-gradients}
 *
 * @public
 */
export class Radial extends Value {
    static of(shape, position, items, repeats) {
        return new Radial(shape, position, Array.from(items), repeats);
    }
    _shape;
    _position;
    _items;
    _repeats;
    constructor(shape, position, items, repeats) {
        super("gradient", Value.hasCalculation(shape, position, ...items));
        this._shape = shape;
        this._position = position;
        this._items = items;
        this._repeats = repeats;
    }
    get kind() {
        return "radial";
    }
    get shape() {
        return this._shape;
    }
    get position() {
        return this._position;
    }
    get items() {
        return this._items;
    }
    get repeats() {
        return this._repeats;
    }
    resolve(resolver) {
        return new Radial(this._shape.resolve(resolver), this._position.resolve(resolver), this._items.map(Item.resolve(resolver)), this._repeats);
    }
    partiallyResolve(resolver) {
        return new Radial(Shape.partiallyResolve(resolver)(this._shape), this._position.partiallyResolve(resolver), Array.from(Iterable.map(this._items, (item) => item.partiallyResolve(resolver))), this._repeats);
    }
    equals(value) {
        return (value instanceof Radial &&
            value._shape.equals(this._shape) &&
            value._position.equals(this._position) &&
            value._items.length === this._items.length &&
            value._items.every((item, i) => item.equals(this._items[i])) &&
            value._repeats === this._repeats);
    }
    hash(hash) {
        hash.writeHashable(this._shape).writeHashable(this._position);
        for (const item of this._items) {
            hash.writeHashable(item);
        }
        hash.writeUint32(this._items.length).writeBoolean(this._repeats);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            kind: "radial",
            shape: this._shape.toJSON(),
            position: this._position.toJSON(),
            items: this._items.map((item) => item.toJSON()),
            repeats: this._repeats,
        };
    }
    toString() {
        const args = [`${this._shape} at ${this._position}`, ...this._items].join(", ");
        return `${this._repeats ? "repeating-" : ""}radial-gradient(${args})`;
    }
}
/**
 * @public
 */
(function (Radial) {
    function isRadial(value) {
        return value instanceof Radial;
    }
    Radial.isRadial = isRadial;
    const parsePosition = right(delimited(option(Token.parseWhitespace), Keyword.parse("at")), Position.parse(false /* legacySyntax */));
    /**
     * {@link https://drafts.csswg.org/css-images/#funcdef-radial-gradient}
     */
    Radial.parse = map(Function.parse((fn) => fn.value === "radial-gradient" ||
        fn.value === "repeating-radial-gradient", pair(option(left(either(pair(map(Shape.parse, (shape) => Option.of(shape)), option(delimited(option(Token.parseWhitespace), parsePosition))), map(parsePosition, (position) => [None, Option.of(position)])), Comma.parse)), Item.parseList)), (result) => {
        const [fn, [shapeAndPosition, items]] = result;
        const shape = shapeAndPosition
            .flatMap(([shape]) => shape)
            .getOrElse(() => Extent.of());
        const position = shapeAndPosition
            .flatMap(([, position]) => position)
            .getOrElse(() => Position.of(Keyword.of("center"), Keyword.of("center")));
        return Radial.of(shape, position, items, fn.name.startsWith("repeating"));
    });
})(Radial || (Radial = {}));
//# sourceMappingURL=radial.js.map