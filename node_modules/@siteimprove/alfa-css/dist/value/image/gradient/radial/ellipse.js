import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Token } from "../../../../syntax/index.js";
import { Keyword } from "../../../textual/keyword.js";
import { LengthPercentage } from "../../../numeric/index.js";
import { Value } from "../../../value.js";
const { option, separatedList } = Parser;
/**
 * {@link https://drafts.csswg.org/css-images/#valdef-ending-shape-ellipse}
 *
 * @internal
 */
export class Ellipse extends Value {
    static of(horizontal, vertical) {
        return new Ellipse(horizontal, vertical);
    }
    _horizontal;
    _vertical;
    constructor(horizontal, vertical) {
        super("ellipse", Value.hasCalculation(horizontal, vertical));
        this._horizontal = horizontal;
        this._vertical = vertical;
    }
    get horizontal() {
        return this._horizontal;
    }
    get vertical() {
        return this._vertical;
    }
    resolve(resolver) {
        return new Ellipse(LengthPercentage.resolve(resolver)(this._horizontal), LengthPercentage.resolve(resolver)(this._vertical));
    }
    partiallyResolve(resolver) {
        return new Ellipse(LengthPercentage.partiallyResolve(resolver)(this._horizontal), LengthPercentage.partiallyResolve(resolver)(this._vertical));
    }
    equals(value) {
        return (value instanceof Ellipse &&
            value._horizontal.equals(this._horizontal) &&
            value._vertical.equals(this._vertical));
    }
    hash(hash) {
        hash.writeHashable(this._horizontal).writeHashable(this._vertical);
    }
    toJSON() {
        return {
            type: "ellipse",
            horizontal: this._horizontal.toJSON(),
            vertical: this._vertical.toJSON(),
        };
    }
    toString() {
        return `ellipse ${this._horizontal} ${this._vertical}`;
    }
}
/**
 * @internal
 */
(function (Ellipse) {
    function isEllipse(value) {
        return value instanceof Ellipse;
    }
    Ellipse.isEllipse = isEllipse;
    const parseShape = Keyword.parse("ellipse");
    const parseSize = separatedList(LengthPercentage.parse, option(Token.parseWhitespace), 2, 2);
    Ellipse.parse = (input) => {
        let shape;
        let horizontal;
        let vertical;
        while (true) {
            for ([input] of Token.parseWhitespace(input)) {
            }
            if (shape === undefined) {
                const result = parseShape(input);
                if (result.isOk()) {
                    [input, shape] = result.get();
                    continue;
                }
            }
            if (horizontal === undefined || vertical === undefined) {
                const result = parseSize(input);
                if (result.isOk()) {
                    [input, [horizontal, vertical]] = result.get();
                    continue;
                }
            }
            break;
        }
        if (horizontal === undefined || vertical === undefined) {
            return Err.of(`Expected ellipse size`);
        }
        return Result.of([input, Ellipse.of(horizontal, vertical)]);
    };
})(Ellipse || (Ellipse = {}));
//# sourceMappingURL=ellipse.js.map