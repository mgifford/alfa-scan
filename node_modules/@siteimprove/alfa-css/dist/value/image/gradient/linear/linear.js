import { Iterable } from "@siteimprove/alfa-iterable";
import { Parser } from "@siteimprove/alfa-parser";
import { Comma, Function, } from "../../../../syntax/index.js";
import { Value } from "../../../value.js";
import { Item } from "../item/index.js";
import { Direction } from "./direction.js";
import { Side } from "./side.js";
const { map, pair, option, left } = Parser;
/**
 * {@link https://drafts.csswg.org/css-images/#linear-gradients}
 *
 * @public
 */
export class Linear extends Value {
    static of(direction, items, repeats) {
        return new Linear(direction, Array.from(items), repeats);
    }
    _direction;
    _items;
    _repeats;
    constructor(direction, items, repeats) {
        super("gradient", Value.hasCalculation(direction, ...items));
        this._direction = direction;
        this._items = items;
        this._repeats = repeats;
    }
    get kind() {
        return "linear";
    }
    get direction() {
        return this._direction;
    }
    get items() {
        return this._items;
    }
    get repeats() {
        return this._repeats;
    }
    resolve(resolver) {
        return new Linear(this._direction.resolve(), this._items.map(Item.resolve(resolver)), this._repeats);
    }
    partiallyResolve(resolver) {
        return new Linear(this._direction.resolve(), Array.from(Iterable.map(this._items, (item) => item.partiallyResolve(resolver))), this._repeats);
    }
    equals(value) {
        return (value instanceof Linear &&
            value._direction.equals(this._direction) &&
            value._items.length === this._items.length &&
            value._items.every((item, i) => item.equals(this._items[i])) &&
            value._repeats === this._repeats);
    }
    hash(hash) {
        hash.writeHashable(this._direction);
        for (const item of this._items) {
            hash.writeHashable(item);
        }
        hash.writeUint32(this._items.length).writeBoolean(this._repeats);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            kind: "linear",
            direction: this._direction.toJSON(),
            items: this._items.map((item) => item.toJSON()),
            repeats: this._repeats,
        };
    }
    toString() {
        const args = [this._direction, ...this._items].join(", ");
        return `${this._repeats ? "repeating-" : ""}linear-gradient(${args})`;
    }
}
/**
 * @public
 */
(function (Linear) {
    function isLinear(value) {
        return value instanceof Linear;
    }
    Linear.isLinear = isLinear;
    /**
     * {@link https://drafts.csswg.org/css-images/#funcdef-linear-gradient}
     */
    Linear.parse = map(Function.parse((fn) => fn.value === "linear-gradient" ||
        fn.value === "repeating-linear-gradient", pair(option(left(Direction.parse, Comma.parse)), Item.parseList)), ([fn, [direction, items]]) => {
        return Linear.of(direction.getOrElse(() => Side.of("bottom")), items, fn.name.startsWith("repeating"));
    });
})(Linear || (Linear = {}));
//# sourceMappingURL=linear.js.map