import { Parser } from "@siteimprove/alfa-parser";
import { Function as CSSFunction, Token } from "../../syntax/index.js";
import { List } from "../collection/index.js";
import { Angle, Number } from "../numeric/index.js";
import { Function } from "./function.js";
const { map, right, pair, either, delimited, option } = Parser;
/**
 * @public
 */
export class Rotate extends Function {
    static of(x, y, z, angle) {
        return new Rotate(x.resolve(), y.resolve(), z.resolve(), angle.resolve());
    }
    _x;
    _y;
    _z;
    _angle;
    constructor(x, y, z, angle) {
        super("rotate", false);
        this._x = x;
        this._y = y;
        this._z = z;
        this._angle = angle;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get z() {
        return this._z;
    }
    get angle() {
        return this._angle;
    }
    resolve() {
        return this;
    }
    equals(value) {
        return (value instanceof Rotate &&
            value._x.equals(this._x) &&
            value._y.equals(this._y) &&
            value._z.equals(this._z) &&
            value._angle.equals(this._angle));
    }
    hash(hash) {
        hash
            .writeHashable(this._x)
            .writeHashable(this._y)
            .writeHashable(this._z)
            .writeHashable(this._angle);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            x: this._x.toJSON(),
            y: this._y.toJSON(),
            z: this._z.toJSON(),
            angle: this._angle.toJSON(),
        };
    }
    toString() {
        if (this._x.value === 0 && this._y.value === 0 && this._z.value === 1) {
            return `rotate(${this._angle})`;
        }
        return `rotate3d(${this._x}, ${this._y}, ${this._z}, ${this._angle})`;
    }
}
/**
 * @public
 */
(function (Rotate) {
    function isRotate(value) {
        return value instanceof Rotate;
    }
    Rotate.isRotate = isRotate;
    const _0 = Number.of(0);
    const _1 = Number.of(1);
    const parseAngleOrZero = either(Angle.parse, map(Number.parseZero, () => Angle.of(0, "deg")));
    const parseAxis = (name) => map(CSSFunction.parse(name, parseAngleOrZero), ([_, angle]) => angle);
    /**
     * {@link https://drafts.csswg.org/css-transforms/#funcdef-transform-rotate}
     */
    const parseRotate = map(parseAxis("rotate"), (angle) => Rotate.of(_0, _0, _1, angle));
    /**
     * {@link https://drafts.csswg.org/css-transforms-2/#funcdef-rotatex}
     */
    const parseRotateX = map(parseAxis("rotateX"), (angle) => Rotate.of(_1, _0, _0, angle));
    /**
     * {@link https://drafts.csswg.org/css-transforms-2/#funcdef-rotatey}
     */
    const parseRotateY = map(parseAxis("rotateY"), (angle) => Rotate.of(_0, _1, _0, angle));
    /**
     * {@link https://drafts.csswg.org/css-transforms-2/#funcdef-rotatey}
     */
    const parseRotateZ = map(parseAxis("rotateZ"), (angle) => Rotate.of(_0, _0, _1, angle));
    /**
     * {@link https://drafts.csswg.org/css-transforms-2/#funcdef-rotate3d}
     */
    const parseRotate3d = map(CSSFunction.parse("rotate3d", pair(map(List.parseCommaSeparated(Number.parse, 3, 3), (list) => list.values), right(delimited(option(Token.parseWhitespace), Token.parseComma), parseAngleOrZero))), (result) => {
        const [_, [[x, y, z], angle]] = result;
        return Rotate.of(x, y, z, angle);
    });
    Rotate.parse = either(parseRotate, parseRotateX, parseRotateY, parseRotateZ, parseRotate3d);
})(Rotate || (Rotate = {}));
//# sourceMappingURL=rotate.js.map