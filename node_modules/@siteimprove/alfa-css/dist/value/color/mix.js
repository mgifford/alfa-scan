import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Maybe, None, Option, Some } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Token } from "../../syntax/index.js";
import { List } from "../collection/index.js";
import { Percentage } from "../numeric/index.js";
import {} from "../resolvable.js";
import { Value } from "../value.js";
const { map, option, pair, right } = Parser;
/**
 * @public
 */
export class MixItem extends Value {
    static of(value, percentage) {
        return new MixItem(value, Maybe.toOption(percentage ?? None));
    }
    _value;
    _percentage;
    constructor(value, percentage) {
        super("mix-item", Value.hasCalculation(value));
        this._value = value;
        this._percentage = percentage;
    }
    get value() {
        return this._value;
    }
    get percentage() {
        return this._percentage;
    }
    resolve(resolver) {
        return new MixItem(this._value.resolve(resolver), this._percentage);
    }
    hasPercentage() {
        return this._percentage.isSome();
    }
    withPercentage(percentage) {
        return new MixItem(this._value, Some.of(percentage));
    }
    equals(value) {
        return (value instanceof MixItem &&
            this._value.equals(value._value) &&
            this._percentage.equals(value._percentage));
    }
    hash(hash) {
        this._value.hash(hash);
        this._percentage.hash(hash);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this._value.toJSON(),
            percentage: this._percentage
                .map((percentage) => percentage.toJSON())
                .getOr(null),
        };
    }
    toString() {
        return (this._value.toString() +
            this._percentage.map((percentage) => ` ${percentage}`).getOr(""));
    }
}
/**
 * @public
 */
(function (MixItem) {
    function isMixItem(value) {
        return value instanceof MixItem;
    }
    MixItem.isMixItem = isMixItem;
    function parse(parser) {
        return map(pair(parser, option(right(Token.parseWhitespace, (Percentage.parse)))), ([value, percentage]) => MixItem.of(value, percentage.map((percentage) => percentage.resolve())));
    }
    MixItem.parse = parse;
})(MixItem || (MixItem = {}));
/**
 * @public
 */
export var Mix;
(function (Mix) {
    function sum(p1, p2) {
        return Percentage.of(p1.value + p2.value);
    }
    /**
     * {@link https://drafts.csswg.org/css-values-5/#mix-percentage-normalization}
     */
    function normalize(items, force = false) {
        let omitted = 0;
        // 1. Sum of the specified percentages.
        const specifiedSum = Iterable.reduce(items, (total, item) => sum(total, item.percentage.getOrElse(() => {
            omitted++;
            return Percentage.of(0);
        })), Percentage.of(0));
        // 2. Replace unspecified percentage by equal shares of the omitted part.
        // We do not create the intermediate list, just remember the "missing" value.
        // If omitted is 0, this won't be used, so no creeping Infinity.
        const omittedPercentage = Percentage.of((1 - specifiedSum.value) / omitted);
        // 3. "Recompute" total. This will be 100% if there were any omission, or the
        // same as the previous total.
        const total = omitted === 0 ? specifiedSum : Percentage.of(1);
        // 4. Normalize percentages, so that total is 100%. For smaller total, only
        // normalize if forced.
        // Replace unspecified percentages with the computed omitted percentage.
        function fallback(item) {
            return item.withPercentage(item.percentage.getOr(omittedPercentage));
        }
        // Normalize all percentages, replacing unspecified ones as needed, so that
        // the sum is 100%.
        function fallbackAndNormalize(item) {
            return item.withPercentage(Percentage.of(item.percentage.getOr(omittedPercentage).value / total.value));
        }
        const normalized = total.value > 1 || (force && total.value > 0)
            ? items.map(fallbackAndNormalize)
            : items.map(fallback);
        // 5. Compute leftover (unspecified) percentage.
        const leftover = total.value < 1 ? Percentage.of(1 - total.value) : Percentage.of(0);
        // 6.
        return [normalized, leftover];
    }
    Mix.normalize = normalize;
    function parse(parser) {
        return List.parseCommaSeparated(MixItem.parse(parser));
    }
    Mix.parse = parse;
})(Mix || (Mix = {}));
//# sourceMappingURL=mix.js.map