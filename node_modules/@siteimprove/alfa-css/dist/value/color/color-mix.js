import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Selective } from "@siteimprove/alfa-selective";
import { Function, Token } from "../../syntax/index.js";
import { Percentage } from "../numeric/index.js";
import { Keyword } from "../textual/index.js";
import { Value } from "../value.js";
import { CSS4Color } from "./css4-color.js";
import { Current } from "./current.js";
import { Mix, MixItem } from "./mix.js";
import { System } from "./system.js";
const { left, map, mapResult, option, pair, right, separated } = Parser;
/**
 * {@link https://drafts.csswg.org/css-color-5/#color-mix}
 *
 * @remarks
 * Browsers seems to only support 2 colors at a time, and always require
 * an interpolation space. However, specs allow for unlimited colors, and use
 * oklab as default space if unspecified. This follows specs and is therefore
 * more capable than current (2026) browsers.
 *
 * @privateRemarks
 * The extra capacity should not create false positives as we assume that authors
 * do not rely on browsers rejecting a long color-mix and defaulting to
 * unspecified value instead.
 *
 * @public
 */
// While color-mix() are not calculations per se, we consider that they are,
// resolving to base colors.
// When `currentcolor` is involved, they are only partially resolved.
export class ColorMix extends Value {
    static of(colors, space, hueMethod) {
        return new ColorMix(colors, space ?? "oklab", hueMethod ?? "shorter");
    }
    _space;
    _hueMethod;
    _colors;
    constructor(colors, space, hueMethod) {
        super("color-mix", true);
        this._colors = colors;
        this._space = space;
        this._hueMethod = hueMethod;
    }
    get colors() {
        return this._colors;
    }
    get space() {
        return this._space;
    }
    get hueMethod() {
        return this._hueMethod;
    }
    static resolveColor(color, resolver) {
        return Selective.of(color)
            .if(System.isSystem, System.resolve)
            .if(Current.isCurrent, (color) => resolver === undefined ? color : resolver.currentColor)
            .if(CSS4Color.isCSS4Color, (color) => color)
            .else((mix) => resolver === undefined ? mix.partiallyResolve() : mix.resolve(resolver))
            .get();
    }
    resolve(resolver) {
        const resolvedColors = this._colors.map((item) => MixItem.of(ColorMix.resolveColor(item.value, resolver), item.percentage.map((percentage) => percentage.resolve())));
        return ColorMix.calculate(resolvedColors, this._space, this._hueMethod);
    }
    partiallyResolve() {
        // System colors can be resolved now, but `currentcolor` cannot.
        const resolvedColors = this._colors.map((item) => MixItem.of(ColorMix.resolveColor(item.value), item.percentage.map((percentage) => percentage.resolve())));
        if (resolvedColors.every((item) => CSS4Color.isCSS4Color(item.value))) {
            return ColorMix.calculate(resolvedColors, this._space, this._hueMethod);
        }
        else {
            return ColorMix.of(resolvedColors, this._space, this._hueMethod);
        }
    }
    equals(value) {
        return (value instanceof ColorMix &&
            this._space === value._space &&
            this._hueMethod === value._hueMethod &&
            this._colors.equals(value._colors));
    }
    hash(hash) {
        hash.writeString(this.type);
        hash.writeString(this._space);
        hash.writeString(this._hueMethod);
        this._colors.hash(hash);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            space: this._space,
            hueMethod: ColorMix.isPolar(this._space) ? this._hueMethod : null,
            colors: this._colors.toJSON(),
        };
    }
    toString() {
        const hue = ColorMix.isPolar(this._space) ? ` ${this._hueMethod} hue` : "";
        return `color-mix(in ${this._space}${hue}, ${this._colors})`;
    }
}
/**
 * @public
 */
(function (ColorMix) {
    function isColorMix(value) {
        return value instanceof ColorMix;
    }
    ColorMix.isColorMix = isColorMix;
    /** @internal */
    ColorMix.rectangularSpaces = [
        "srgb",
        "srgb-linear",
        "display-p3",
        "display-p3-linear",
        "a98-rgb",
        "prophoto-rgb",
        "rec2020",
        "lab",
        "oklab",
        "xyz",
        "xyz-d50",
        "xyz-d65",
    ];
    /** @internal */
    ColorMix.polarSpaces = ["hsl", "hwb", "lch", "oklch"];
    ColorMix.interpolationSpaces = [
        ...ColorMix.rectangularSpaces,
        ...ColorMix.polarSpaces,
    ];
    function isPolar(space) {
        return ColorMix.polarSpaces.includes(space);
    }
    ColorMix.isPolar = isPolar;
    /**
     * Convert CSS color spaces names to ColorJS.io space identifiers.
     */
    const spaceId = {
        srgb: "srgb",
        "srgb-linear": "srgb-linear",
        "display-p3": "p3",
        "display-p3-linear": "p3-linear",
        "a98-rgb": "a98rgb",
        "prophoto-rgb": "prophoto",
        rec2020: "rec2020",
        lab: "lab",
        oklab: "oklab",
        xyz: "xyz",
        "xyz-d50": "xyz-d50",
        "xyz-d65": "xyz-d65",
        hsl: "hsl",
        hwb: "hwb",
        lch: "lch",
        oklch: "oklch",
    };
    /** @internal */
    ColorMix.hueInterpolationMethods = [
        "shorter",
        "longer",
        "increasing",
        "decreasing",
    ];
    function mixColorItems(space, hue) {
        return (color1, color2) => {
            const p1 = color1.percentage.get().value;
            const p2 = color2.percentage.get().value;
            return MixItem.of(CSS4Color.of(color1.value.color.mix(color2.value.color, p2 / (p1 + p2), // this is the proportion of color2 in the mix.
            { space: spaceId[space], hue })), Percentage.of(p1 + p2));
        };
    }
    /**
     * Calculates the result of a color-mix, given that all colors are already
     * resolved to CSS4Color.
     * {@see https://drafts.csswg.org/css-color-5/#color-mix-result}
     *
     * @internal
     */
    function calculate(colors, space, hue) {
        const transparent = CSS4Color.of("transparent").getUnsafe();
        // 1.
        // Note that the `force` parameter is actually powerless here since it
        // effectively multiplies all percentages by the same value (when the total
        // is <100%), which does not change their relative weights. We keep it to
        // stick to the specs.
        const [normalized, leftover] = Mix.normalize(colors, true);
        // 2.
        if (leftover.value === 1) {
            // Because we restrict the list of allowed spaces, the conversion
            // should not fail.
            return transparent.toSpace(spaceId[space]).getUnsafe();
        }
        // 3.
        const alphaMult = 1 - leftover.value;
        // 4. is describing a reduce operation. Our list is already in the correct
        // order, so we do not need to reverse it (4.1). Due to the progress
        // percentage in 4.2.2 (a/(a+b) vs b/(a+b)), the neutral element is anything
        // with a percentage (a or b) of 0, so we can use that directly for our
        // initial accumulator.
        const reduced = normalized.values.reduce(mixColorItems(space, hue), MixItem.of(transparent, Percentage.of(0)));
        // 5., 6.
        return reduced.value.withAlpha(alphaMult * reduced.value.alpha.value);
    }
    ColorMix.calculate = calculate;
    const parseSpace = map(separated(Keyword.parse("in"), Token.parseWhitespace, Keyword.parse(...ColorMix.interpolationSpaces)), ([, space]) => space.value);
    const parseHueMethod = map(left(Keyword.parse(...ColorMix.hueInterpolationMethods), Token.parseWhitespace, Keyword.parse("hue")), (hueMethod) => hueMethod.value);
    const parseInterpolation = mapResult(pair(parseSpace, option(right(Token.parseWhitespace, parseHueMethod))), ([space, hue]) => isPolar(space) || hue.isNone()
        ? Result.of([space, hue])
        : Err.of("Hue interpolation method is forbidden with rectangular color spaces."));
    /**
     * Parses a `color-mix()` function, according to a basic color parser.
     *
     * @param parseColor - A parser for colors used within the color mix.
     */
    function parse(parseColor) {
        return map(Function.parse("color-mix", pair(option(left(parseInterpolation, Token.parseComma, Token.parseWhitespace)), mapResult(Mix.parse(parseColor), (colors) => colors.none((item) => item.percentage.some((percentage) => percentage.value < 0 || percentage.value > 1))
            ? Result.of(colors)
            : Err.of("Percentages in color-mix must be between 0 and 100%.")))), ([, [interpolation, colors]]) => ColorMix.of(colors, interpolation.map(([space]) => space).getOr("oklab"), interpolation.flatMap(([, hueMethod]) => hueMethod).getOr("shorter")));
    }
    ColorMix.parse = parse;
})(ColorMix || (ColorMix = {}));
//# sourceMappingURL=color-mix.js.map