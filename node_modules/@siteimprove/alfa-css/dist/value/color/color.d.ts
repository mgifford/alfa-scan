import type { Result } from "@siteimprove/alfa-result";
import type { Slice } from "@siteimprove/alfa-slice";
import type { Token } from "../../syntax/index.js";
import { Number, Percentage } from "../numeric/index.js";
import { Keyword } from "../textual/keyword.js";
import { ColorMix } from "./color-mix.js";
import { CSS4Color } from "./css4-color.js";
import { Current } from "./current.js";
import { System } from "./system.js";
/**
 * @public
 */
export type Color<S extends ColorMix.InterpolationSpace = ColorMix.InterpolationSpace, H extends ColorMix.HueInterpolationMethod = ColorMix.HueInterpolationMethod> = ColorMix<S, H> | CSS4Color | Current | System;
/**
 * @public
 */
export declare namespace Color {
    type Canonical = CSS4Color.Canonical;
    type PartiallyResolved<S extends ColorMix.InterpolationSpace = ColorMix.InterpolationSpace, H extends ColorMix.HueInterpolationMethod = ColorMix.HueInterpolationMethod> = ColorMix<S, H> | CSS4Color | Current;
    type JSON<S extends ColorMix.InterpolationSpace = ColorMix.InterpolationSpace, H extends ColorMix.HueInterpolationMethod = ColorMix.HueInterpolationMethod> = ColorMix.JSON<S, H> | CSS4Color.JSON | Keyword.JSON;
    const isCSS4Color: typeof CSS4Color.isCSS4Color;
    const isCurrent: typeof Current.isCurrent;
    const isSystem: typeof System.isSystem;
    const isColorMix: typeof ColorMix.isColorMix;
    /**
     * Resolver for colors, must include the resolution for `currentcolor`.
     */
    interface Resolver {
        currentColor: CSS4Color.Canonical;
    }
    interface PartialResolver {
    }
    function resolve(resolver: Resolver): (color: Color) => Canonical;
    function partiallyResolve<S extends ColorMix.InterpolationSpace, H extends ColorMix.HueInterpolationMethod>(color: Color<S, H>): PartiallyResolved<S, H>;
    /**
     * Creates a color in the sRGB color space.
     */
    function rgb(red: Number | Percentage, green: Number | Percentage, blue: Number | Percentage, alpha?: Number | Percentage): CSS4Color;
    /**
     * Creates a color based on its CSS string representation.
     */
    function of(color: string): Result<CSS4Color, Error>;
    const transparent: CSS4Color;
    const current: Current;
    const system: (value: System.Keyword) => System;
    /**
     * Composite colors of a graphic element ("foreground") over a backdrop
     * ("background").
     * {@link https://drafts.csswg.org/compositing-1/#simplealphacompositing}
     *
     * @remarks
     * The graphic element (foreground) may have a partially transparent color
     * **and** be part of an HTML element which is itself partially transparent.
     * Both transparencies need to be merged first.
     *
     * @param foreground - The color of the graphic element to combine
     * @param background - The color of the backdrop to combine into
     * @param opacity - The opacity of the graphic element, independently of its color.
     */
    function composite(foreground: Color.Canonical, background: Color.Canonical, opacity: number): Color.Canonical;
    /**
     * {@link https://drafts.csswg.org/css-color/#typedef-color}
     */
    function parse(input: Slice<Token>): Result<[Slice<Token>, Color], string>;
    function isTransparent(color: Color): boolean;
}
//# sourceMappingURL=color.d.ts.map