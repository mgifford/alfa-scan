import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import type { Serializable } from "@siteimprove/alfa-json";
import type * as json from "@siteimprove/alfa-json";
import type { PartiallyResolvable, Resolvable } from "./resolvable.js";
/**
 * Representation of a CSS Value
 *
 * @remarks
 * * T: a string representation of the type stored in the value,
 *      e.g. "length", "color", â€¦
 * * CALC: whether the numeric values in this may include calculation or not.
 *         When CALC is true, the value hasn't been resolved. It does not
 *         necessarily contain calculation; when CALC is false, the value has
 *         been fully resolved and is guaranteed without calculations.
 * * R: a string representation of the type stored in the resolved value.
 *      This differs from T, typically, for dimension-percentage values that
 *      are resolved as dimensions only.
 * * PR: a string representation of the type stored in the partially resolved value.
 *
 * @public
 */
export declare abstract class Value<T extends string = string, CALC extends boolean = boolean, R extends string = T, PR extends string = R> implements Equatable, Hashable, Serializable<Value.JSON<T>>, Resolvable<Value<R, false>, Resolvable.Resolver<Value>>, PartiallyResolvable<Value<PR>, Resolvable.PartialResolver<Value>> {
    private readonly _type;
    protected readonly _hasCalculation: CALC;
    protected constructor(type: T, hasCalculation: CALC);
    get type(): T;
    hasCalculation(): this is Value<T, true, R, PR>;
    abstract resolve(resolver?: unknown): Value<R, false>;
    partiallyResolve(resolver?: unknown): Value<PR>;
    abstract equals(value: unknown): value is this;
    abstract hash(hash: Hash): void;
    toJSON(): Value.JSON<T>;
    abstract toString(): string;
}
/**
 * @public
 */
export declare namespace Value {
    interface JSON<T extends string = string> {
        [key: string]: json.JSON;
        type: T;
    }
    function isValue<T extends string>(value: unknown, type?: T): value is Value<T>;
    /**
     * @internal
     */
    type HasCalculation<V extends Array<Value>> = V extends Array<Value<string, false>> ? false : true;
    /**
     * @internal
     */
    function hasCalculation<A extends Array<Value> = []>(...values: A): HasCalculation<A>;
}
//# sourceMappingURL=value.d.ts.map