import type { Hash } from "@siteimprove/alfa-hash";
import type { Serializable } from "@siteimprove/alfa-json";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Value } from "../value.js";
/**
 * @public
 */
export declare class Tuple<T extends Array<Value>> extends Value<"tuple", Value.HasCalculation<T>> implements Resolvable<Tuple<Tuple.Resolved<T>>, Tuple.Resolver<T>>, PartiallyResolvable<Tuple<Tuple.PartiallyResolved<T>>, Tuple.PartialResolver<T>> {
    static of<T extends Array<Value>>(...values: Readonly<T>): Tuple<T>;
    private readonly _values;
    protected constructor(values: Readonly<T>);
    get values(): Readonly<T>;
    resolve(resolver?: Tuple.Resolver<T>): Tuple<Tuple.Resolved<T>>;
    partiallyResolve(resolver?: Tuple.PartialResolver<T>): Tuple<Tuple.PartiallyResolved<T>>;
    equals<T extends Array<Value>>(value: Tuple<T>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(): Tuple.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Tuple {
    interface JSON<T extends Array<Value>> extends Value.JSON<"tuple"> {
        values: Serializable.ToJSON<T>;
    }
    function isTuple<T extends Array<Value>>(value: unknown): value is Tuple<T>;
    /**
     * Applying Resolved<T> to all members of a tuple, keeping size and order.
     *
     * {@link https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c}
     *
     * @internal
     */
    type Resolved<T extends Array<Value>> = T extends [
        infer Head extends Value,
        ...infer Tail extends Array<Value>
    ] ? [Resolvable.Resolved<Head>, ...Resolved<Tail>] : [];
    type PartiallyResolved<T extends Array<Value>> = T extends [
        infer Head extends Value,
        ...infer Tail extends Array<Value>
    ] ? [Resolvable.PartiallyResolved<Head>, ...PartiallyResolved<Tail>] : [];
    /**
     * Applying Resolver<T> to all members of a tuple, collapsing them into
     * a single union
     *
     * @internal
     */
    type Resolver<T extends Array<Value>> = T extends Array<infer V extends Value> ? Resolvable.Resolver<V> : never;
    type PartialResolver<T extends Array<Value>> = T extends Array<infer V extends Value> ? Resolvable.PartialResolver<V> : never;
}
//# sourceMappingURL=tuple.d.ts.map