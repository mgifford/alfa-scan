import { Array } from "@siteimprove/alfa-array";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Parser } from "@siteimprove/alfa-parser";
import { Token } from "../../syntax/index.js";
import { Value } from "../value.js";
const { delimited, option, map, separatedList } = Parser;
/**
 * @public
 */
export class List extends Value {
    static of(values, separator = " ") {
        return new List(Array.from(values), separator);
    }
    _values;
    _separator;
    constructor(values, separator) {
        super("list", Value.hasCalculation(...values));
        this._values = values;
        this._separator = separator;
    }
    get values() {
        return this._values;
    }
    get size() {
        return this._values.length;
    }
    some(predicate) {
        return this._values.some(predicate);
    }
    none(predicate) {
        return Array.none(this._values, predicate);
    }
    every(predicate) {
        return this._values.every(predicate);
    }
    resolve(resolver) {
        return this.map((value) => value.resolve(resolver));
    }
    partiallyResolve(resolver) {
        return this.map((value) => value.partiallyResolve(resolver));
    }
    map(mapper) {
        return new List(this._values.map(mapper), this._separator);
    }
    /**
     * Returns a copy of the current instance cut off or extended with repeated values to match the given `length`.
     *
     * @example
     * List.of([1, 2, 3]).cutOrExtend(2); // returns a new List with values [1, 2]
     *
     * @example
     * List.of([1, 2, 3]).cutOrExtend(5); // returns a new List with values [1, 2, 3, 1, 2]
     */
    cutOrExtend(length) {
        if (this.size === length) {
            return new List(this._values, this._separator);
        }
        if (length < this.size) {
            return new List(this._values.slice(0, length), this._separator);
        }
        const extended = [];
        for (let i = 0; i < length; ++i) {
            // Cyclically repeat the values until the result has the desired length.
            extended.push(this._values[i % this.size]);
        }
        return new List(extended, this._separator);
    }
    equals(value) {
        return (value instanceof List &&
            value._values.length === this._values.length &&
            value._values.every((value, i) => value.equals(this._values[i])));
    }
    hash(hash) {
        for (const value of this._values) {
            value.hash(hash);
        }
        hash.writeUint32(this._values.length).writeString(this._separator);
    }
    *[Symbol.iterator]() {
        yield* this._values;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            values: this._values.map((value) => value.toJSON()),
            separator: this._separator,
        };
    }
    toString() {
        return this._values.join(this._separator);
    }
}
/**
 * @public
 */
(function (List) {
    function isList(value) {
        return value instanceof List;
    }
    List.isList = isList;
    function parse(parseValue, separator, parseSeparator, lower, upper) {
        return map(separatedList(parseValue, parseSeparator, lower, upper), (values) => List.of(values, separator));
    }
    const parseComma = delimited(option(Token.parseWhitespace), Token.parseComma);
    const parseSpace = option(Token.parseWhitespace);
    List.parseCommaSeparated = (parseValue, lower = 1, upper = Infinity) => parse(parseValue, ", ", parseComma, lower, upper);
    List.parseSpaceSeparated = (parseValue, lower = 1, upper = Infinity) => parse(parseValue, " ", parseSpace, lower, upper);
})(List || (List = {}));
//# sourceMappingURL=list.js.map