import { Array } from "@siteimprove/alfa-array";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import { type Parser as CSSParser } from "../../syntax/index.js";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Value } from "../value.js";
/**
 * @public
 */
export declare class List<V extends Value> extends Value<"list", Value.HasCalculation<[V]>> implements Iterable<V>, Resolvable<List<Resolvable.Resolved<V>>, Resolvable.Resolver<V>>, PartiallyResolvable<List<Resolvable.PartiallyResolved<V>>, Resolvable.PartialResolver<V>> {
    static of<V extends Value>(values: Iterable<V>, separator?: string): List<V>;
    private readonly _values;
    private readonly _separator;
    protected constructor(values: Array<V>, separator: string);
    get values(): ReadonlyArray<V>;
    get size(): number;
    some(predicate: Predicate<V, [index: number]>): boolean;
    none(predicate: Predicate<V, [index: number]>): boolean;
    every<U extends V>(refinement: Refinement<V, U, [index: number]>): this is List<U>;
    every(predicate: Predicate<V, [index: number]>): boolean;
    resolve(resolver?: Resolvable.Resolver<V>): List<Resolvable.Resolved<V>>;
    partiallyResolve(resolver?: Resolvable.PartialResolver<V>): List<Resolvable.PartiallyResolved<V>>;
    map<U extends Value>(mapper: Mapper<V, U>): List<U>;
    /**
     * Returns a copy of the current instance cut off or extended with repeated values to match the given `length`.
     *
     * @example
     * List.of([1, 2, 3]).cutOrExtend(2); // returns a new List with values [1, 2]
     *
     * @example
     * List.of([1, 2, 3]).cutOrExtend(5); // returns a new List with values [1, 2, 3, 1, 2]
     */
    cutOrExtend(length: number): List<V>;
    equals<T extends Value>(value: List<T>): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Iterator<V>;
    toJSON(): List.JSON<V>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace List {
    interface JSON<V extends Value> extends Value.JSON<"list"> {
        values: Array<Serializable.ToJSON<V>>;
        separator: string;
    }
    function isList<V extends Value>(value: Iterable<V>): value is List<V>;
    function isList<V extends Value>(value: unknown): value is List<V>;
    const parseCommaSeparated: <V extends Value>(parseValue: CSSParser<V>, lower?: number, upper?: number) => CSSParser<List<V>>;
    const parseSpaceSeparated: <V extends Value>(parseValue: CSSParser<V>, lower?: number, upper?: number) => CSSParser<List<V>>;
}
//# sourceMappingURL=list.d.ts.map