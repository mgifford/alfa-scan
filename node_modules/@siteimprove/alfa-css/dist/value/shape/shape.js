import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Selective } from "@siteimprove/alfa-selective";
import { Value } from "../value.js";
import { Token } from "../../syntax/index.js";
import { Box } from "../box.js";
import { Keyword } from "../textual/keyword.js";
import { Circle } from "./circle.js";
import { Inset } from "./inset.js";
import { Rectangle } from "./rectangle.js";
import { Ellipse } from "./ellipse.js";
import { Polygon } from "./polygon.js";
const { either } = Parser;
/**
 * @public
 */
export class Shape extends Value {
    static of(shape, box) {
        return new Shape(shape, box);
    }
    _shape;
    _box;
    constructor(shape, box) {
        super("shape", Value.hasCalculation(shape));
        this._shape = shape;
        this._box = box;
    }
    get shape() {
        return this._shape;
    }
    get box() {
        return this._box;
    }
    resolve(resolver) {
        return new Shape(this._shape.resolve(resolver), this._box);
    }
    partiallyResolve(resolver) {
        return Shape.of(Shape.Basic.partiallyResolve(resolver)(this._shape), this._box);
    }
    equals(value) {
        return (value instanceof Shape &&
            value._shape.equals(this._shape) &&
            value._box.equals(this._box));
    }
    hash(hash) {
        hash.writeHashable(this._shape).writeHashable(this._box);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            shape: this._shape.toJSON(),
            box: this._box.toJSON(),
        };
    }
    toString() {
        return `${this._shape.toString()} ${this._box.toString()}`;
    }
}
/**
 * @public
 */
(function (Shape) {
    let Basic;
    (function (Basic) {
        function partiallyResolve(resolver) {
            return (value) => Selective.of(value)
                .if(Rectangle.isRectangle, (rectangle) => rectangle.resolve(resolver))
                .else((value) => value.partiallyResolve(resolver))
                .get();
        }
        Basic.partiallyResolve = partiallyResolve;
        /**
         * @remarks
         * This does not parse the deprecated `rect()` shape.
         *
         * @internal
         */
        Basic.parse = either(Circle.parse, Ellipse.parse, Inset.parse, Polygon.parse);
    })(Basic = Shape.Basic || (Shape.Basic = {}));
    /**
     * @remarks
     * This does not parse the deprecated `rect()` shape.
     */
    Shape.parse = (input) => {
        let shape;
        let box;
        const skipWhitespace = () => {
            for (const [remainder] of Token.parseWhitespace(input)) {
                input = remainder;
            }
        };
        while (true) {
            skipWhitespace();
            if (shape === undefined) {
                const result = Basic.parse(input);
                if (result.isOk()) {
                    [input, shape] = result.get();
                    continue;
                }
            }
            if (box === undefined) {
                const result = Box.parseGeometry(input);
                if (result.isOk()) {
                    [input, box] = result.get();
                    continue;
                }
            }
            break;
        }
        // Even though `<geometry-box>` alone is accepted by the specs, it seems to
        // have no browser support.
        if (shape === undefined) {
            return Err.of("Expected a shape");
        }
        return Result.of([input, Shape.of(shape, box ?? Keyword.of("border-box"))]);
    };
})(Shape || (Shape = {}));
//# sourceMappingURL=shape.js.map