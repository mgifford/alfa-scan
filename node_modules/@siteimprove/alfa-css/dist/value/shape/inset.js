import { Array } from "@siteimprove/alfa-array";
import { Parser } from "@siteimprove/alfa-parser";
import { Function, Token, } from "../../syntax/index.js";
import { Keyword } from "../textual/keyword.js";
import { LengthPercentage } from "../numeric/index.js";
import { Value } from "../value.js";
import { BasicShape } from "./basic-shape.js";
import { Corner } from "./corner.js";
const { delimited, filter, map, option, pair, right, separatedList } = Parser;
const { parseDelim, parseWhitespace } = Token;
/**
 * {@link https://drafts.csswg.org/css-shapes/#funcdef-inset}
 *
 * @public
 */
export class Inset extends BasicShape {
    static of(offsets, corners) {
        return new Inset(offsets, corners);
    }
    _offsets;
    _corners;
    constructor(offsets, corners) {
        super("inset", (Value.hasCalculation(...offsets) ||
            corners.some((corners) => corners.some(Corner.hasCalculation))));
        this._offsets = offsets;
        this._corners = corners;
    }
    get offsets() {
        return this._offsets;
    }
    get corners() {
        return this._corners;
    }
    get top() {
        return this._offsets[0];
    }
    get right() {
        return this._offsets[1];
    }
    get bottom() {
        return this._offsets[2];
    }
    get left() {
        return this._offsets[3];
    }
    get topLeft() {
        return this._corners.map((corners) => corners[0]);
    }
    get topRight() {
        return this._corners.map((corners) => corners[1]);
    }
    get bottomRight() {
        return this._corners.map((corners) => corners[2]);
    }
    get bottomLeft() {
        return this._corners.map((corners) => corners[3]);
    }
    resolve(resolver) {
        // map is losing the length of the arrays
        return new Inset(this._offsets.map(LengthPercentage.resolve(resolver)), this._corners.map((corners) => corners.map(Corner.resolve(resolver))));
    }
    partiallyResolve(resolver) {
        return new Inset(this._offsets.map(LengthPercentage.partiallyResolve(resolver)), this._corners.map((corners) => corners.map(Corner.partiallyResolve(resolver))));
    }
    equals(value) {
        return (value instanceof Inset &&
            Array.equals(value._offsets, this._offsets) &&
            value._corners.equals(this._corners));
    }
    hash(hash) {
        Array.hash(this._offsets, hash);
        hash.writeHashable(this._corners);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            offsets: Array.toJSON(this._offsets),
            corners: this._corners.toJSON(),
        };
    }
    toString() {
        const result = `ellipse(${this.top} ${this.right} ${this.bottom} ${this.left}`;
        for (const corners of this._corners) {
            // If at least one corner has both horizontal and vertical radius, we need
            // to split things.
            if (corners.some((corner) => Array.isArray(corner))) {
                const [tlh, tlv] = Array.isArray(this.topLeft)
                    ? this.topLeft
                    : [this.topLeft, this.topLeft];
                const [trh, trv] = Array.isArray(this.topRight)
                    ? this.topRight
                    : [this.topRight, this.topRight];
                const [brh, brv] = Array.isArray(this.bottomRight)
                    ? this.bottomRight
                    : [this.bottomRight, this.bottomRight];
                const [blh, blv] = Array.isArray(this.bottomLeft)
                    ? this.bottomLeft
                    : [this.bottomLeft, this.bottomLeft];
                return (result + `${tlh} ${trh} ${brh} ${blh} / ${tlv} ${trv} ${brv} ${blv})`);
            }
            else {
                return (result +
                    `${this.topLeft} ${this.topRight} ${this.bottomRight} ${this.bottomLeft})`);
            }
        }
        return result + ")";
    }
}
/**
 * @public
 */
(function (Inset) {
    function isInset(value) {
        return value instanceof Inset;
    }
    Inset.isInset = isInset;
    const parseOffsets = map(separatedList(LengthPercentage.parse, option(parseWhitespace), 1, 4), ([top, right = top, bottom = top, left = right]) => [top, right, bottom, left]);
    const parseRadius = filter(LengthPercentage.parse, 
    // https://drafts.csswg.org/css-values/#calc-range
    (value) => value.hasCalculation() || value.value >= 0, () => "Radius cannot be negative");
    const parseRadii = map(separatedList(parseRadius, option(parseWhitespace), 1, 4), ([topLeft, topRight = topLeft, bottomRight = topLeft, bottomLeft = topRight,]) => [topLeft, topRight, bottomRight, bottomLeft]);
    const parseCorners = map(pair(parseRadii, option(right(delimited(option(parseWhitespace), parseDelim("/")), parseRadii))), ([horizontal, vertical]) => vertical
        .map((vertical) => [
        [horizontal[0], vertical[0]],
        [horizontal[1], vertical[1]],
        [horizontal[2], vertical[2]],
        [horizontal[3], vertical[3]],
    ])
        .getOr(horizontal));
    Inset.parse = map(Function.parse("inset", pair(parseOffsets, option(right(option(Token.parseWhitespace), right(Keyword.parse("round"), right(Token.parseWhitespace, parseCorners)))))), ([_, [offsets, corners]]) => Inset.of(offsets, corners));
})(Inset || (Inset = {}));
//# sourceMappingURL=inset.js.map