import { Parser } from "@siteimprove/alfa-parser";
import { Math } from "../../calculation/index.js";
import * as Base from "../../calculation/numeric/index.js";
import {} from "../../syntax/index.js";
import { Dimension } from "./dimension.js";
import { Angle } from "./angle.js";
import { Length } from "./length.js";
import { Percentage } from "./percentage.js";
const { either, map } = Parser;
/**
 * @public
 */
export var AnglePercentage;
(function (AnglePercentage) {
    /**
     * Angle-percentages that are the result of a calculation.
     */
    class Calculated extends Dimension.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(math) {
            super(math, "angle-percentage");
        }
        hasCalculation() {
            return true;
        }
        resolve(resolver) {
            return Angle.Fixed.of(this._math
                // The math expression resolver is only aware of BasePercentage and
                // thus work with it, but we want to abstract it from further layers,
                // so the resolver here is only aware of Percentage, and we need to
                // translate back and forth.
                .resolve({
                // 100% is always 1 full turn!
                percentage: (value) => Base.Angle.of(360, "deg").scale(value.value),
            })
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not resolve ${this._math} as an angle`));
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
    }
    AnglePercentage.Calculated = Calculated;
    /**
     * Fully resolves an angle-percentage, when a full resolver is provided.
     */
    function resolve(value, resolver) {
        return Percentage.isPercentage(value)
            ? value.resolve({
                percentageBase: Angle.of(360, "deg"),
                ...Length.toExpressionResolver(resolver),
            })
            : value.resolve();
    }
    AnglePercentage.resolve = resolve;
    function isAnglePercentage(value) {
        return (value instanceof Calculated ||
            Angle.isAngle(value) ||
            Percentage.isPercentage(value));
    }
    AnglePercentage.isAnglePercentage = isAnglePercentage;
    function isCalculated(value) {
        return (value instanceof Calculated ||
            Angle.isCalculated(value) ||
            Percentage.isCalculated(value));
    }
    AnglePercentage.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Angle.Fixed;
    }
    AnglePercentage.isFixed = isFixed;
    function isPercentage(value) {
        return value instanceof Percentage.Fixed;
    }
    AnglePercentage.isPercentage = isPercentage;
    function of(value, unit) {
        if (typeof value === "number") {
            if (unit === undefined) {
                return Percentage.of(value);
            }
            else {
                return Angle.of(value, unit);
            }
        }
        if (Base.Angle.isAngle(value)) {
            return Angle.of(value.value, value.unit);
        }
        if (Base.Percentage.isPercentage(value)) {
            return Percentage.of(value.value);
        }
        // value must be a math expression
        if (value.isPercentage()) {
            return Percentage.of(value);
        }
        if (value.isDimension("angle")) {
            return Angle.of(value);
        }
        return Calculated.of(value);
    }
    AnglePercentage.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#angles}
     */
    AnglePercentage.parse = either(Angle.parse, (Percentage.parse), map(Math.parseAnglePercentage, of));
})(AnglePercentage || (AnglePercentage = {}));
//# sourceMappingURL=angle-percentage.js.map