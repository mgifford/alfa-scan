import { Math } from "../../calculation/index.js";
import * as Base from "../../calculation/numeric/index.js";
import { type Parser as CSSParser } from "../../syntax/index.js";
import type { Unit } from "../../unit/index.js";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Dimension } from "./dimension.js";
import { Length } from "./length.js";
import type { Numeric } from "./numeric.js";
import { Percentage } from "./percentage.js";
/**
 * @public
 */
export type LengthPercentage<U extends Unit.Length = Unit.Length> = LengthPercentage.Calculated | Length.Calculated | Length.Fixed<U> | Percentage.Calculated<"length"> | Percentage.Fixed<"length">;
/**
 * @public
 */
export declare namespace LengthPercentage {
    type Canonical = Length.Canonical;
    /**
     * Some percentages are resolved against boxes dimensions which we do not
     * always have access to at compute time.
     */
    type PartiallyResolved = Canonical | Percentage.PartiallyResolved<"length"> | LengthPercentage.Calculated;
    /**
     * Length-percentages that are the result of a calculation.
     */
    class Calculated extends Dimension.Calculated<"length-percentage"> implements Resolvable<Length.Canonical, Resolver>, PartiallyResolvable<Calculated, PartialResolver> {
        static of(value: Math<"length-percentage">): Calculated;
        protected constructor(math: Math<"length-percentage">);
        hasCalculation(): this is Calculated;
        resolve(resolver: Resolver & Numeric.GenericResolver): Canonical;
        partiallyResolve(resolver: PartialResolver): this;
        equals(value: unknown): value is this;
    }
    namespace Calculated {
        interface JSON extends Dimension.Calculated.JSON<"length-percentage"> {
        }
    }
    type JSON = Calculated.JSON | Length.Calculated.JSON | Length.Fixed.JSON | Percentage.Calculated.JSON | Percentage.Fixed.JSON;
    type Resolver = Length.Resolver & Percentage.Resolver<"length">;
    type PartialResolver = Length.Resolver;
    /**
     * Fully resolves a length-percentage, when a full resolver is provided.
     */
    function resolve(resolver: Resolver & Numeric.GenericResolver): (value: LengthPercentage) => Canonical;
    /**
     * Partially resolves a length-percentage, when only a length resolver is
     * provided.
     *
     * @remarks
     * For many style properties, the percentages are resolved depending on the
     * dimensions of the box, which we do not always have. In this case, we
     * cannot resolve the percentage parts, but we can still fully resolve the
     * length parts. Calculated percentages cannot be fully resolved into a
     * canonical length, but we can nonetheless reduce them to a pure percentage.
     * However, mixed calculations have to stay as they are.
     */
    function partiallyResolve(resolver: PartialResolver): (value: LengthPercentage) => PartiallyResolved;
    function isLengthPercentage(value: unknown): value is LengthPercentage;
    function isCalculated(value: unknown): value is Calculated | Length.Calculated | Percentage.Calculated;
    function isFixed(value: unknown): value is Length.Fixed;
    function isPercentage(value: unknown): value is Percentage.Fixed;
    function of<U extends Unit.Length>(value: number, unit: U): Length.Fixed<U>;
    function of<U extends Unit.Length>(value: Base.Length<U>): Length.Fixed<U>;
    function of(value: number): Percentage.Fixed;
    function of(value: Base.Percentage): Percentage.Fixed;
    function of(value: Math<"length">): Length.Calculated;
    function of(value: Math<"length-percentage">): Calculated;
    function of(value: Math<"percentage">): Percentage.Calculated;
    /**
     * {@link https://drafts.csswg.org/css-values/#lengths}
     */
    const parse: CSSParser<LengthPercentage>;
}
//# sourceMappingURL=length-percentage.d.ts.map