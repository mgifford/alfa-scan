import type { Comparison } from "@siteimprove/alfa-comparable";
import { Comparable } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Math } from "../../calculation/index.js";
import { Numeric as BaseNumeric } from "../../calculation/numeric/index.js";
import type { Resolvable } from "../resolvable.js";
import { Value } from "../value.js";
import type { Length } from "./length.js";
/**
 * @public
 */
export type Numeric<T extends Numeric.Type = Numeric.Type> = Numeric.Calculated<T> | Numeric.Fixed<T>;
/**
 * @public
 */
export declare namespace Numeric {
    /**
     * @internal
     */
    type ToMath<T extends Type> = Math<T extends BaseNumeric.Scalar ? "number" : T>;
    /**
     * Numerics that are the result of a calculation.
     */
    abstract class Calculated<T extends Type = Type, R extends Type = T, PR extends Type = R> extends Value<T, true, R, PR> implements Resolvable<Fixed<R>, never> {
        protected readonly _math: ToMath<T>;
        protected constructor(math: ToMath<T>, type: T);
        get math(): ToMath<T>;
        hasCalculation(): this is Calculated<T, R, PR>;
        abstract resolve(resolver?: GenericResolver): Fixed<R>;
        equals(value: unknown): value is this;
        hash(hash: Hash): void;
        toJSON(): Calculated.JSON<T>;
        toString(): string;
    }
    /**
     * @public
     */
    namespace Calculated {
        interface JSON<T extends Type = Type> extends Value.JSON<T> {
            math: Serializable.ToJSON<ToMath<T>>;
        }
    }
    /**
     * Numerics that are a fixed (not calculated) value.
     */
    abstract class Fixed<T extends Type = Type, R extends Type = T, PR extends Type = R> extends Value<T, false, R, PR> implements Resolvable<Fixed<R>, never>, Comparable<Fixed> {
        protected readonly _value: number;
        protected constructor(value: number, type: T);
        get value(): number;
        abstract scale(factor: number): Fixed<T, R>;
        hasCalculation(): this is never;
        abstract resolve(resolver?: unknown): Fixed<R>;
        isZero(): boolean;
        /**
         * @internal
         */
        abstract toBase(): T extends Exclude<Type, `${string}-percentage`> ? BaseNumeric<T> : never;
        equals(value: unknown): value is this;
        compare(value: Fixed<T>): Comparison;
        hash(hash: Hash): void;
        toJSON(): Fixed.JSON<T>;
        toString(): string;
    }
    /**
     * @public
     */
    namespace Fixed {
        interface JSON<T extends Type = Type> extends Value.JSON<T> {
            value: number;
        }
    }
    type Type = BaseNumeric.Type | `${BaseNumeric.Dimension}-percentage`;
    /**
     * A length resolver may be needed even for non-length calculation due to
     * division cancelling units.
     *
     * @internal
     */
    type GenericResolver = Partial<Length.Resolver>;
    function isCalculated(value: unknown): value is Calculated;
    function isFixed(value: unknown): value is Fixed;
    function isNumeric(value: unknown): value is Numeric;
    function isZero(value: Fixed): boolean;
}
//# sourceMappingURL=numeric.d.ts.map