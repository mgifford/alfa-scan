import type { Comparison } from "@siteimprove/alfa-comparable";
import { Comparable } from "@siteimprove/alfa-comparable";
import type { Hash } from "@siteimprove/alfa-hash";
import type { Dimension as BaseDimension, Numeric as BaseNumeric } from "../../calculation/numeric/index.js";
import { type Convertible, Unit } from "../../unit/index.js";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Numeric } from "./numeric.js";
/**
 * @public
 */
export declare namespace Dimension {
    /**
     * Dimensions that are the result of a calculation.
     */
    abstract class Calculated<T extends Type = Type, PR extends Type = T> extends Numeric.Calculated<T, ToBase[T], PR> implements Resolvable<Fixed<ToBase[T], ToCanonicalUnit[ToBase[T]]>, unknown>, PartiallyResolvable<any, any> {
        protected constructor(math: Numeric.ToMath<T>, type: T);
        hasCalculation(): this is Calculated<T, PR>;
        abstract resolve(resolver?: unknown): Fixed<ToBase[T], ToCanonicalUnit[ToBase[T]]>;
        equals(value: unknown): value is this;
    }
    namespace Calculated {
        interface JSON<T extends Type = Type> extends Numeric.Calculated.JSON<T> {
        }
    }
    /**
     * Dimensions that are a fixed (not calculated) value.
     */
    abstract class Fixed<T extends BaseNumeric.Dimension = BaseNumeric.Dimension, U extends BaseDimension.ToUnit[T] = BaseDimension.ToUnit[T]> extends Numeric.Fixed<T> implements Resolvable<Fixed<T, ToCanonicalUnit[T]>, unknown>, Convertible<BaseDimension.ToUnit[T]>, Comparable<Fixed<T>> {
        protected readonly _unit: U;
        protected constructor(value: number, unit: U, type: T);
        get unit(): U;
        hasCalculation(): this is never;
        /**
         * {@link https://drafts.csswg.org/css-values/#canonical-unit}
         */
        get canonicalUnit(): ToCanonicalUnit[T];
        abstract hasUnit<V extends BaseDimension.ToUnit[T]>(unit: V): this is Fixed<T, V>;
        abstract withUnit<V extends BaseDimension.ToUnit[T]>(unit: V): Fixed<T, V>;
        abstract resolve(resolver?: unknown): Fixed<T, ToCanonicalUnit[T]>;
        equals(value: unknown): value is this;
        compare(value: Fixed<T>): Comparison;
        hash(hash: Hash): void;
        toJSON(): Fixed.JSON<T, U>;
        toString(): string;
    }
    namespace Fixed {
        interface JSON<T extends BaseNumeric.Dimension = BaseNumeric.Dimension, U extends BaseDimension.ToUnit[T] = BaseDimension.ToUnit[T]> extends Numeric.Fixed.JSON<T> {
            unit: U;
        }
    }
    function isCalculated(value: unknown): value is Calculated;
    function isFixed(value: unknown): value is Fixed;
    function isDimension(value: unknown): value is Numeric;
}
type Type = BaseNumeric.Dimension | `${BaseNumeric.Dimension}-percentage`;
/**
 * Helper types to turn a dimension or dimension-percentage type into its
 * components:
 */
type ToBase = {
    angle: "angle";
    "angle-percentage": "angle";
    length: "length";
    "length-percentage": "length";
};
type ToCanonicalUnit = {
    angle: Unit.Angle.Canonical;
    length: Unit.Length.Canonical;
};
export {};
//# sourceMappingURL=dimension.d.ts.map