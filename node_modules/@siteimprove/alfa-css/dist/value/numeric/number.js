import { Parser } from "@siteimprove/alfa-parser";
import { Selective } from "@siteimprove/alfa-selective";
import { Math } from "../../calculation/index.js";
import { Number as BaseNumber } from "../../calculation/numeric/index.js";
import {} from "../../syntax/index.js";
import { Length } from "./length.js";
import { Numeric } from "./numeric.js";
const { either, map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#numbers}
 *
 * @public
 */
export var Number;
(function (Number) {
    /**
     * Numbers that are the result of a calculation.
     */
    class Calculated extends Numeric.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(value) {
            super(value, "number");
        }
        resolve(resolver) {
            return Fixed.of(this._math
                .resolve(Length.toExpressionResolver(resolver))
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not fully resolve ${this} as a number`));
        }
        partiallyResolve(resolver) {
            return this.resolve(resolver);
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
        toJSON() {
            return super.toJSON();
        }
    }
    Number.Calculated = Calculated;
    /**
     * Numbers that are a fixed (not calculated) value.
     */
    class Fixed extends Numeric.Fixed {
        static of(value) {
            return new Fixed(BaseNumber.isNumber(value) ? value.value : value);
        }
        constructor(value) {
            super(value, "number");
        }
        resolve() {
            return this;
        }
        partiallyResolve() {
            return this;
        }
        scale(factor) {
            return new Fixed(this._value * factor);
        }
        /**
         * @internal
         */
        toBase() {
            return BaseNumber.of(this._value);
        }
        equals(value) {
            return value instanceof Fixed && super.equals(value);
        }
        toJSON() {
            return super.toJSON();
        }
    }
    Number.Fixed = Fixed;
    function isCalculated(value) {
        return value instanceof Calculated;
    }
    Number.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Fixed;
    }
    Number.isFixed = isFixed;
    function isNumber(value) {
        return value instanceof Calculated || value instanceof Fixed;
    }
    Number.isNumber = isNumber;
    function of(value) {
        return Selective.of(value)
            .if(Math.isNumber, Calculated.of)
            .else(Fixed.of)
            .get();
    }
    Number.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#number-value}
     */
    Number.parse = either(map(BaseNumber.parse, of), map(Math.parseNumber, of));
    /**
     * @remarks
     * Zero values must be true 0, not calculations evaluating to 0.
     *
     * {@link https://drafts.csswg.org/css-values/#zero-value}
     */
    Number.parseZero = map(BaseNumber.parseZero, of);
})(Number || (Number = {}));
//# sourceMappingURL=number.js.map