import type { Slice } from "@siteimprove/alfa-slice";
import { type Expression, Math } from "../../calculation/index.js";
import type { Numeric as BaseNumeric } from "../../calculation/numeric/index.js";
import { Percentage as BasePercentage } from "../../calculation/numeric/index.js";
import type { Token } from "../../syntax/index.js";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Angle } from "./angle.js";
import { Integer } from "./integer.js";
import { Length } from "./length.js";
import { Number } from "./number.js";
import { Numeric } from "./numeric.js";
/**
 * {@link https://drafts.csswg.org/css-values/#numbers}
 *
 * @remarks
 * Percentages, even if they do not contain a calc() function, act nearly as
 * calculated value. Given a percentage base (i.e., what is 100%), they can
 * resolve to a numeric value of that type.
 *
 * The Percentage type contains a type hint, H, that indicate into which type
 * this is intended to resolve. This is normally known at parse time (i.e., is
 * it a length?) This is only stored in the type and does not have any effect
 * on the computation.
 *
 * Calculated percentages can be partially resolved in the absence of a base,
 * they are then turned into a Fixed percentage with the same hint.
 *
 * Percentages that represent percentages (e.g., RGB components) are special
 * kids in the sense that their partial and full resolution are the same.
 * This requires resolve() to accept zero argument (no resolver) for them.
 *
 * @public
 */
export type Percentage<H extends BaseNumeric.Type = BaseNumeric.Type> = Percentage.Calculated<H> | Percentage.Fixed<H>;
/**
 * {@link https://drafts.csswg.org/css-values/#numbers}
 *
 * @public
 */
export declare namespace Percentage {
    type Canonical = Fixed<"percentage">;
    type PartiallyResolved<H extends BaseNumeric.Type> = Fixed<H>;
    /**
     * Percentages that are the result of a calculation.
     *
     */
    class Calculated<H extends BaseNumeric.Type = BaseNumeric.Type> extends Numeric.Calculated<"percentage", H, "percentage"> implements Resolvable<Canonicals[H], Resolver<H>>, PartiallyResolvable<PartiallyResolved<H>, PartialResolver> {
        static of<H extends BaseNumeric.Type = BaseNumeric.Type>(value: Math<"percentage">): Calculated<H>;
        protected constructor(math: Math<"percentage">);
        hasCalculation(): this is Calculated<H>;
        resolve(): Fixed<H>;
        resolve<T extends Canonicals[H]>(resolver: Resolver<H> & Numeric.GenericResolver): T;
        partiallyResolve(resolver?: Numeric.GenericResolver): PartiallyResolved<H>;
        equals(value: unknown): value is this;
        toJSON(): Calculated.JSON;
    }
    /**
     * @public
     */
    namespace Calculated {
        interface JSON extends Numeric.Calculated.JSON<"percentage"> {
        }
    }
    /**
     * Percentages that are a fixed (not calculated) value.
     */
    class Fixed<H extends BaseNumeric.Type = BaseNumeric.Type> extends Numeric.Fixed<"percentage", "percentage" | H, "percentage"> implements Resolvable<Canonical | Canonicals[H], Resolver<H>>, PartiallyResolvable<PartiallyResolved<H>, PartialResolver> {
        static of<H extends BaseNumeric.Type = BaseNumeric.Type>(value: number | BasePercentage): Fixed<H>;
        protected constructor(value: number);
        resolve<T extends Canonicals[H]>(resolver: Resolver<H> & Numeric.GenericResolver): T;
        resolve(resolver?: Partial<Resolver<H> & Numeric.GenericResolver>): Canonical;
        partiallyResolve(): PartiallyResolved<H>;
        scale(factor: number): Fixed<H>;
        /**
         * @internal
         */
        toBase(): BasePercentage;
        equals(value: unknown): value is this;
        toJSON(): Fixed.JSON;
        toString(): string;
    }
    /**
     * @public
     */
    namespace Fixed {
        interface JSON extends Numeric.Fixed.JSON<"percentage"> {
        }
    }
    type Resolver<H extends BaseNumeric.Type> = H extends "percentage" ? never : {
        percentageBase: Canonicals[H];
    };
    /**
     * @internal
     */
    function toExpressionResolver<H extends BaseNumeric.Type, B extends BaseNumeric<H>>(resolver: Resolver<H>): Expression.PercentageResolver<B>;
    /**
     * @internal
     */
    function toExpressionResolver(resolver: any): {};
    type PartialResolver = never;
    function isCalculated(value: unknown): value is Calculated;
    function isFixed(value: unknown): value is Fixed;
    function isPercentage(value: unknown): value is Percentage;
    function of<H extends BaseNumeric.Type = BaseNumeric.Type>(value: number): Fixed<H>;
    function of<H extends BaseNumeric.Type = BaseNumeric.Type>(value: BasePercentage): Fixed<H>;
    function of<H extends BaseNumeric.Type = BaseNumeric.Type>(value: Math<"percentage">): Calculated<H>;
    /**
     * {@link https://drafts.csswg.org/css-values/#number-value}
     */
    function parse<H extends BaseNumeric.Type = BaseNumeric.Type>(input: Slice<Token>): import("@siteimprove/alfa-result").Result<[Slice<Token>, Fixed<H> | Calculated<H>], string>;
}
type Canonicals = {
    integer: Integer.Canonical;
    number: Number.Canonical;
    percentage: Percentage.Canonical;
    angle: Angle.Canonical;
    length: Length.Canonical;
};
export {};
//# sourceMappingURL=percentage.d.ts.map