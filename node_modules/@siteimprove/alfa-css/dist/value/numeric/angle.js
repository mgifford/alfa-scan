import { Parser } from "@siteimprove/alfa-parser";
import { Math } from "../../calculation/index.js";
import { Angle as BaseAngle } from "../../calculation/numeric/index.js";
import {} from "../../syntax/index.js";
import { Converter } from "../../unit/index.js";
import { Dimension } from "./dimension.js";
import { Length } from "./length.js";
const { either, map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#numbers}
 *
 * @public
 */
export var Angle;
(function (Angle) {
    /**
     * Angles that are the result of a calculation.
     */
    class Calculated extends Dimension.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(value) {
            super(value, "angle");
        }
        hasCalculation() {
            return true;
        }
        resolve(resolver) {
            return Fixed.of(this._math
                .resolve(Length.toExpressionResolver(resolver))
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not resolve ${this._math} as an angle`));
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
    }
    Angle.Calculated = Calculated;
    /**
     * Angles that are a fixed (not calculated) value.
     */
    class Fixed extends Dimension.Fixed {
        static of(value, unit) {
            if (typeof value === "number") {
                // The overloads ensure that unit is not undefined
                return new Fixed(value, unit);
            }
            return new Fixed(value.value, value.unit);
        }
        constructor(value, unit) {
            super(value, unit, "angle");
        }
        hasCalculation() {
            return false;
        }
        hasUnit(unit) {
            return this._unit === unit;
        }
        withUnit(unit) {
            if (this.hasUnit(unit)) {
                return this;
            }
            return Fixed.of(Converter.angle(this._value, this._unit, unit), unit);
        }
        scale(factor) {
            return new Fixed(this._value * factor, this._unit);
        }
        resolve() {
            return this.withUnit("deg");
        }
        /**
         * @internal
         */
        toBase() {
            return BaseAngle.of(this._value, this._unit);
        }
        equals(value) {
            return value instanceof Fixed && super.equals(value);
        }
    }
    Angle.Fixed = Fixed;
    function isCalculated(value) {
        return value instanceof Calculated;
    }
    Angle.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Fixed;
    }
    Angle.isFixed = isFixed;
    function isAngle(value) {
        return value instanceof Calculated || value instanceof Fixed;
    }
    Angle.isAngle = isAngle;
    function of(value, unit) {
        if (typeof value === "number") {
            // The overloads ensure that unit is not undefined
            return Fixed.of(value, unit);
        }
        if (BaseAngle.isAngle(value)) {
            return Fixed.of(value.value, value.unit);
        }
        return Calculated.of(value);
    }
    Angle.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#number-value}
     */
    Angle.parse = either(map(BaseAngle.parse, of), map(Math.parseAngle, of));
})(Angle || (Angle = {}));
//# sourceMappingURL=angle.js.map