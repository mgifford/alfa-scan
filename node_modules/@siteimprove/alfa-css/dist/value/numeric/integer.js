import { Parser } from "@siteimprove/alfa-parser";
import { Selective } from "@siteimprove/alfa-selective";
// We need to rename Math to avoid collision with the global namespace.
import { Math as Calculation } from "../../calculation/index.js";
import { Integer as BaseInteger } from "../../calculation/numeric/index.js";
import {} from "../../syntax/index.js";
import { Length } from "./length.js";
import { Numeric } from "./numeric.js";
const { either, map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#integers}
 *
 * @public
 */
export var Integer;
(function (Integer) {
    /**
     * Integers that are the result of a calculation.
     */
    class Calculated extends Numeric.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(value) {
            super(value, "integer");
        }
        /**
         * @remarks
         * Numbers are rounded to the nearest integer upon resolving calculation
         *
         * {@link https://drafts.csswg.org/css-values/#calc-type-checking}
         */
        resolve(resolver) {
            return Fixed.of(this._math
                .resolve(Length.toExpressionResolver(resolver))
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not fully resolve ${this} as a number`).value);
        }
        partiallyResolve(resolver) {
            return this.resolve(resolver);
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
        toJSON() {
            return super.toJSON();
        }
    }
    Integer.Calculated = Calculated;
    /**
     * Numbers that are a fixed (not calculated) value.
     */
    class Fixed extends Numeric.Fixed {
        /**
         * {@link https://drafts.csswg.org/css-values/#css-round-to-the-nearest-integer}
         */
        static of(value) {
            return new Fixed(BaseInteger.isInteger(value)
                ? value.value
                : // Math.round ensure the correct rounding.
                    // The bitwise or ensure coercion to 32 bits integer
                    Math.round(value) | 0);
        }
        constructor(value) {
            super(value, "integer");
        }
        resolve() {
            return this;
        }
        partiallyResolve() {
            return this;
        }
        scale(factor) {
            return new Fixed(this._value * factor);
        }
        /**
         * @internal
         */
        toBase() {
            return BaseInteger.of(this._value);
        }
        equals(value) {
            return value instanceof Fixed && super.equals(value);
        }
        hash(hash) {
            hash.writeInt32(this._value);
        }
        toJSON() {
            return super.toJSON();
        }
    }
    Integer.Fixed = Fixed;
    function isCalculated(value) {
        return value instanceof Calculated;
    }
    Integer.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Fixed;
    }
    Integer.isFixed = isFixed;
    function isInteger(value) {
        return value instanceof Calculated || value instanceof Fixed;
    }
    Integer.isInteger = isInteger;
    function of(value) {
        return Selective.of(value)
            .if(Calculation.isNumber, Calculated.of)
            .else(Fixed.of)
            .get();
    }
    Integer.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#number-value}
     */
    Integer.parse = either(map(BaseInteger.parse, of), map(Calculation.parseNumber, of));
})(Integer || (Integer = {}));
//# sourceMappingURL=integer.js.map