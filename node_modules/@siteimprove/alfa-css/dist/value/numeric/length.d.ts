import type { Comparable } from "@siteimprove/alfa-comparable";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { type Expression, Math } from "../../calculation/index.js";
import { Length as BaseLength } from "../../calculation/numeric/index.js";
import { type Parser as CSSParser } from "../../syntax/index.js";
import { Unit } from "../../unit/index.js";
import type { Resolvable } from "../resolvable.js";
import { Dimension } from "./dimension.js";
import type { Numeric } from "./numeric.js";
/**
 * @public
 */
export type Length<U extends Unit.Length = Unit.Length> = Length.Calculated | Length.Fixed<U>;
/**
 * @public
 */
export declare namespace Length {
    type Canonical = Fixed<Unit.Length.Canonical>;
    /**
     * Lengths that are the result of a calculation.
     */
    class Calculated extends Dimension.Calculated<"length"> implements Resolvable<Canonical, Resolver> {
        static of(value: Math<"length">): Calculated;
        protected constructor(math: Math<"length">);
        hasCalculation(): this is Calculated;
        resolve(resolver: Resolver & Numeric.GenericResolver): Canonical;
        equals(value: unknown): value is this;
    }
    namespace Calculated {
        interface JSON extends Dimension.Calculated.JSON<"length"> {
        }
    }
    /**
     * Lengths that are a fixed (not calculated) value.
     */
    class Fixed<U extends Unit.Length = Unit.Length> extends Dimension.Fixed<"length", U> implements Resolvable<Canonical, Resolver>, Comparable<Fixed<U>> {
        static of<U extends Unit.Length>(value: number, unit: U): Fixed<U>;
        static of<U extends Unit.Length>(value: BaseLength<U>): Fixed<U>;
        protected constructor(value: number, unit: U);
        hasCalculation(): this is never;
        hasUnit<U extends Unit.Length>(unit: U): this is Fixed<U>;
        withUnit<U extends Unit.Length>(unit: U): Fixed<U>;
        isRelative(): this is Fixed<Unit.Length.Relative>;
        isFontRelative(): this is Fixed<Unit.Length.Relative.Font>;
        isViewportRelative(): this is Fixed<Unit.Length.Relative.Viewport>;
        isAbsolute(): this is Fixed<Unit.Length.Absolute>;
        scale(factor: number): Fixed<U>;
        /**
         * Resolve a Length into an absolute Length in pixels.
         */
        resolve(resolver: Resolver): Canonical;
        /**
         * @internal
         */
        toBase(): BaseLength<U>;
        equals(value: unknown): value is this;
    }
    namespace Fixed {
        interface JSON<U extends Unit.Length = Unit.Length> extends Dimension.Fixed.JSON<"length", U> {
        }
    }
    type JSON = Calculated.JSON | Fixed.JSON;
    interface Resolver {
        length: Mapper<Fixed<Unit.Length.Relative>, Canonical>;
    }
    /**
     * @internal
     */
    function toExpressionResolver(resolver: Resolver): Expression.LengthResolver;
    /**
     * @internal
     */
    function toExpressionResolver(resolver: any): {};
    /**
     * Build a (fixed) length resolver, using basis for the relative units
     */
    function resolver(emBase: Canonical, remBase: Canonical, vwBase: Canonical, vhBase: Canonical): Mapper<Fixed<Unit.Length.Relative>, Canonical>;
    function isLength(value: unknown): value is Length;
    function isCalculated(value: unknown): value is Calculated;
    function isFixed(value: unknown): value is Fixed;
    function of<U extends Unit.Length>(value: number, unit: U): Fixed<U>;
    function of<U extends Unit.Length>(value: BaseLength<U>): Fixed<U>;
    function of(value: Math<"length">): Calculated;
    /**
     * {@link https://drafts.csswg.org/css-values/#lengths}
     */
    const parse: CSSParser<Length>;
}
//# sourceMappingURL=length.d.ts.map