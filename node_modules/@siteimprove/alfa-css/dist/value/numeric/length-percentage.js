import { Parser } from "@siteimprove/alfa-parser";
import { Selective } from "@siteimprove/alfa-selective";
import { Math } from "../../calculation/index.js";
import * as Base from "../../calculation/numeric/index.js";
import {} from "../../syntax/index.js";
import { Dimension } from "./dimension.js";
import { Length } from "./length.js";
import { Percentage } from "./percentage.js";
const { either, map } = Parser;
/**
 * @public
 */
export var LengthPercentage;
(function (LengthPercentage) {
    /**
     * Length-percentages that are the result of a calculation.
     */
    class Calculated extends Dimension.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(math) {
            super(math, "length-percentage");
        }
        hasCalculation() {
            return true;
        }
        resolve(resolver) {
            const resolve = this._math.resolve({
                ...Length.toExpressionResolver(resolver),
                ...Percentage.toExpressionResolver(resolver),
            });
            return Length.Fixed.of(resolve
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not resolve ${this._math} as a length`));
        }
        partiallyResolve(resolver) {
            return this;
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
    }
    LengthPercentage.Calculated = Calculated;
    /**
     * Fully resolves a length-percentage, when a full resolver is provided.
     */
    function resolve(resolver) {
        return (value) => {
            // We need to break down the union to help TS find the correct overload
            // of each component and correctly narrow the result.
            return Percentage.isPercentage(value)
                ? value.resolve(resolver)
                : value.resolve(resolver);
        };
    }
    LengthPercentage.resolve = resolve;
    /**
     * Partially resolves a length-percentage, when only a length resolver is
     * provided.
     *
     * @remarks
     * For many style properties, the percentages are resolved depending on the
     * dimensions of the box, which we do not always have. In this case, we
     * cannot resolve the percentage parts, but we can still fully resolve the
     * length parts. Calculated percentages cannot be fully resolved into a
     * canonical length, but we can nonetheless reduce them to a pure percentage.
     * However, mixed calculations have to stay as they are.
     */
    function partiallyResolve(resolver) {
        return (value) => Selective.of(value)
            .if(Length.isLength, (value) => value.resolve(resolver))
            .if(Percentage.isPercentage, (value) => value.partiallyResolve())
            .get();
    }
    LengthPercentage.partiallyResolve = partiallyResolve;
    function isLengthPercentage(value) {
        return (value instanceof Calculated ||
            Length.isLength(value) ||
            Percentage.isPercentage(value));
    }
    LengthPercentage.isLengthPercentage = isLengthPercentage;
    function isCalculated(value) {
        return (value instanceof Calculated ||
            Length.isCalculated(value) ||
            Percentage.isCalculated(value));
    }
    LengthPercentage.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Length.Fixed;
    }
    LengthPercentage.isFixed = isFixed;
    function isPercentage(value) {
        return value instanceof Percentage.Fixed;
    }
    LengthPercentage.isPercentage = isPercentage;
    function of(value, unit) {
        if (typeof value === "number") {
            if (unit === undefined) {
                return Percentage.of(value);
            }
            else {
                return Length.of(value, unit);
            }
        }
        if (Base.Length.isLength(value)) {
            return Length.of(value.value, value.unit);
        }
        if (Base.Percentage.isPercentage(value)) {
            return Percentage.of(value.value);
        }
        // value must be a math expression
        if (value.isPercentage()) {
            return Percentage.of(value);
        }
        if (value.isDimension("length")) {
            return Length.of(value);
        }
        return Calculated.of(value);
    }
    LengthPercentage.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#lengths}
     */
    LengthPercentage.parse = either(Length.parse, (Percentage.parse), map(Math.parseLengthPercentage, of));
})(LengthPercentage || (LengthPercentage = {}));
//# sourceMappingURL=length-percentage.js.map