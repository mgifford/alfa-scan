import { Parser } from "@siteimprove/alfa-parser";
import { Selective } from "@siteimprove/alfa-selective";
import { Math } from "../../calculation/index.js";
import { Angle as BaseAngle, Integer as BaseInteger, Length as BaseLength, Number as BaseNumber, Percentage as BasePercentage, } from "../../calculation/numeric/index.js";
import { Angle } from "./angle.js";
import { Integer } from "./integer.js";
import { Length } from "./length.js";
import { Number } from "./number.js";
import { Numeric } from "./numeric.js";
const { either, map } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#numbers}
 *
 * @public
 */
export var Percentage;
(function (Percentage) {
    /**
     * Percentages that are the result of a calculation.
     *
     */
    class Calculated extends Numeric.Calculated {
        static of(value) {
            return new Calculated(value);
        }
        constructor(math) {
            super(math, "percentage");
        }
        hasCalculation() {
            return true;
        }
        resolve(resolver) {
            if (resolver === undefined) {
                return Fixed.of(this._math
                    .resolve()
                    // Since the expression has been correctly typed, it should always resolve.
                    .getUnsafe(`Could not fully resolve ${this} as a percentage`));
            }
            return Selective.of(this._math
                .resolve({
                percentage: (value) => value,
                ...toExpressionResolver(resolver),
                ...Length.toExpressionResolver(resolver),
            })
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not fully resolve ${this} as a percentage`))
                .if(BaseAngle.isAngle, Angle.Fixed.of)
                .if(BaseInteger.isInteger, Integer.Fixed.of)
                .if(BaseLength.isLength, Length.Fixed.of)
                .if(BaseNumber.isNumber, Number.Fixed.of)
                .else((value) => Fixed.of(value))
                .get();
        }
        partiallyResolve(resolver) {
            return Fixed.of(this._math
                .resolve({
                percentage: (value) => value,
                ...Length.toExpressionResolver(resolver),
            })
                // Since the expression has been correctly typed, it should always resolve.
                .getUnsafe(`Could not resolve ${this} as a percentage`));
        }
        equals(value) {
            return value instanceof Calculated && super.equals(value);
        }
        toJSON() {
            return super.toJSON();
        }
    }
    Percentage.Calculated = Calculated;
    /**
     * Percentages that are a fixed (not calculated) value.
     */
    class Fixed extends Numeric.Fixed {
        static of(value) {
            return new Fixed(BasePercentage.isPercentage(value) ? value.value : value);
        }
        constructor(value) {
            super(value, "percentage");
        }
        resolve(resolver) {
            return resolver?.percentageBase === undefined
                ? this
                : // since we don't know much about percentageBase, scale defaults to
                    // the abstract one on Numeric and loses its actual type which needs
                    // to be asserted again.
                    resolver.percentageBase.scale(this._value);
        }
        partiallyResolve() {
            return this;
        }
        scale(factor) {
            return new Fixed(this._value * factor);
        }
        /**
         * @internal
         */
        toBase() {
            return BasePercentage.of(this._value);
        }
        equals(value) {
            return value instanceof Fixed && super.equals(value);
        }
        toJSON() {
            return super.toJSON();
        }
        toString() {
            return `${this._value * 100}%`;
        }
    }
    Percentage.Fixed = Fixed;
    /**
     * @internal
     */
    function toExpressionResolver(resolver) {
        return resolver?.percentageBase === undefined
            ? {}
            : {
                percentage: (value) => resolver.percentageBase.toBase().scale(value.value),
            };
    }
    Percentage.toExpressionResolver = toExpressionResolver;
    function isCalculated(value) {
        return value instanceof Calculated;
    }
    Percentage.isCalculated = isCalculated;
    function isFixed(value) {
        return value instanceof Fixed;
    }
    Percentage.isFixed = isFixed;
    function isPercentage(value) {
        return value instanceof Calculated || value instanceof Fixed;
    }
    Percentage.isPercentage = isPercentage;
    function of(value) {
        return Selective.of(value)
            .if(Math.isPercentage, (Calculated.of))
            .else((Fixed.of))
            .get();
    }
    Percentage.of = of;
    /**
     * {@link https://drafts.csswg.org/css-values/#number-value}
     */
    function parse(input) {
        return either(map(BasePercentage.parse, (of)), map(Math.parsePercentage, (of)))(input);
    }
    Percentage.parse = parse;
})(Percentage || (Percentage = {}));
//# sourceMappingURL=percentage.js.map