import type { Hash } from "@siteimprove/alfa-hash";
import { type Parser as CSSParser } from "../../syntax/index.js";
import type { Length } from "../numeric/index.js";
import type { PartiallyResolvable, Resolvable } from "../resolvable.js";
import { Value } from "../value.js";
import * as component from "./component.js";
import * as keywords from "./keywords.js";
import * as side from "./side.js";
/**
 * {@link https://drafts.csswg.org/css-values/#position}
 *
 * @remarks
 * A Position has a horizontal and a vertical component, corresponding to some
 * coordinates. Each component can either be an offset (implicitly from the
 * "start" side (left or top, usually)), or the keyword "center", or a Side
 * (i.e. an explicit side with an optional offset).
 *
 * @public
 */
export declare class Position<H extends Position.Keywords.Horizontal = Position.Keywords.Horizontal, V extends Position.Keywords.Vertical = Position.Keywords.Vertical, HC extends Position.Component<H> = Position.Component<H>, VC extends Position.Component<V> = Position.Component<V>> extends Value<"position", Value.HasCalculation<[HC, VC]>> implements Resolvable<Position.Canonical<H, V>, Position.Resolver>, PartiallyResolvable<Position.PartiallyResolved<H, V>, Position.PartialResolver> {
    static of<H extends Position.Keywords.Horizontal = Position.Keywords.Horizontal, V extends Position.Keywords.Vertical = Position.Keywords.Vertical, HC extends Position.Component<H> = Position.Component<H>, VC extends Position.Component<V> = Position.Component<V>>(horizontal: HC, vertical: VC): Position<H, V, HC, VC>;
    private readonly _horizontal;
    private readonly _vertical;
    protected constructor(horizontal: HC, vertical: VC);
    get horizontal(): HC;
    get vertical(): VC;
    resolve(resolver: Position.Resolver): Position.Canonical<H, V>;
    partiallyResolve(resolver: Position.PartialResolver): Position.PartiallyResolved<H, V>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(): Position.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Position {
    type Canonical<H extends Keywords.Horizontal = Keywords.Horizontal, V extends Keywords.Vertical = Keywords.Vertical> = Position<H, V, Component.Canonical<H>, Component.Canonical<V>>;
    type PartiallyResolved<H extends Keywords.Horizontal = Keywords.Horizontal, V extends Keywords.Vertical = Keywords.Vertical> = Position<H, V, Component.PartiallyResolved<H>, Component.PartiallyResolved<V>>;
    interface JSON extends Value.JSON<"position"> {
        horizontal: Component.JSON;
        vertical: Component.JSON;
    }
    export import Keywords = keywords.Keywords;
    export import Side = side.Side;
    export import Component = component.Component;
    /**
     * Percentages are not resolved against the same base in both dimensions.
     */
    interface Resolver extends Length.Resolver {
        percentageHBase: Length.Canonical;
        percentageVBase: Length.Canonical;
    }
    type PartialResolver = Component.PartialResolver;
    /**
     * Parse a position, optionally accepting legacy 3-values syntax.
     *
     * {@link https://drafts.csswg.org/css-values/#typedef-position}
     * {@link https://drafts.csswg.org/css-backgrounds/#typedef-bg-position}
     *
     * @privateRemarks
     * The parsers must be tested in decreasing number of tokens.
     */
    function parse(legacySyntax?: boolean): CSSParser<Position>;
}
//# sourceMappingURL=position.d.ts.map