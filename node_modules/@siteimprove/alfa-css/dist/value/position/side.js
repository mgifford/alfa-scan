import { Option } from "@siteimprove/alfa-option";
import { Parser } from "@siteimprove/alfa-parser";
import { Token } from "../../syntax/index.js";
import { LengthPercentage } from "../numeric/index.js";
import { Value } from "../value.js";
import { Keywords } from "./keywords.js";
const { either, map, pair, right } = Parser;
/**
 * @public
 */
export class Side extends Value {
    static of(side, offset) {
        return new Side(side, Option.isOption(offset) ? offset : Option.from(offset));
    }
    _side;
    _offset;
    constructor(side, offset) {
        super("side", offset.some(Value.hasCalculation));
        this._side = side;
        this._offset = offset;
    }
    get side() {
        return this._side;
    }
    get offset() {
        return this._offset;
    }
    resolve(resolver) {
        return new Side(this._side, this._offset.map(LengthPercentage.resolve(resolver)));
    }
    partiallyResolve(resolver) {
        return new Side(this._side, this._offset.map(LengthPercentage.partiallyResolve(resolver)));
    }
    equals(value) {
        return (value instanceof Side &&
            value._side.equals(this._side) &&
            value._offset.equals(this._offset));
    }
    hash(hash) {
        hash.writeHashable(this._side).writeHashable(this._offset);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            side: this._side.toJSON(),
            offset: this._offset.map((offset) => offset.toJSON()).getOr(null),
        };
    }
    toString() {
        return `${this._side}${this._offset
            .map((offset) => ` ${offset}`)
            .getOr("")}`;
    }
}
/**
 * @public
 */
(function (Side) {
    function isSide(value) {
        return value instanceof Side;
    }
    Side.isSide = isSide;
    /**
     * Parse a side keyword (top/bottom/left/right) or "center"
     */
    function parseKeyword(parser) {
        return either(Keywords.parseCenter, map(parser, (side) => Side.of(side)));
    }
    /**
     * Parse a side keyword followed by an offset (length-percentage).
     */
    function parseKeywordValue(parser) {
        return map(pair(parser, right(Token.parseWhitespace, LengthPercentage.parse)), ([keyword, value]) => Side.of(keyword, value));
    }
    Side.parseHorizontalKeywordValue = parseKeywordValue(Keywords.parseHorizontal);
    Side.parseHorizontalKeyword = parseKeyword(Keywords.parseHorizontal);
    Side.parseHorizontal = either(Side.parseHorizontalKeyword, Side.parseHorizontalKeywordValue);
    Side.parseVerticalKeywordValue = parseKeywordValue(Keywords.parseVertical);
    Side.parseVerticalKeyword = parseKeyword(Keywords.parseVertical);
    Side.parseVertical = either(Side.parseVerticalKeyword, Side.parseVerticalKeywordValue);
})(Side || (Side = {}));
//# sourceMappingURL=side.js.map