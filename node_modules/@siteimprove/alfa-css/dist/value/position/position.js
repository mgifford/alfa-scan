import { Parser } from "@siteimprove/alfa-parser";
import { Err } from "@siteimprove/alfa-result";
import { Token } from "../../syntax/index.js";
import { Keyword } from "../textual/keyword.js";
import { Value } from "../value.js";
import * as component from "./component.js";
import * as keywords from "./keywords.js";
import * as side from "./side.js";
const { map, either, pair, right } = Parser;
/**
 * {@link https://drafts.csswg.org/css-values/#position}
 *
 * @remarks
 * A Position has a horizontal and a vertical component, corresponding to some
 * coordinates. Each component can either be an offset (implicitly from the
 * "start" side (left or top, usually)), or the keyword "center", or a Side
 * (i.e. an explicit side with an optional offset).
 *
 * @public
 */
export class Position extends Value {
    static of(horizontal, vertical) {
        return new Position(horizontal, vertical);
    }
    _horizontal;
    _vertical;
    constructor(horizontal, vertical) {
        super("position", Value.hasCalculation(horizontal, vertical));
        this._horizontal = horizontal;
        this._vertical = vertical;
    }
    get horizontal() {
        return this._horizontal;
    }
    get vertical() {
        return this._vertical;
    }
    resolve(resolver) {
        return new Position(Position.Component.resolve({
            length: resolver.length,
            percentageBase: resolver.percentageHBase,
        })(this._horizontal), Position.Component.resolve({
            length: resolver.length,
            percentageBase: resolver.percentageVBase,
        })(this._vertical));
    }
    partiallyResolve(resolver) {
        return new Position(Position.Component.partiallyResolve(resolver)(this._horizontal), Position.Component.partiallyResolve(resolver)(this._vertical));
    }
    equals(value) {
        return (value instanceof Position &&
            value._horizontal.equals(this._horizontal) &&
            value._vertical.equals(this._vertical));
    }
    hash(hash) {
        hash.writeHashable(this._horizontal).writeHashable(this._vertical);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            horizontal: this._horizontal.toJSON(),
            vertical: this._vertical.toJSON(),
        };
    }
    toString() {
        return `${this._horizontal} ${this._vertical}`;
    }
}
/**
 * @public
 */
(function (Position) {
    Position.Keywords = keywords.Keywords;
    Position.Side = side.Side;
    Position.Component = component.Component;
    /**
     * @remarks
     * Positions can be declared using either 1, 2, 3, or 4 tokens with the
     * longest possible match taking precedence. The 3-token syntax is deprecated
     * and must be selectively enabled.
     *
     * It is not easy to reuse component parsing here because, for example,
     * H v would be incorrectly parsed as Hh by the horizontal component parser,
     * so we need parsing error recovery to happen globally.
     * Moreover, the parsers must be tested in decreasing number of tokens so that
     * the 1 token parser does not eagerly accept something which actually has 4
     * tokens.
     *
     * Notation:
     *
     *   - H/V: keyword: top | bottom | right | left | center
     *   - h/v: numeric: \<length | percentage\>
     *   - Hh/Vv: keyword (excluding center) and numeric
     *
     * Syntax:
     *
     *   - 4 tokens: Hh Vv | Vv Hh
     *   - 3 tokens: Hh V | H Vv | Vv H | V Hh
     *   - 2 tokens: H V | H v | h V | h v | V H   <- Obs! no V h | v H | v h
     *   - 1 token:  H | V | h
     */
    const mapHV = ([horizontal, vertical]) => Position.of(horizontal, vertical);
    const mapVH = ([vertical, horizontal]) => Position.of(horizontal, vertical);
    const { parseHorizontalKeywordValue, parseHorizontalKeyword, parseVerticalKeywordValue, parseVerticalKeyword, } = Position.Side;
    const parse4 = either(map(pair(parseHorizontalKeywordValue, right(Token.parseWhitespace, parseVerticalKeywordValue)), mapHV), map(pair(parseVerticalKeywordValue, right(Token.parseWhitespace, parseHorizontalKeywordValue)), mapVH));
    // Hh V | H Vv | Vv H | V Hh
    const parse3 = either(map(either(pair(parseHorizontalKeywordValue, right(Token.parseWhitespace, parseVerticalKeyword)), pair(parseHorizontalKeyword, right(Token.parseWhitespace, parseVerticalKeywordValue))), mapHV), map(either(pair(parseVerticalKeywordValue, right(Token.parseWhitespace, parseHorizontalKeyword)), pair(parseVerticalKeyword, right(Token.parseWhitespace, parseHorizontalKeywordValue))), mapVH));
    // H V | H v | h V | h v | V H = (H | h) (V | v) | V H
    const parse2 = either(map(pair(either(parseHorizontalKeyword, Position.Component.parseOffset(Keyword.of("left"))), right(Token.parseWhitespace, either(parseVerticalKeyword, Position.Component.parseOffset(Keyword.of("top"))))), mapHV), map(pair(parseVerticalKeyword, right(Token.parseWhitespace, parseHorizontalKeyword)), mapVH));
    // H | V | h
    const parse1 = either(map(parseHorizontalKeyword, (horizontal) => Position.of(horizontal, Keyword.of("center"))), map(parseVerticalKeyword, (vertical) => Position.of(Keyword.of("center"), vertical)), map(Position.Component.parseOffset(Keyword.of("left")), (horizontal) => Position.of(horizontal, Keyword.of("center"))));
    /**
     * Parse a position, optionally accepting legacy 3-values syntax.
     *
     * {@link https://drafts.csswg.org/css-values/#typedef-position}
     * {@link https://drafts.csswg.org/css-backgrounds/#typedef-bg-position}
     *
     * @privateRemarks
     * The parsers must be tested in decreasing number of tokens.
     */
    function parse(legacySyntax = false) {
        return either(parse4, legacySyntax ? parse3 : () => Err.of("Three-value syntax is not allowed"), parse2, parse1);
    }
    Position.parse = parse;
})(Position || (Position = {}));
//# sourceMappingURL=position.js.map