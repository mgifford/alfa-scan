import { Array } from "@siteimprove/alfa-array";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type * as json from "@siteimprove/alfa-json";
import type { Serializable } from "@siteimprove/alfa-json";
import { Parser } from "@siteimprove/alfa-parser";
import type { Predicate } from "@siteimprove/alfa-predicate";
import { Refinement } from "@siteimprove/alfa-refinement";
import type { Slice } from "@siteimprove/alfa-slice";
import type { Parser as CSSParser } from "./parser.js";
/**
 * @public
 */
export type Token = Token.Ident | Token.Function | Token.AtKeyword | Token.Hash | Token.String | Token.URL | Token.BadURL | Token.Delim | Token.Number | Token.Percentage | Token.Dimension | Token.Whitespace | Token.Colon | Token.Semicolon | Token.Comma | Token.OpenParenthesis | Token.CloseParenthesis | Token.OpenSquareBracket | Token.CloseSquareBracket | Token.OpenCurlyBracket | Token.CloseCurlyBracket | Token.OpenComment | Token.CloseComment;
/**
 * @public
 */
export declare namespace Token {
    type JSON = Ident.JSON | Function.JSON | AtKeyword.JSON | Hash.JSON | String.JSON | URL.JSON | BadURL.JSON | Delim.JSON | Number.JSON | Percentage.JSON | Dimension.JSON | Whitespace.JSON | Colon.JSON | Semicolon.JSON | Comma.JSON | OpenParenthesis.JSON | CloseParenthesis.JSON | OpenSquareBracket.JSON | CloseSquareBracket.JSON | OpenCurlyBracket.JSON | CloseCurlyBracket.JSON | OpenComment.JSON | CloseComment.JSON;
    /**
     * Parses the first token, whatever it is.
     *
     *  @internal
     */
    const parseFirst: CSSParser<Token>;
    function skipUntil(delimiter: CSSParser<unknown>): CSSParser<void>;
    class Ident<N extends string = string> implements Equatable, Serializable<Ident.JSON<N>> {
        static of<N extends string>(value: N): Ident<N>;
        private readonly _value;
        protected constructor(value: N);
        get type(): "ident";
        get value(): N;
        equals(value: unknown): value is this;
        toJSON(): Ident.JSON<N>;
        toString(): string;
    }
    namespace Ident {
        interface JSON<N extends string = string> {
            [key: string]: json.JSON;
            type: "ident";
            value: N;
        }
        function isIdent(value: unknown): value is Ident;
    }
    const ident: typeof Ident.of, isIdent: typeof Ident.isIdent;
    function parseIdent<N extends string>(query: N | Array<N> | Refinement<Ident, Ident<N>>): CSSParser<Ident<N>>;
    function parseIdent(query?: Predicate<Ident>): CSSParser<Ident>;
    class Function<N extends string = string> implements Equatable, Serializable<Function.JSON> {
        static of<N extends string = string>(value: N): Function<N>;
        private readonly _value;
        protected constructor(value: N);
        get type(): "function";
        get value(): N;
        get mirror(): CloseParenthesis;
        equals(value: unknown): value is this;
        toJSON(): Function.JSON<N>;
        toString(): string;
    }
    namespace Function {
        interface JSON<N extends string = string> {
            [key: string]: json.JSON;
            type: "function";
            value: N;
        }
        function isFunction(value: unknown): value is Function;
    }
    const func: typeof Function.of, isFunction: typeof Function.isFunction;
    function parseFunction<N extends string>(query: N | ReadonlyArray<N> | Refinement<Function, Function<N>>): CSSParser<Function<N>>;
    function parseFunction(query?: Predicate<Function>): CSSParser<Function>;
    class AtKeyword implements Equatable, Serializable<AtKeyword.JSON> {
        static of(value: string): AtKeyword;
        private readonly _value;
        protected constructor(value: string);
        get type(): "at-keyword";
        get value(): string;
        equals(value: unknown): value is this;
        toJSON(): AtKeyword.JSON;
        toString(): string;
    }
    namespace AtKeyword {
        interface JSON {
            [key: string]: json.JSON;
            type: "at-keyword";
            value: string;
        }
    }
    const atKeyword: typeof AtKeyword.of;
    class Hash implements Equatable, Serializable<Hash.JSON> {
        static of(value: string, isIdentifier: boolean): Hash;
        private readonly _value;
        private readonly _isIdentifier;
        protected constructor(value: string, isIdentifier: boolean);
        get type(): "hash";
        get value(): string;
        get isIdentifier(): boolean;
        equals(value: unknown): value is this;
        toJSON(): Hash.JSON;
        toString(): string;
    }
    namespace Hash {
        interface JSON {
            [key: string]: json.JSON;
            type: "hash";
            value: string;
            isIdentifier: boolean;
        }
        function isHash(value: unknown): value is Hash;
    }
    const hash: typeof Hash.of, isHash: typeof Hash.isHash;
    function parseHash(predicate?: Predicate<Hash>): CSSParser<Hash>;
    class String implements Equatable, Serializable<String.JSON> {
        static of(value: string): String;
        private readonly _value;
        protected constructor(value: string);
        get type(): "string";
        get value(): string;
        equals(value: unknown): value is this;
        toJSON(): String.JSON;
        toString(): string;
    }
    namespace String {
        interface JSON {
            [key: string]: json.JSON;
            type: "string";
            value: string;
        }
        function isString(value: unknown): value is String;
    }
    const string: typeof String.of, isString: typeof String.isString;
    function parseString(predicate?: Predicate<String>): CSSParser<String>;
    class URL implements Equatable, Serializable<URL.JSON> {
        static of(value: string): URL;
        private readonly _value;
        protected constructor(value: string);
        get type(): "url";
        get value(): string;
        equals(value: unknown): value is this;
        toJSON(): URL.JSON;
        toString(): string;
    }
    namespace URL {
        interface JSON {
            [key: string]: json.JSON;
            type: "url";
            value: string;
        }
        function isURL(value: unknown): value is URL;
    }
    const url: typeof URL.of, isURL: typeof URL.isURL;
    function parseURL(predicate?: Predicate<URL>): CSSParser<URL>;
    class BadURL implements Equatable, Serializable<BadURL.JSON> {
        private static _instance;
        static of(): BadURL;
        private constructor();
        get type(): "bad-url";
        equals(value: unknown): value is this;
        toJSON(): BadURL.JSON;
        toString(): string;
    }
    namespace BadURL {
        interface JSON {
            [key: string]: json.JSON;
            type: "bad-url";
        }
    }
    const badURL: typeof BadURL.of;
    class Delim implements Equatable, Serializable<Delim.JSON> {
        private static _delims;
        static of(value: number): Delim;
        private readonly _value;
        protected constructor(value: number);
        get type(): "delim";
        get value(): number;
        equals(value: unknown): value is this;
        toJSON(): Delim.JSON;
        toString(): string;
    }
    namespace Delim {
        interface JSON {
            [key: string]: json.JSON;
            type: "delim";
            value: number;
        }
        function isDelim(value: unknown): value is Delim;
    }
    const delim: typeof Delim.of, isDelim: typeof Delim.isDelim;
    function parseDelim(query?: string | number | Predicate<Delim>): CSSParser<Delim>;
    class Number implements Equatable, Serializable<Number.JSON> {
        static of(value: number, isInteger: boolean, isSigned: boolean): Number;
        private readonly _value;
        private readonly _isInteger;
        private readonly _isSigned;
        protected constructor(value: number, isInteger: boolean, isSigned: boolean);
        get type(): "number";
        get value(): number;
        get isInteger(): boolean;
        get isSigned(): boolean;
        equals(value: unknown): value is this;
        toJSON(): Number.JSON;
        toString(): string;
    }
    namespace Number {
        interface JSON {
            [key: string]: json.JSON;
            type: "number";
            value: number;
            isInteger: boolean;
            isSigned: boolean;
        }
        function isNumber(value: unknown): value is Number;
    }
    const number: typeof Number.of, isNumber: typeof Number.isNumber;
    function parseNumber(predicate?: Predicate<Number>): CSSParser<Number>;
    class Percentage implements Equatable, Serializable<Percentage.JSON> {
        static of(value: number, isInteger: boolean): Percentage;
        private readonly _value;
        private readonly _isInteger;
        protected constructor(value: number, isInteger: boolean);
        get type(): "percentage";
        get value(): number;
        get isInteger(): boolean;
        equals(value: unknown): value is this;
        toJSON(): Percentage.JSON;
        toString(): string;
    }
    namespace Percentage {
        interface JSON {
            [key: string]: json.JSON;
            type: "percentage";
            value: number;
            isInteger: boolean;
        }
        function isPercentage(value: unknown): value is Percentage;
    }
    const percentage: typeof Percentage.of, isPercentage: typeof Percentage.isPercentage;
    function parsePercentage(predicate?: Predicate<Percentage>): CSSParser<Percentage>;
    class Dimension implements Equatable, Serializable<Dimension.JSON> {
        static of(value: number, unit: string, isInteger: boolean, isSigned: boolean): Dimension;
        private readonly _value;
        private readonly _unit;
        private readonly _isInteger;
        private readonly _isSigned;
        protected constructor(value: number, unit: string, isInteger: boolean, isSigned: boolean);
        get type(): "dimension";
        get value(): number;
        get unit(): string;
        get isInteger(): boolean;
        get isSigned(): boolean;
        equals(value: unknown): value is this;
        toJSON(): Dimension.JSON;
        toString(): string;
    }
    namespace Dimension {
        interface JSON {
            [key: string]: json.JSON;
            type: "dimension";
            value: number;
            unit: string;
            isInteger: boolean;
            isSigned: boolean;
        }
        function isDimension(value: unknown): value is Dimension;
    }
    const dimension: typeof Dimension.of, isDimension: typeof Dimension.isDimension;
    function parseDimension(predicate?: Predicate<Dimension>): CSSParser<Dimension>;
    class Whitespace implements Equatable, Serializable<Whitespace.JSON> {
        private static _instance;
        static of(): Whitespace;
        private constructor();
        get type(): "whitespace";
        equals(value: unknown): value is this;
        toJSON(): Whitespace.JSON;
        toString(): string;
    }
    namespace Whitespace {
        interface JSON {
            [key: string]: json.JSON;
            type: "whitespace";
        }
        function isWhitespace(value: unknown): value is Whitespace;
    }
    const whitespace: typeof Whitespace.of, isWhitespace: typeof Whitespace.isWhitespace;
    /**
     * Parses whitespace.
     *
     * @remarks
     * This accepts more than one whitespace because our tokenization does not
     * group them, but CSS grammar doesn't care how many there are.
     *
     * This accepts zero whitespace to handle Arbitrary Substitution Functions
     * (essentially `var()`).
     * {@link https://drafts.csswg.org/css-values-5/#arbitrary-substitution-function}
     * When a substitution function is substituted, its value replaces the entire
     * function, but they do not "merge" with previous or following tokens.
     * That is, `var(--foo)var(--bar)` resolves as `[Ident("foo"), Ident("bar")]`
     * and not `[Ident("foobar")]`, and there is no way to obtain the former through
     * pure lexing of a string. This means that a value that accepts two idents
     * would accept `var(--foo)var(--bar)` as a valid value, even if it doesn't
     * accept `foobar`.
     *
     * It is clearer to accept 0 or more whitespace here and have the value parser
     * require whitespace (`separated(parseFoo, parseWhitespace, parseBar`) than
     * using `optional(parseWhitespace)` everywhere. Notably reading the parsers
     * make it more obvious that we are talking about separated tokens.
     */
    const parseWhitespace: Parser<Slice<Token>, Whitespace, string, []>;
    class Colon implements Equatable, Serializable<Colon.JSON> {
        private static _instance;
        static of(): Colon;
        private constructor();
        get type(): "colon";
        equals(value: unknown): value is this;
        toJSON(): Colon.JSON;
        toString(): string;
    }
    namespace Colon {
        interface JSON {
            [key: string]: json.JSON;
            type: "colon";
        }
        function isColon(value: unknown): value is Colon;
    }
    const colon: typeof Colon.of, isColon: typeof Colon.isColon;
    const parseColon: CSSParser<Colon>;
    class Semicolon implements Equatable, Serializable<Semicolon.JSON> {
        private static _instance;
        static of(): Semicolon;
        private constructor();
        get type(): "semicolon";
        equals(value: unknown): value is this;
        toJSON(): Semicolon.JSON;
        toString(): string;
    }
    namespace Semicolon {
        interface JSON {
            [key: string]: json.JSON;
            type: "semicolon";
        }
        function isSemicolon(value: unknown): value is Semicolon;
    }
    const semicolon: typeof Semicolon.of, isSemicolon: typeof Semicolon.isSemicolon;
    const parseSemicolon: CSSParser<Semicolon>;
    class Comma implements Equatable, Serializable<Comma.JSON> {
        private static _instance;
        static of(): Comma;
        private constructor();
        get type(): "comma";
        equals(value: unknown): value is this;
        toJSON(): Comma.JSON;
        toString(): string;
    }
    namespace Comma {
        interface JSON {
            [key: string]: json.JSON;
            type: "comma";
        }
        function isComma(value: unknown): value is Comma;
    }
    const comma: typeof Comma.of, isComma: typeof Comma.isComma;
    const parseComma: CSSParser<Comma>;
    class OpenParenthesis implements Equatable, Serializable<OpenParenthesis.JSON> {
        private static _instance;
        static of(): OpenParenthesis;
        private constructor();
        get type(): "open-parenthesis";
        get mirror(): CloseParenthesis;
        equals(value: unknown): value is this;
        toJSON(): OpenParenthesis.JSON;
        toString(): string;
    }
    namespace OpenParenthesis {
        interface JSON {
            [key: string]: json.JSON;
            type: "open-parenthesis";
        }
        function isOpenParenthesis(value: unknown): value is OpenParenthesis;
    }
    const openParenthesis: typeof OpenParenthesis.of, isOpenParenthesis: typeof OpenParenthesis.isOpenParenthesis;
    const parseOpenParenthesis: CSSParser<OpenParenthesis>;
    class CloseParenthesis implements Equatable, Serializable<CloseParenthesis.JSON> {
        private static _instance;
        static of(): CloseParenthesis;
        private constructor();
        get type(): "close-parenthesis";
        get mirror(): OpenParenthesis;
        equals(value: unknown): value is this;
        toJSON(): CloseParenthesis.JSON;
        toString(): string;
    }
    namespace CloseParenthesis {
        interface JSON {
            [key: string]: json.JSON;
            type: "close-parenthesis";
        }
        function isCloseParenthesis(value: unknown): value is CloseParenthesis;
    }
    const closeParenthesis: typeof CloseParenthesis.of, isCloseParenthesis: typeof CloseParenthesis.isCloseParenthesis;
    const parseCloseParenthesis: CSSParser<CloseParenthesis>;
    class OpenSquareBracket implements Equatable, Serializable<OpenSquareBracket.JSON> {
        private static _instance;
        static of(): OpenSquareBracket;
        private constructor();
        get type(): "open-square-bracket";
        get mirror(): CloseSquareBracket;
        equals(value: unknown): value is this;
        toJSON(): OpenSquareBracket.JSON;
        toString(): string;
    }
    namespace OpenSquareBracket {
        interface JSON {
            [key: string]: json.JSON;
            type: "open-square-bracket";
        }
        function isOpenSquareBracket(value: unknown): value is OpenSquareBracket;
    }
    const openSquareBracket: typeof OpenSquareBracket.of, isOpenSquareBracket: typeof OpenSquareBracket.isOpenSquareBracket;
    const parseOpenSquareBracket: CSSParser<OpenSquareBracket>;
    class CloseSquareBracket implements Equatable, Serializable<CloseSquareBracket.JSON> {
        private static _instance;
        static of(): CloseSquareBracket;
        private constructor();
        get type(): "close-square-bracket";
        get mirror(): OpenSquareBracket;
        equals(value: unknown): value is this;
        toJSON(): CloseSquareBracket.JSON;
        toString(): string;
    }
    namespace CloseSquareBracket {
        interface JSON {
            [key: string]: json.JSON;
            type: "close-square-bracket";
        }
        function isCloseSquareBracket(value: unknown): value is CloseSquareBracket;
    }
    const closeSquareBracket: typeof CloseSquareBracket.of, isCloseSquareBracket: typeof CloseSquareBracket.isCloseSquareBracket;
    const parseCloseSquareBracket: CSSParser<CloseSquareBracket>;
    class OpenCurlyBracket implements Equatable, Serializable<OpenCurlyBracket.JSON> {
        private static _instance;
        static of(): OpenCurlyBracket;
        private constructor();
        get type(): "open-curly-bracket";
        get mirror(): CloseCurlyBracket;
        equals(value: unknown): value is this;
        toJSON(): OpenCurlyBracket.JSON;
        toString(): string;
    }
    namespace OpenCurlyBracket {
        interface JSON {
            [key: string]: json.JSON;
            type: "open-curly-bracket";
        }
        function isOpenCurlyBracket(value: unknown): value is OpenCurlyBracket;
    }
    const openCurlyBracket: typeof OpenCurlyBracket.of, isOpenCurlyBracket: typeof OpenCurlyBracket.isOpenCurlyBracket;
    const parseOpenCurlyBracket: CSSParser<OpenCurlyBracket>;
    class CloseCurlyBracket implements Equatable, Serializable<CloseCurlyBracket.JSON> {
        private static _instance;
        static of(): CloseCurlyBracket;
        private constructor();
        get type(): "close-curly-bracket";
        get mirror(): OpenCurlyBracket;
        equals(value: unknown): value is this;
        toJSON(): CloseCurlyBracket.JSON;
        toString(): string;
    }
    namespace CloseCurlyBracket {
        interface JSON {
            [key: string]: json.JSON;
            type: "close-curly-bracket";
        }
        function isCloseCurlyBracket(value: unknown): value is CloseCurlyBracket;
    }
    const closeCurlyBracket: typeof CloseCurlyBracket.of, isCloseCurlyBracket: typeof CloseCurlyBracket.isCloseCurlyBracket;
    const parseCloseCurlyBracket: CSSParser<CloseCurlyBracket>;
    class OpenComment implements Equatable, Serializable<OpenComment.JSON> {
        private static _instance;
        static of(): OpenComment;
        private constructor();
        get type(): "open-comment";
        equals(value: unknown): value is this;
        toJSON(): OpenComment.JSON;
        toString(): string;
    }
    namespace OpenComment {
        interface JSON {
            [key: string]: json.JSON;
            type: "open-comment";
        }
        function isOpenComment(value: unknown): value is OpenComment;
    }
    const openComment: typeof OpenComment.of, isOpenComment: typeof OpenComment.isOpenComment;
    const parseOpenComment: CSSParser<OpenComment>;
    class CloseComment implements Equatable, Serializable<CloseComment.JSON> {
        private static _instance;
        static of(): CloseComment;
        private constructor();
        get type(): "close-comment";
        equals(value: unknown): value is this;
        toJSON(): CloseComment.JSON;
        toString(): string;
    }
    namespace CloseComment {
        interface JSON {
            [key: string]: json.JSON;
            type: "close-comment";
        }
        function isCloseComment(value: unknown): value is CloseComment;
    }
    const closeComment: typeof CloseComment.of, isCloseComment: typeof CloseComment.isCloseComment;
    const parseCloseComment: CSSParser<CloseComment>;
}
//# sourceMappingURL=token.d.ts.map