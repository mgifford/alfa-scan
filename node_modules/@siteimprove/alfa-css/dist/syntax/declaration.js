import { Parser } from "@siteimprove/alfa-parser";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Result } from "@siteimprove/alfa-result";
import { Slice } from "@siteimprove/alfa-slice";
import { Component } from "./component.js";
import { Token } from "./token.js";
const { not } = Predicate;
const { option, delimited, left, zeroOrMore, map, pair, flatMap } = Parser;
/**
 * {@link https://drafts.csswg.org/css-syntax/#declaration}
 *
 * @public
 */
export class Declaration {
    static of(name, value, important = false) {
        return new Declaration(name, Array.from(value), important);
    }
    _name;
    _value;
    _important;
    constructor(name, value, important) {
        this._name = name;
        this._value = value;
        this._important = important;
    }
    get name() {
        return this._name;
    }
    get value() {
        return this._value;
    }
    get important() {
        return this._important;
    }
    *[Symbol.iterator]() {
        // <name>:
        yield Token.Ident.of(this._name);
        yield Token.Colon.of();
        // <value>
        yield* this._value;
        if (this._important) {
            // !important
            yield Token.Delim.of(0x21);
            yield Token.Ident.of("important");
        }
    }
    equals(value) {
        return (value instanceof Declaration &&
            value._name === this._name &&
            value._important === this._important &&
            value._value.length === this._value.length &&
            value._value.every((token, i) => token.equals(this._value[i])));
    }
    toJSON() {
        return {
            name: this._name,
            value: this._value.map((token) => token.toJSON()),
            important: this._important,
        };
    }
    toString() {
        return `${this._name}: ${this._value}${this._important ? " !important" : ""}`;
    }
}
/**
 * @public
 */
(function (Declaration) {
    /**
     * {@link https://drafts.csswg.org/css-syntax/#consume-a-declaration}
     */
    Declaration.consume = flatMap(pair(left(Token.parseIdent(), delimited(option(Token.parseWhitespace), Token.parseColon)), map(zeroOrMore(Component.consume), (components) => components.flatMap((component) => [...component]))), ([{ value: name }, value]) => (input) => {
        let important = false;
        if (value.length >= 2) {
            const fst = value[value.length - 2];
            const snd = value[value.length - 1];
            if (fst.type === "delim" &&
                fst.value === 0x21 &&
                snd.type === "ident" &&
                snd.value.toLowerCase() === "important") {
                value.splice(value.length - 2, 2);
                important = true;
            }
        }
        if (value.length >= 1) {
            const lst = value[value.length - 1];
            if (lst.type === "whitespace") {
                value.pop();
            }
        }
        return Result.of([
            input,
            Declaration.of(name, value, important),
        ]);
    });
    /**
     * {@link https://drafts.csswg.org/css-syntax/#parse-a-declaration}
     */
    Declaration.parse = (input) => {
        while (input.get(0).some(Token.isWhitespace)) {
            input = input.slice(1);
        }
        const next = input.get(0);
        if (next.none(Token.isIdent)) {
            return Err.of("Expected an ident");
        }
        return Declaration.consume(input);
    };
    /**
     * {@link https://drafts.csswg.org/css-syntax/#consume-a-list-of-declarations}
     */
    Declaration.consumeList = (input) => {
        const declarations = [];
        while (input.length > 0) {
            for (const next of input.get(0)) {
                input = input.slice(1);
                if (Token.isWhitespace(next) || Token.isSemicolon(next)) {
                    continue;
                }
                if (Token.isIdent(next)) {
                    const value = [next];
                    while (input.get(0).some(not(Token.isSemicolon))) {
                        // Component.consume returns Ok while input is non-empty
                        const [remainder, component] = Component.consume(input).getUnsafe();
                        input = remainder;
                        value.push(...component);
                    }
                    const result = Declaration.consume(Slice.of(value));
                    if (result.isOk()) {
                        declarations.push(result.get()[1]);
                    }
                }
                else {
                    while (input.get(0).some(not(Token.isSemicolon))) {
                        // Component.consume returns Ok while input is non-empty
                        const [remainder] = Component.consume(input).getUnsafe();
                        input = remainder;
                    }
                }
            }
        }
        return Result.of([input, declarations]);
    };
    /**
     * {@link https://drafts.csswg.org/css-syntax/#parse-a-list-of-declarations}
     */
    Declaration.parseList = Declaration.consumeList;
})(Declaration || (Declaration = {}));
//# sourceMappingURL=declaration.js.map