import { Parser } from "@siteimprove/alfa-parser";
import { Err, Result } from "@siteimprove/alfa-result";
import { Slice } from "@siteimprove/alfa-slice";
import { Component } from "./component.js";
import { Token } from "./token.js";
const { delimited, flatMap, option, peek, right, left, pair, map, takeUntil, either, end, } = Parser;
/**
 * {@link https://drafts.csswg.org/css-syntax/#function}
 *
 * @public
 */
export class Function {
    static of(name, value) {
        return new Function(name, Array.from(value));
    }
    _name;
    _value;
    constructor(name, value) {
        this._name = name;
        this._value = value;
    }
    get name() {
        return this._name;
    }
    get value() {
        return this._value;
    }
    *[Symbol.iterator]() {
        // <name>(
        yield Token.Function.of(this._name);
        // <value>
        yield* this._value;
        // )
        yield Token.CloseParenthesis.of();
    }
    equals(value) {
        return (value instanceof Function &&
            value._name === this._name &&
            value._value.length === this._value.length &&
            value._value.every((token, i) => token.equals(this._value[i])));
    }
    toJSON() {
        return {
            name: this._name,
            value: this._value.map((token) => token.toJSON()),
        };
    }
    toString() {
        return `${this._name}(${this._value.join("")})`;
    }
}
/**
 * @public
 */
(function (Function) {
    /**
     * {@link https://drafts.csswg.org/css-syntax/#consume-a-function}
     */
    Function.consume = (input) => 
    // eta expansion is necessary for `this` binding to resolve correctly
    map(pair(Token.parseFunction(), map(left(takeUntil(Component.consume, either(Token.parseCloseParenthesis, end(() => "Dummy error message since this should never fail"))), option(Token.parseCloseParenthesis)), (components) => components.flatMap((component) => [...component]))), ([{ value: name }, value]) => Function.of(name, value))(input);
    function parse(query, body) {
        return flatMap(
        // TypeScript is unable to match the overloads of this function with the
        // ones of `Token.parseFunction` (the local overloads are ignored in the
        // implementation); so we just tell it to ignore it.
        right(peek(Token.parseFunction(query)), Function.consume), (fn) => (input) => {
            if (body === undefined) {
                return Result.of([input, [fn, undefined]]);
            }
            // Sadly, JS alone is not capable of differentiating one function from
            // another. So, at run time we can't differentiate a parser from a
            // thunk.
            // We have to rely on exception to handle that.
            let parse;
            try {
                parse = body();
                // In the off case where `body` is a parser that never looks at its
                // input, the previous call might not throw.
                if (Result.isResult(parse)) {
                    throw new Error("It was a parser after all");
                }
            }
            catch (err) {
                parse = body;
            }
            const result = delimited(
            // whitespace just inside the parentheses are OK.
            option(Token.parseWhitespace), parse)(Slice.of(fn.value));
            if (result.isErr()) {
                return result;
            }
            // the previous check ensures the result is Ok
            const [remainder, value] = result.getUnsafe();
            if (remainder.length > 0) {
                // remainder is not empty, so remainder.get(0) is Some.
                return Err.of(`Unexpected token ${remainder.get(0).getUnsafe()}`);
            }
            return Result.of([input, [fn, value]]);
        });
    }
    Function.parse = parse;
})(Function || (Function = {}));
//# sourceMappingURL=function.js.map