import { Array } from "@siteimprove/alfa-array";
import { Parser } from "@siteimprove/alfa-parser";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Err, Ok } from "@siteimprove/alfa-result";
const { map, zeroOrMore } = Parser;
const { fromCharCode } = String;
const { and } = Refinement;
/**
 * @public
 */
export var Token;
(function (Token) {
    /**
     * Parses the first token, whatever it is.
     *
     *  @internal
     */
    Token.parseFirst = (input) => input
        .first()
        .map((token) => Ok.of([input.rest(), token]))
        .getOr(Err.of("No token left"));
    /**
     * @privateRemarks
     * This function is a hot path and is therefore implemented
     * without using other parser combinators to avoid the extra overhead.
     * Any changes to this function should be benchmarked.
     */
    function parseToken(refinement) {
        return (input) => {
            if (input.isEmpty()) {
                return Err.of("No token left");
            }
            // We know input is not empty, so this is safe.
            const val = input.getUnsafe(0);
            if (refinement(val)) {
                return Ok.of([input.rest(), val]);
            }
            return Err.of("Mismatching token");
        };
    }
    function skipUntil(delimiter) {
        return Parser.skipUntil(Token.parseFirst, delimiter);
    }
    Token.skipUntil = skipUntil;
    class Ident {
        static of(value) {
            return new Ident(value);
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "ident";
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return value instanceof Ident && value._value === this._value;
        }
        toJSON() {
            return {
                type: "ident",
                value: this._value,
            };
        }
        toString() {
            return this._value;
        }
    }
    Token.Ident = Ident;
    (function (Ident) {
        function isIdent(value) {
            return value instanceof Ident;
        }
        Ident.isIdent = isIdent;
    })(Ident = Token.Ident || (Token.Ident = {}));
    Token.ident = Ident.of, Token.isIdent = Ident.isIdent;
    function parseIdent(query) {
        let predicate = () => true;
        if (typeof query === "function") {
            predicate = query;
        }
        else if (typeof query === "string") {
            predicate = (ident) => ident.value === query;
        }
        else if (Array.isArray(query)) {
            predicate = (ident) => query.includes(ident.value);
        }
        return parseToken(and(Token.isIdent, predicate));
    }
    Token.parseIdent = parseIdent;
    class Function {
        static of(value) {
            return new Function(value);
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "function";
        }
        get value() {
            return this._value;
        }
        get mirror() {
            return CloseParenthesis.of();
        }
        equals(value) {
            return value instanceof Function && value._value === this._value;
        }
        toJSON() {
            return {
                type: "function",
                value: this._value,
            };
        }
        toString() {
            return `${this._value}(`;
        }
    }
    Token.Function = Function;
    (function (Function) {
        function isFunction(value) {
            return value instanceof Function;
        }
        Function.isFunction = isFunction;
    })(Function = Token.Function || (Token.Function = {}));
    Token.func = Function.of, Token.isFunction = Function.isFunction;
    function parseFunction(query = () => true) {
        const predicate = typeof query === "function"
            ? query
            : Array.isArray(query)
                ? (ident) => query.includes(ident.value)
                : (ident) => ident.value === query;
        return parseToken(and(Token.isFunction, predicate));
    }
    Token.parseFunction = parseFunction;
    class AtKeyword {
        static of(value) {
            return new AtKeyword(value);
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "at-keyword";
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return value instanceof AtKeyword && value._value === this._value;
        }
        toJSON() {
            return {
                type: "at-keyword",
                value: this._value,
            };
        }
        toString() {
            return `@${this._value}`;
        }
    }
    Token.AtKeyword = AtKeyword;
    Token.atKeyword = AtKeyword.of;
    class Hash {
        static of(value, isIdentifier) {
            return new Hash(value, isIdentifier);
        }
        _value;
        _isIdentifier;
        constructor(value, isIdentifier) {
            this._value = value;
            this._isIdentifier = isIdentifier;
        }
        get type() {
            return "hash";
        }
        get value() {
            return this._value;
        }
        get isIdentifier() {
            return this._isIdentifier;
        }
        equals(value) {
            return (value instanceof Hash &&
                value._value === this._value &&
                value._isIdentifier === this._isIdentifier);
        }
        toJSON() {
            return {
                type: "hash",
                value: this._value,
                isIdentifier: this._isIdentifier,
            };
        }
        toString() {
            return `#${this._value}`;
        }
    }
    Token.Hash = Hash;
    (function (Hash) {
        function isHash(value) {
            return value instanceof Hash;
        }
        Hash.isHash = isHash;
    })(Hash = Token.Hash || (Token.Hash = {}));
    Token.hash = Hash.of, Token.isHash = Hash.isHash;
    function parseHash(predicate = () => true) {
        return parseToken(and(Token.isHash, predicate));
    }
    Token.parseHash = parseHash;
    class String {
        static of(value) {
            return new String(value);
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "string";
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return value instanceof String && value._value === this._value;
        }
        toJSON() {
            return {
                type: "string",
                value: this._value,
            };
        }
        toString() {
            return `"${this._value.replace(/"/g, `\\"`)}"`;
        }
    }
    Token.String = String;
    (function (String) {
        function isString(value) {
            return value instanceof String;
        }
        String.isString = isString;
    })(String = Token.String || (Token.String = {}));
    Token.string = String.of, Token.isString = String.isString;
    function parseString(predicate = () => true) {
        return parseToken(and(Token.isString, predicate));
    }
    Token.parseString = parseString;
    class URL {
        static of(value) {
            return new URL(value);
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "url";
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return value instanceof URL && value._value === this._value;
        }
        toJSON() {
            return {
                type: "url",
                value: this._value,
            };
        }
        toString() {
            return `url(${this._value})`;
        }
    }
    Token.URL = URL;
    (function (URL) {
        function isURL(value) {
            return value instanceof URL;
        }
        URL.isURL = isURL;
    })(URL = Token.URL || (Token.URL = {}));
    Token.url = URL.of, Token.isURL = URL.isURL;
    function parseURL(predicate = () => true) {
        return parseToken(and(Token.isURL, predicate));
    }
    Token.parseURL = parseURL;
    class BadURL {
        static _instance = new BadURL();
        static of() {
            return BadURL._instance;
        }
        constructor() { }
        get type() {
            return "bad-url";
        }
        equals(value) {
            return value instanceof BadURL;
        }
        toJSON() {
            return {
                type: "bad-url",
            };
        }
        toString() {
            return "";
        }
    }
    Token.BadURL = BadURL;
    Token.badURL = BadURL.of;
    class Delim {
        static _delims = new Map();
        static of(value) {
            let delim = Delim._delims.get(value);
            if (delim === undefined) {
                delim = new Delim(value);
                Delim._delims.set(value, delim);
            }
            return delim;
        }
        _value;
        constructor(value) {
            this._value = value;
        }
        get type() {
            return "delim";
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return value instanceof Delim && value._value === this._value;
        }
        toJSON() {
            return {
                type: "delim",
                value: this._value,
            };
        }
        toString() {
            return fromCharCode(this._value);
        }
    }
    Token.Delim = Delim;
    (function (Delim) {
        function isDelim(value) {
            return value instanceof Delim;
        }
        Delim.isDelim = isDelim;
    })(Delim = Token.Delim || (Token.Delim = {}));
    Token.delim = Delim.of, Token.isDelim = Delim.isDelim;
    function parseDelim(query = () => true) {
        let predicate;
        if (typeof query === "function") {
            predicate = query;
        }
        else {
            const value = typeof query === "number" ? query : query.charCodeAt(0);
            predicate = (delim) => delim.value === value;
        }
        return parseToken(and(Token.isDelim, predicate));
    }
    Token.parseDelim = parseDelim;
    class Number {
        static of(value, isInteger, isSigned) {
            return new Number(value, isInteger, isSigned);
        }
        _value;
        _isInteger;
        _isSigned;
        constructor(value, isInteger, isSigned) {
            this._value = value;
            this._isInteger = isInteger;
            this._isSigned = isSigned;
        }
        get type() {
            return "number";
        }
        get value() {
            return this._value;
        }
        get isInteger() {
            return this._isInteger;
        }
        get isSigned() {
            return this._isSigned;
        }
        equals(value) {
            return (value instanceof Number &&
                value._value === this._value &&
                value._isInteger === this._isInteger &&
                value._isSigned === this._isSigned);
        }
        toJSON() {
            return {
                type: "number",
                value: this._value,
                isInteger: this._isInteger,
                isSigned: this._isSigned,
            };
        }
        toString() {
            // If the token is explicitly signed and the value is positive, we must
            // add a `+` as this won't be included in the stringified value.
            const sign = this._isSigned && this._value >= 0 ? "+" : "";
            return `${sign}${this._value}`;
        }
    }
    Token.Number = Number;
    (function (Number) {
        function isNumber(value) {
            return value instanceof Number;
        }
        Number.isNumber = isNumber;
    })(Number = Token.Number || (Token.Number = {}));
    Token.number = Number.of, Token.isNumber = Number.isNumber;
    function parseNumber(predicate = () => true) {
        return parseToken(and(Token.isNumber, predicate));
    }
    Token.parseNumber = parseNumber;
    class Percentage {
        static of(value, isInteger) {
            return new Percentage(value, isInteger);
        }
        _value;
        _isInteger;
        constructor(value, isInteger) {
            this._value = value;
            this._isInteger = isInteger;
        }
        get type() {
            return "percentage";
        }
        get value() {
            return this._value;
        }
        get isInteger() {
            return this._isInteger;
        }
        equals(value) {
            return (value instanceof Percentage &&
                value._value === this._value &&
                value._isInteger === this._isInteger);
        }
        toJSON() {
            return {
                type: "percentage",
                value: this._value,
                isInteger: this._isInteger,
            };
        }
        toString() {
            return `${this._value * 100}%`;
        }
    }
    Token.Percentage = Percentage;
    (function (Percentage) {
        function isPercentage(value) {
            return value instanceof Percentage;
        }
        Percentage.isPercentage = isPercentage;
    })(Percentage = Token.Percentage || (Token.Percentage = {}));
    Token.percentage = Percentage.of, Token.isPercentage = Percentage.isPercentage;
    function parsePercentage(predicate = () => true) {
        return parseToken(and(Token.isPercentage, predicate));
    }
    Token.parsePercentage = parsePercentage;
    class Dimension {
        static of(value, unit, isInteger, isSigned) {
            return new Dimension(value, unit, isInteger, isSigned);
        }
        _value;
        _unit;
        _isInteger;
        _isSigned;
        constructor(value, unit, isInteger, isSigned) {
            this._value = value;
            this._unit = unit;
            this._isInteger = isInteger;
            this._isSigned = isSigned;
        }
        get type() {
            return "dimension";
        }
        get value() {
            return this._value;
        }
        get unit() {
            return this._unit;
        }
        get isInteger() {
            return this._isInteger;
        }
        get isSigned() {
            return this._isSigned;
        }
        equals(value) {
            return (value instanceof Dimension &&
                value._value === this._value &&
                value._unit === this._unit &&
                value._isInteger === this._isInteger &&
                value._isSigned === this._isSigned);
        }
        toJSON() {
            return {
                type: "dimension",
                value: this._value,
                unit: this._unit,
                isInteger: this._isInteger,
                isSigned: this._isSigned,
            };
        }
        toString() {
            // If the token is explicitly signed and the value is positive, we must
            // add a `+` as this won't be included in the stringified value.
            const sign = this._isSigned && this._value >= 0 ? "+" : "";
            return `${sign}${this._value}${this._unit}`;
        }
    }
    Token.Dimension = Dimension;
    (function (Dimension) {
        function isDimension(value) {
            return value instanceof Dimension;
        }
        Dimension.isDimension = isDimension;
    })(Dimension = Token.Dimension || (Token.Dimension = {}));
    Token.dimension = Dimension.of, Token.isDimension = Dimension.isDimension;
    function parseDimension(predicate = () => true) {
        return parseToken(and(Token.isDimension, predicate));
    }
    Token.parseDimension = parseDimension;
    class Whitespace {
        static _instance = new Whitespace();
        static of() {
            return Whitespace._instance;
        }
        constructor() { }
        get type() {
            return "whitespace";
        }
        equals(value) {
            return value instanceof Whitespace;
        }
        toJSON() {
            return {
                type: "whitespace",
            };
        }
        toString() {
            return " ";
        }
    }
    Token.Whitespace = Whitespace;
    (function (Whitespace) {
        function isWhitespace(value) {
            return value instanceof Whitespace;
        }
        Whitespace.isWhitespace = isWhitespace;
    })(Whitespace = Token.Whitespace || (Token.Whitespace = {}));
    Token.whitespace = Whitespace.of, Token.isWhitespace = Whitespace.isWhitespace;
    /**
     * Parses whitespace.
     *
     * @remarks
     * This accepts more than one whitespace because our tokenization does not
     * group them, but CSS grammar doesn't care how many there are.
     *
     * This accepts zero whitespace to handle Arbitrary Substitution Functions
     * (essentially `var()`).
     * {@link https://drafts.csswg.org/css-values-5/#arbitrary-substitution-function}
     * When a substitution function is substituted, its value replaces the entire
     * function, but they do not "merge" with previous or following tokens.
     * That is, `var(--foo)var(--bar)` resolves as `[Ident("foo"), Ident("bar")]`
     * and not `[Ident("foobar")]`, and there is no way to obtain the former through
     * pure lexing of a string. This means that a value that accepts two idents
     * would accept `var(--foo)var(--bar)` as a valid value, even if it doesn't
     * accept `foobar`.
     *
     * It is clearer to accept 0 or more whitespace here and have the value parser
     * require whitespace (`separated(parseFoo, parseWhitespace, parseBar`) than
     * using `optional(parseWhitespace)` everywhere. Notably reading the parsers
     * make it more obvious that we are talking about separated tokens.
     */
    Token.parseWhitespace = map(zeroOrMore(parseToken(Token.isWhitespace)), Whitespace.of);
    class Colon {
        static _instance = new Colon();
        static of() {
            return Colon._instance;
        }
        constructor() { }
        get type() {
            return "colon";
        }
        equals(value) {
            return value instanceof Colon;
        }
        toJSON() {
            return {
                type: "colon",
            };
        }
        toString() {
            return ":";
        }
    }
    Token.Colon = Colon;
    (function (Colon) {
        function isColon(value) {
            return value instanceof Colon;
        }
        Colon.isColon = isColon;
    })(Colon = Token.Colon || (Token.Colon = {}));
    Token.colon = Colon.of, Token.isColon = Colon.isColon;
    Token.parseColon = parseToken(Token.isColon);
    class Semicolon {
        static _instance = new Semicolon();
        static of() {
            return Semicolon._instance;
        }
        constructor() { }
        get type() {
            return "semicolon";
        }
        equals(value) {
            return value instanceof Semicolon;
        }
        toJSON() {
            return {
                type: "semicolon",
            };
        }
        toString() {
            return ";";
        }
    }
    Token.Semicolon = Semicolon;
    (function (Semicolon) {
        function isSemicolon(value) {
            return value instanceof Semicolon;
        }
        Semicolon.isSemicolon = isSemicolon;
    })(Semicolon = Token.Semicolon || (Token.Semicolon = {}));
    Token.semicolon = Semicolon.of, Token.isSemicolon = Semicolon.isSemicolon;
    Token.parseSemicolon = parseToken(Token.isSemicolon);
    class Comma {
        static _instance = new Comma();
        static of() {
            return Comma._instance;
        }
        constructor() { }
        get type() {
            return "comma";
        }
        equals(value) {
            return value instanceof Comma;
        }
        toJSON() {
            return {
                type: "comma",
            };
        }
        toString() {
            return ",";
        }
    }
    Token.Comma = Comma;
    (function (Comma) {
        function isComma(value) {
            return value instanceof Comma;
        }
        Comma.isComma = isComma;
    })(Comma = Token.Comma || (Token.Comma = {}));
    Token.comma = Comma.of, Token.isComma = Comma.isComma;
    Token.parseComma = parseToken(Token.isComma);
    class OpenParenthesis {
        static _instance = new OpenParenthesis();
        static of() {
            return OpenParenthesis._instance;
        }
        constructor() { }
        get type() {
            return "open-parenthesis";
        }
        get mirror() {
            return CloseParenthesis.of();
        }
        equals(value) {
            return value instanceof OpenParenthesis;
        }
        toJSON() {
            return {
                type: "open-parenthesis",
            };
        }
        toString() {
            return "(";
        }
    }
    Token.OpenParenthesis = OpenParenthesis;
    (function (OpenParenthesis) {
        function isOpenParenthesis(value) {
            return value instanceof OpenParenthesis;
        }
        OpenParenthesis.isOpenParenthesis = isOpenParenthesis;
    })(OpenParenthesis = Token.OpenParenthesis || (Token.OpenParenthesis = {}));
    Token.openParenthesis = OpenParenthesis.of, Token.isOpenParenthesis = OpenParenthesis.isOpenParenthesis;
    Token.parseOpenParenthesis = parseToken(Token.isOpenParenthesis);
    class CloseParenthesis {
        static _instance = new CloseParenthesis();
        static of() {
            return CloseParenthesis._instance;
        }
        constructor() { }
        get type() {
            return "close-parenthesis";
        }
        get mirror() {
            return OpenParenthesis.of();
        }
        equals(value) {
            return value instanceof CloseParenthesis;
        }
        toJSON() {
            return {
                type: "close-parenthesis",
            };
        }
        toString() {
            return ")";
        }
    }
    Token.CloseParenthesis = CloseParenthesis;
    (function (CloseParenthesis) {
        function isCloseParenthesis(value) {
            return value instanceof CloseParenthesis;
        }
        CloseParenthesis.isCloseParenthesis = isCloseParenthesis;
    })(CloseParenthesis = Token.CloseParenthesis || (Token.CloseParenthesis = {}));
    Token.closeParenthesis = CloseParenthesis.of, Token.isCloseParenthesis = CloseParenthesis.isCloseParenthesis;
    Token.parseCloseParenthesis = parseToken(Token.isCloseParenthesis);
    class OpenSquareBracket {
        static _instance = new OpenSquareBracket();
        static of() {
            return OpenSquareBracket._instance;
        }
        constructor() { }
        get type() {
            return "open-square-bracket";
        }
        get mirror() {
            return CloseSquareBracket.of();
        }
        equals(value) {
            return value instanceof OpenSquareBracket;
        }
        toJSON() {
            return {
                type: "open-square-bracket",
            };
        }
        toString() {
            return "[";
        }
    }
    Token.OpenSquareBracket = OpenSquareBracket;
    (function (OpenSquareBracket) {
        function isOpenSquareBracket(value) {
            return value instanceof OpenSquareBracket;
        }
        OpenSquareBracket.isOpenSquareBracket = isOpenSquareBracket;
    })(OpenSquareBracket = Token.OpenSquareBracket || (Token.OpenSquareBracket = {}));
    Token.openSquareBracket = OpenSquareBracket.of, Token.isOpenSquareBracket = OpenSquareBracket.isOpenSquareBracket;
    Token.parseOpenSquareBracket = parseToken(Token.isOpenSquareBracket);
    class CloseSquareBracket {
        static _instance = new CloseSquareBracket();
        static of() {
            return CloseSquareBracket._instance;
        }
        constructor() { }
        get type() {
            return "close-square-bracket";
        }
        get mirror() {
            return OpenSquareBracket.of();
        }
        equals(value) {
            return value instanceof CloseSquareBracket;
        }
        toJSON() {
            return {
                type: "close-square-bracket",
            };
        }
        toString() {
            return "]";
        }
    }
    Token.CloseSquareBracket = CloseSquareBracket;
    (function (CloseSquareBracket) {
        function isCloseSquareBracket(value) {
            return value instanceof CloseSquareBracket;
        }
        CloseSquareBracket.isCloseSquareBracket = isCloseSquareBracket;
    })(CloseSquareBracket = Token.CloseSquareBracket || (Token.CloseSquareBracket = {}));
    Token.closeSquareBracket = CloseSquareBracket.of, Token.isCloseSquareBracket = CloseSquareBracket.isCloseSquareBracket;
    Token.parseCloseSquareBracket = parseToken(Token.isCloseSquareBracket);
    class OpenCurlyBracket {
        static _instance = new OpenCurlyBracket();
        static of() {
            return OpenCurlyBracket._instance;
        }
        constructor() { }
        get type() {
            return "open-curly-bracket";
        }
        get mirror() {
            return CloseCurlyBracket.of();
        }
        equals(value) {
            return value instanceof OpenCurlyBracket;
        }
        toJSON() {
            return {
                type: "open-curly-bracket",
            };
        }
        toString() {
            return "{";
        }
    }
    Token.OpenCurlyBracket = OpenCurlyBracket;
    (function (OpenCurlyBracket) {
        function isOpenCurlyBracket(value) {
            return value instanceof OpenCurlyBracket;
        }
        OpenCurlyBracket.isOpenCurlyBracket = isOpenCurlyBracket;
    })(OpenCurlyBracket = Token.OpenCurlyBracket || (Token.OpenCurlyBracket = {}));
    Token.openCurlyBracket = OpenCurlyBracket.of, Token.isOpenCurlyBracket = OpenCurlyBracket.isOpenCurlyBracket;
    Token.parseOpenCurlyBracket = parseToken(Token.isOpenCurlyBracket);
    class CloseCurlyBracket {
        static _instance = new CloseCurlyBracket();
        static of() {
            return CloseCurlyBracket._instance;
        }
        constructor() { }
        get type() {
            return "close-curly-bracket";
        }
        get mirror() {
            return OpenCurlyBracket.of();
        }
        equals(value) {
            return value instanceof CloseCurlyBracket;
        }
        toJSON() {
            return {
                type: "close-curly-bracket",
            };
        }
        toString() {
            return "}";
        }
    }
    Token.CloseCurlyBracket = CloseCurlyBracket;
    (function (CloseCurlyBracket) {
        function isCloseCurlyBracket(value) {
            return value instanceof CloseCurlyBracket;
        }
        CloseCurlyBracket.isCloseCurlyBracket = isCloseCurlyBracket;
    })(CloseCurlyBracket = Token.CloseCurlyBracket || (Token.CloseCurlyBracket = {}));
    Token.closeCurlyBracket = CloseCurlyBracket.of, Token.isCloseCurlyBracket = CloseCurlyBracket.isCloseCurlyBracket;
    Token.parseCloseCurlyBracket = parseToken(Token.isCloseCurlyBracket);
    class OpenComment {
        static _instance = new OpenComment();
        static of() {
            return OpenComment._instance;
        }
        constructor() { }
        get type() {
            return "open-comment";
        }
        equals(value) {
            return value instanceof OpenComment;
        }
        toJSON() {
            return {
                type: "open-comment",
            };
        }
        toString() {
            return "<!--";
        }
    }
    Token.OpenComment = OpenComment;
    (function (OpenComment) {
        function isOpenComment(value) {
            return value instanceof OpenComment;
        }
        OpenComment.isOpenComment = isOpenComment;
    })(OpenComment = Token.OpenComment || (Token.OpenComment = {}));
    Token.openComment = OpenComment.of, Token.isOpenComment = OpenComment.isOpenComment;
    Token.parseOpenComment = parseToken(Token.isOpenComment);
    class CloseComment {
        static _instance = new CloseComment();
        static of() {
            return CloseComment._instance;
        }
        constructor() { }
        get type() {
            return "close-comment";
        }
        equals(value) {
            return value instanceof CloseComment;
        }
        toJSON() {
            return {
                type: "close-comment",
            };
        }
        toString() {
            return "-->";
        }
    }
    Token.CloseComment = CloseComment;
    (function (CloseComment) {
        function isCloseComment(value) {
            return value instanceof CloseComment;
        }
        CloseComment.isCloseComment = isCloseComment;
    })(CloseComment = Token.CloseComment || (Token.CloseComment = {}));
    Token.closeComment = CloseComment.of, Token.isCloseComment = CloseComment.isCloseComment;
    Token.parseCloseComment = parseToken(Token.isCloseComment);
})(Token || (Token = {}));
//# sourceMappingURL=token.js.map