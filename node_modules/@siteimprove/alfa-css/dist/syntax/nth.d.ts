import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import type * as json from "@siteimprove/alfa-json";
import type { Parser as CSSParser } from "./parser.js";
import { Token } from "./token.js";
/**
 * {@link https://drafts.csswg.org/css-syntax/#anb}
 *
 * @public
 */
export declare class Nth implements Iterable<Token>, Equatable, Serializable {
    static of(step: number, offset?: number): Nth;
    private readonly _step;
    private readonly _offset;
    protected constructor(step: number, offset: number);
    get step(): number;
    get offset(): number;
    /**
     * Check if the given index matches the indices produced by this nth.
     *
     * @remarks
     * This is checked by solving the equation `an + b = i` for `n`, giving us
     * `n = (i - b) / a`. The index `i` is matched by this nth if the resulting
     * `n` is a non-negative integer.
     */
    matches(index: number): boolean;
    for(n: number): number;
    indices(): Iterable<number>;
    [Symbol.iterator](): Iterator<Token>;
    equals(value: unknown): value is this;
    toJSON(): Nth.JSON;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Nth {
    interface JSON {
        [key: string]: json.JSON;
        step: number;
        offset: number;
    }
    /**
     * @remarks
     * The An+B syntax isn't really meant for the tokens produced by the CSS lexer
     * and so the resulting parser ends up being quite complex.
     *
     * {@link https://drafts.csswg.org/css-syntax/#anb-production}
     */
    const parse: CSSParser<Nth>;
}
//# sourceMappingURL=nth.d.ts.map