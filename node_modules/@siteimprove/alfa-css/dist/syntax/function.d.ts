import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type * as json from "@siteimprove/alfa-json";
import type { Thunk } from "@siteimprove/alfa-thunk";
import type { Parser as CSSParser } from "./parser.js";
import { Token } from "./token.js";
/**
 * {@link https://drafts.csswg.org/css-syntax/#function}
 *
 * @public
 */
export declare class Function<N extends string = string> implements Iterable<Token>, Equatable, Serializable {
    static of<N extends string = string>(name: N, value: Iterable<Token>): Function<N>;
    private readonly _name;
    private readonly _value;
    protected constructor(name: N, value: Array<Token>);
    get name(): N;
    get value(): Array<Token>;
    [Symbol.iterator](): Iterator<Token>;
    equals(value: unknown): value is this;
    toJSON(): Function.JSON<N>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Function {
    interface JSON<N extends string = string> {
        [key: string]: json.JSON;
        name: N;
        value: Array<Token.JSON>;
    }
    /**
     * {@link https://drafts.csswg.org/css-syntax/#consume-a-function}
     */
    const consume: CSSParser<Function>;
    function parse<T, N extends string = string>(query: N | ReadonlyArray<N> | Refinement<Token.Function, Token.Function<N>>, body?: CSSParser<T> | Thunk<CSSParser<T>>): CSSParser<[Function, T]>;
    function parse<T>(query?: Predicate<Token.Function>, body?: CSSParser<T> | Thunk<CSSParser<T>>): CSSParser<[Function, T]>;
}
//# sourceMappingURL=function.d.ts.map