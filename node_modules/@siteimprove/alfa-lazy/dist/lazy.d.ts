import type { Applicative } from "@siteimprove/alfa-applicative";
import { Equatable } from "@siteimprove/alfa-equatable";
import type { Functor } from "@siteimprove/alfa-functor";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import type { Monad } from "@siteimprove/alfa-monad";
import type { Thunk } from "@siteimprove/alfa-thunk";
import { Trampoline } from "@siteimprove/alfa-trampoline";
/**
 * @public
 */
export declare class Lazy<T> implements Functor<T>, Applicative<T>, Monad<T>, Iterable<T>, Equatable, Serializable<Lazy.JSON<T>> {
    static of<T>(thunk: Thunk<T>): Lazy<T>;
    static force<T>(value: T): Lazy<T>;
    private _value;
    protected constructor(value: Trampoline<T>);
    force(): T;
    map<U>(mapper: Mapper<T, U>): Lazy<U>;
    apply<U>(mapper: Lazy<Mapper<T, U>>): Lazy<U>;
    flatMap<U>(mapper: Mapper<T, Lazy<U>>): Lazy<U>;
    flatten<T>(this: Lazy<Lazy<T>>): Lazy<T>;
    equals<T>(value: Lazy<T>): boolean;
    equals(value: unknown): value is this;
    iterator(): Iterator<T>;
    [Symbol.iterator](): Iterator<T>;
    toThunk(): Thunk<T>;
    toJSON(options?: Serializable.Options): Lazy.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Lazy {
    type JSON<T> = Serializable.ToJSON<T>;
}
//# sourceMappingURL=lazy.d.ts.map