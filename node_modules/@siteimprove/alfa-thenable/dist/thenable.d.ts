import { Array } from "@siteimprove/alfa-array";
import type { Callback } from "@siteimprove/alfa-callback";
import type { Continuation } from "@siteimprove/alfa-continuation";
import type { Mapper } from "@siteimprove/alfa-mapper";
/**
 * @remarks
 * This interface purposely defines only the bare minimum needed for awaitable
 * values and leaves out features like chaining of `.then()` calls and optional
 * rejection callbacks as available for promises.
 *
 * @public
 */
export interface Thenable<T, E = unknown> {
    then(resolved: Callback<T>, rejected: Callback<E>): void;
}
/**
 * @public
 */
export declare namespace Thenable {
    /**
     * Check if an unknown value implements the {@link (Thenable:interface)}
     * interface.
     */
    function isThenable<T, E = unknown>(value: unknown): value is Thenable<T, E>;
    function empty(): Thenable<void, never>;
    function resolve<T>(value: T): Thenable<T, never>;
    function reject<E>(error: E): Thenable<never, E>;
    function defer<T, E = unknown>(continuation: Continuation<T, void, [reject: Callback<E>]>): Thenable<T, E>;
    function map<T, U, E = unknown>(thenable: Thenable<T, E>, mapper: Mapper<T, U>): Thenable<U, E>;
    function apply<T, U, E = unknown, F = E>(thenable: Thenable<T, E>, mapper: Thenable<Mapper<T, U>, F>): Thenable<U, E | F>;
    function flatMap<T, U, E = unknown, F = E>(thenable: Thenable<T, E>, mapper: Mapper<T, Thenable<U, F>>): Thenable<U, E | F>;
    function flatten<T, E = unknown, F = E>(thenable: Thenable<Thenable<T, F>, E>): Thenable<T, E | F>;
    function all<T, E = unknown>(...thenables: Array<Thenable<T, E>>): Thenable<Array<T>, E>;
    function any<T, E = unknown>(...thenables: Array<Thenable<T, E>>): Thenable<T, Array<E>>;
    function race<T, E = unknown>(...thenables: Array<Thenable<T, E>>): Thenable<T, E>;
}
//# sourceMappingURL=thenable.d.ts.map