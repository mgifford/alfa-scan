/**
 * @public
 */
export var Bits;
(function (Bits) {
    /**
     * Returns a number whose binary representation has a 1 in the ith position.
     */
    function bit(i) {
        return 1 << i;
    }
    Bits.bit = bit;
    /**
     * Returns the input with the ith bit is set to 1.
     */
    function set(bits, i) {
        return bits | bit(i);
    }
    Bits.set = set;
    /**
     * Returns the input with the ith bit is set to 0.
     */
    function clear(bits, i) {
        return bits & ~bit(i);
    }
    Bits.clear = clear;
    /**
     * Returns true if the ith bit is 1.
     */
    function test(bits, i) {
        return (bits & bit(i)) !== 0;
    }
    Bits.test = test;
    /**
     * Returns the input with only the n least signifant bits.
     */
    function take(bits, n) {
        return bits & ((1 << n) - 1);
    }
    Bits.take = take;
    /**
     * Returns the input with the n least signifant bits removed.
     */
    function skip(bits, n) {
        return bits >>> n;
    }
    Bits.skip = skip;
    /**
     * @remarks
     * This is a 32-bit variant of the 64-bit population count algorithm outlined
     * on Wikipedia. Until ECMAScript natively provides an efficient population
     * count algorithm, this is the best we can do.
     *
     * {@link https://en.wikipedia.org/wiki/Hamming_weight}
     */
    function popCount(bits) {
        bits -= (bits >> 1) & 0x55555555;
        bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);
        bits = (bits + (bits >> 4)) & 0x0f0f0f0f;
        bits += bits >> 8;
        bits += bits >> 16;
        return bits & 0x7f;
    }
    Bits.popCount = popCount;
})(Bits || (Bits = {}));
//# sourceMappingURL=bits.js.map