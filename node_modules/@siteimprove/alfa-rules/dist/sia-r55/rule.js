import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { DOM, Node } from "@siteimprove/alfa-aria";
import { Element, Namespace, Query } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Ok } from "@siteimprove/alfa-result";
import { String } from "@siteimprove/alfa-string";
import * as dom from "@siteimprove/alfa-dom";
import { expectation } from "../common/act/expectation.js";
import { Group } from "../common/act/group.js";
import { Question } from "../common/act/question.js";
import { WithRole } from "../common/diagnostic/with-role.js";
import { ARIA } from "../requirements/index.js";
import { Scope, Stability } from "../tags/index.js";
const { hasIncorrectRoleWithoutName, hasRole, isIncludedInTheAccessibilityTree, } = DOM;
const { hasNamespace } = Element;
const { and, equals } = Predicate;
const { getElementDescendants } = Query;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r55",
    requirements: [
        ARIA.of("https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/#aria_lh_step3"),
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document }) {
        return {
            applicability() {
                return (getElementDescendants(document, dom.Node.fullTree)
                    .filter(and(hasNamespace(equals(Namespace.HTML)), isIncludedInTheAccessibilityTree(device), hasRole(device, (role) => role.is("landmark"))))
                    // circumventing https://github.com/Siteimprove/alfa/issues/298
                    .reject(hasIncorrectRoleWithoutName(device))
                    // We first group by name, under the assumption that duplicated
                    // names are less frequent than duplicated roles.
                    .groupBy((landmark) => Node.from(landmark, device).name.map((name) => String.normalize(name.value)))
                    .filter((landmarks) => landmarks.size > 1)
                    // Next, we group by role.
                    .flatMap((sameName) => sameName
                    // We have filtered by having a role, and can safely get it.
                    .groupBy((landmark) => Node.from(landmark, device).role.getUnsafe()))
                    .filter((elements) => elements.size > 1)
                    .map(Group.of)
                    .values());
            },
            expectations(target) {
                // Empty groups have been filtered out already, so we can safely get the
                // first element
                const first = Node.from(Iterable.first(target).getUnsafe(), device);
                const role = first.role.map((role) => role.name).getOr("generic");
                const name = first.name.map((name) => name.value).getOr("");
                const sameResource = Question.of("is-content-equivalent", target, `Do these ${role} landmarks have the same or equivalent content?`, {
                    diagnostic: WithRoleAndName.of(`Do these ${role} landmarks have the same or equivalent content?`, role, name),
                });
                return {
                    1: sameResource.map((same) => expectation(same, () => Outcomes.SameResource(role, name), () => Outcomes.DifferentResources(role, name))),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.SameResource = (role, name) => Ok.of(WithRoleAndName.of(`No two \`${role}\` have the same name and different content.`, role, name));
    Outcomes.DifferentResources = (role, name) => Err.of(WithRoleAndName.of(`Some \`${role}\` have the same name and different content.`, role, name));
})(Outcomes || (Outcomes = {}));
/**
 * @public
 */
export class WithRoleAndName extends WithRole {
    static of(message, role, name) {
        return role === undefined
            ? new Diagnostic(message)
            : name === undefined
                ? new WithRole(message, role)
                : new WithRoleAndName(message, role, name);
    }
    _name;
    constructor(message, role, name) {
        super(message, role);
        this._name = name;
    }
    get name() {
        return this._name;
    }
    equals(value) {
        return (value instanceof WithRoleAndName &&
            value._message === this._message &&
            value._role === this._role &&
            value._name === this._name);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            name: this._name,
        };
    }
}
/**
 * @public
 */
(function (WithRoleAndName) {
    /**@public */
    function isWithRoleAndName(value) {
        return value instanceof WithRoleAndName;
    }
    WithRoleAndName.isWithRoleAndName = isWithRoleAndName;
})(WithRoleAndName || (WithRoleAndName = {}));
//# sourceMappingURL=rule.js.map