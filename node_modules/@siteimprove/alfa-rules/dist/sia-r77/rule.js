import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { DOM } from "@siteimprove/alfa-aria";
import { Element, Namespace, Query } from "@siteimprove/alfa-dom";
import { EAA } from "@siteimprove/alfa-eaa";
import { Map } from "@siteimprove/alfa-map";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Table } from "@siteimprove/alfa-table";
import { Criterion } from "@siteimprove/alfa-wcag";
import { expectation } from "../common/act/expectation.js";
import { Scope, Stability } from "../tags/index.js";
const { hasRole, isIncludedInTheAccessibilityTree, isPerceivableForAll } = DOM;
const { hasName, hasNamespace } = Element;
const { and } = Predicate;
const { getElementDescendants } = Query;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r77",
    requirements: [Criterion.of("1.3.1"), EAA.of("9.1.3.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document }) {
        let data = Map.empty();
        return {
            *applicability() {
                const tables = getElementDescendants(document).filter(and(hasNamespace(Namespace.HTML), hasName("table"), isIncludedInTheAccessibilityTree(device)));
                for (const table of tables) {
                    const model = Table.from(table);
                    if (model.cells.find((cell) => cell.isHeader()).isNone()) {
                        continue;
                    }
                    const dataCells = getElementDescendants(table).filter(and(hasNamespace(Namespace.HTML), hasName("td"), hasRole(device, "cell", "gridcell"), isPerceivableForAll(device)));
                    for (const dataCell of dataCells) {
                        for (const cell of model.cells.find((cell) => cell.element.equals(dataCell))) {
                            data = data.set(dataCell, cell);
                            yield dataCell;
                        }
                    }
                }
            },
            expectations(target) {
                // targets are yielded after filling the map.
                const cell = data.get(target).getUnsafe();
                return {
                    1: expectation(cell.headers.isEmpty(), () => Outcomes.IsNotAssignedToHeaderCell, () => Outcomes.IsAssignedToHeaderCell),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.IsAssignedToHeaderCell = Ok.of(Diagnostic.of(`The cell is assigned to an header cell`));
    Outcomes.IsNotAssignedToHeaderCell = Err.of(Diagnostic.of(`The cell is not assigned to any header cell`));
})(Outcomes || (Outcomes = {}));
//# sourceMappingURL=rule.js.map