import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { DOM } from "@siteimprove/alfa-aria";
import { Array } from "@siteimprove/alfa-array";
import { Element, Namespace, Node, Query } from "@siteimprove/alfa-dom";
import { EAA } from "@siteimprove/alfa-eaa";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Style } from "@siteimprove/alfa-style";
import { Criterion, Technique } from "@siteimprove/alfa-wcag";
import * as aria from "@siteimprove/alfa-aria";
import { isAriaControlsOptional } from "../common/predicate/is-aria-controls-optional.js";
import { Scope, Stability } from "../tags/index.js";
const { hasNonDefaultRole, isIncludedInTheAccessibilityTree } = DOM;
const { hasNamespace } = Element;
const { isEmpty } = Iterable;
const { and, property } = Predicate;
const { isFocusable } = Style;
const { getElementDescendants } = Query;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r16",
    requirements: [
        Criterion.of("1.3.1"),
        Criterion.of("4.1.2"),
        EAA.of("9.1.3.1"),
        EAA.of("9.4.1.2"),
        Technique.of("ARIA5"),
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document }) {
        return {
            applicability() {
                return getElementDescendants(document, Node.composedNested)
                    .filter(and(hasNamespace(Namespace.HTML, Namespace.SVG), hasNonDefaultRole))
                    .filter(isIncludedInTheAccessibilityTree(device));
            },
            expectations(target) {
                return { 1: hasRequiredValues(device, target) };
            },
        };
    },
});
function hasRequiredValues(device, element) {
    const node = aria.Node.from(element, device);
    for (const role of node.role) {
        // The `separator` role is poorly architected in the sense that its
        // inheritance and attribute requirements depend on aspects of the element
        // carrying the role. If the element is not focusable, the `separator`
        // role has no required attributes.
        if (role.is("separator") && !isFocusable(device)(element)) {
            return Outcomes.HasAllStates(role.name, [], []);
        }
        const required = role.requiredAttributes;
        const missing = [];
        let result = true;
        for (const attribute of required) {
            // We need to keep going through all attributes to gather all the missing
            // ones
            if (node.attribute(attribute).every(property("value", isEmpty)) &&
                !(isAriaControlsOptional(node) && attribute === "aria-controls")) {
                missing.push(attribute);
                result = false;
            }
        }
        return result
            ? Outcomes.HasAllStates(role.name, required, missing)
            : Outcomes.HasNotAllStates(role.name, required, missing);
    }
    // If there is no role for the node, we have a problem; applicability ensures
    // the presence of a role. Throwing a Failed result to trigger looking into it
    return Outcomes.RuleError;
}
/**
 * @public
 */
export class RoleAndRequiredAttributes extends Diagnostic {
    static of(message, role, requiredAttributes, missingAttributes) {
        return role === undefined
            ? Diagnostic.of(message)
            : new RoleAndRequiredAttributes(message, role, 
            // Presence is ensured by the overload
            requiredAttributes, missingAttributes);
    }
    _role;
    _requiredAttributes;
    _missingAttributes;
    constructor(message, role, requiredAttributes, missingAttributes) {
        super(message);
        this._role = role;
        this._requiredAttributes = requiredAttributes;
        this._missingAttributes = missingAttributes;
    }
    get role() {
        return this._role;
    }
    get requiredAttributes() {
        return this._requiredAttributes;
    }
    get missingAttributes() {
        return this._missingAttributes;
    }
    equals(value) {
        return (value instanceof RoleAndRequiredAttributes &&
            value._message === this._message &&
            value._role === this._role &&
            Array.equals(value._requiredAttributes, this._requiredAttributes) &&
            Array.equals(value._missingAttributes, this._missingAttributes));
    }
    hash(hash) {
        super.hash(hash);
        hash.writeString(this._role);
        this._requiredAttributes.forEach((attr) => hash.writeString(attr));
        this._missingAttributes.forEach((attr) => hash.writeString(attr));
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            role: this._role,
            attributes: {
                required: Array.copy(this._requiredAttributes),
                missing: Array.copy(this._missingAttributes),
            },
        };
    }
}
/**
 * @public
 */
(function (RoleAndRequiredAttributes) {
    /**@public */
    function isRoleAndRequiredAttributes(value) {
        return value instanceof RoleAndRequiredAttributes;
    }
    RoleAndRequiredAttributes.isRoleAndRequiredAttributes = isRoleAndRequiredAttributes;
})(RoleAndRequiredAttributes || (RoleAndRequiredAttributes = {}));
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.HasAllStates = (role, required, missing) => Ok.of(RoleAndRequiredAttributes.of("The element has all required states and properties", role, required, missing));
    Outcomes.HasNotAllStates = (role, required, missing) => Err.of(RoleAndRequiredAttributes.of("The element does not have all required states and properties", role, required, missing));
    // This should never happen
    Outcomes.RuleError = Err.of(RoleAndRequiredAttributes.of("", "generic", [], []));
})(Outcomes || (Outcomes = {}));
//# sourceMappingURL=rule.js.map