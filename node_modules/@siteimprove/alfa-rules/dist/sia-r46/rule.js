import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { DOM } from "@siteimprove/alfa-aria";
import { Element, Namespace, Query } from "@siteimprove/alfa-dom";
import { EAA } from "@siteimprove/alfa-eaa";
import { Map } from "@siteimprove/alfa-map";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Table } from "@siteimprove/alfa-table";
import { Criterion, Technique } from "@siteimprove/alfa-wcag";
import { expectation } from "../common/act/expectation.js";
import { Scope, Stability } from "../tags/index.js";
const { hasRole, isIncludedInTheAccessibilityTree, isPerceivableForAll } = DOM;
const { hasName, hasNamespace } = Element;
const { and } = Predicate;
const { getElementDescendants } = Query;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r46",
    requirements: [Criterion.of("1.3.1"), EAA.of("9.1.3.1"), Technique.of("H43")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document }) {
        let data = Map.empty();
        return {
            *applicability() {
                const tables = getElementDescendants(document).filter(and(hasNamespace(Namespace.HTML), hasName("table"), isIncludedInTheAccessibilityTree(device)));
                for (const table of tables) {
                    const model = Table.from(table);
                    const headers = getElementDescendants(table).filter(and(hasNamespace(Namespace.HTML), hasName("th"), hasRole(device, "rowheader", "columnheader"), isPerceivableForAll(device)));
                    for (const header of headers) {
                        for (const cell of model.cells.find((cell) => cell.element.equals(header))) {
                            data = data.set(header, [cell, model]);
                            yield header;
                        }
                    }
                }
            },
            expectations(target) {
                // data has been set just before yielding targets
                const [header, table] = data.get(target).getUnsafe();
                return {
                    1: expectation(table.cells.some((cell) => 
                    // Does there exists a cell with the target as one of its headers?
                    hasRole(device, (role) => role.is("cell"))(cell.element) &&
                        cell.headers.some((slot) => slot.equals(header.anchor))), () => Outcomes.IsAssignedToDataCell, () => Outcomes.IsNotAssignedToDataCell),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.IsAssignedToDataCell = Ok.of(Diagnostic.of(`The header cell is assigned to a cell`));
    Outcomes.IsNotAssignedToDataCell = Err.of(Diagnostic.of(`The header cell is not assigned to any cell`));
})(Outcomes || (Outcomes = {}));
//# sourceMappingURL=rule.js.map