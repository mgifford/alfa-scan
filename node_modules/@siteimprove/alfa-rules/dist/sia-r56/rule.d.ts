import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import type { Role } from "@siteimprove/alfa-aria";
import { Array } from "@siteimprove/alfa-array";
import { Element } from "@siteimprove/alfa-dom";
import type { Hash } from "@siteimprove/alfa-hash";
import { Iterable } from "@siteimprove/alfa-iterable";
import { List } from "@siteimprove/alfa-list";
import { Err, Ok } from "@siteimprove/alfa-result";
import type { Page } from "@siteimprove/alfa-web";
import * as dom from "@siteimprove/alfa-dom";
import { Group } from "../common/act/group.js";
declare const _default: Rule.Atomic<Page, Group<Element<string>>, {}, Group<Element<string>>>;
export default _default;
/**
 * @public
 */
export declare namespace Outcomes {
    const differentNames: (role: Role.Name) => Ok<SameNames>;
    const sameNames: (role: Role.Name, errors: Iterable<Iterable<Element>>) => Err<SameNames>;
}
/**
 * @public
 */
export declare class SameNames extends Diagnostic implements Iterable<List<Element>> {
    static of(message: string, role?: Role.Name, errors?: Iterable<Iterable<Element>>): SameNames;
    private readonly _role;
    private readonly _errors;
    protected constructor(message: string, role: Role.Name, errors: ReadonlyArray<List<Element>>);
    get role(): Role.Name;
    [Symbol.iterator](): Iterator<List<Element>>;
    equals(value: SameNames): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: dom.Node.SerializationOptions): SameNames.JSON;
}
/**
 * @public
 */
export declare namespace SameNames {
    interface JSON extends Diagnostic.JSON {
        role: string;
        errors: Array<List.JSON<Element>>;
    }
    function isSameNames(value: Diagnostic): value is SameNames;
    function isSameNames(value: unknown): value is SameNames;
}
//# sourceMappingURL=rule.d.ts.map