import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { DOM, Node as ariaNode } from "@siteimprove/alfa-aria";
import { Element, Node } from "@siteimprove/alfa-dom";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Err, Ok } from "@siteimprove/alfa-result";
import { expectation } from "../common/act/expectation.js";
import { BestPractice } from "../requirements/index.js";
import { Scope, Stability } from "../tags/index.js";
import { withDocumentElement } from "../common/applicability/with-document-element.js";
const { hasRole, isIncludedInTheAccessibilityTree } = DOM;
const { isElement } = Element;
const { and } = Refinement;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r61",
    requirements: [BestPractice.of("document-start-with-level-1-heading")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document }) {
        const firstHeading = document
            .descendants(Node.flatTree)
            .filter(and(isElement, isIncludedInTheAccessibilityTree(device)))
            .find(hasRole(device, "heading"));
        return {
            applicability() {
                return withDocumentElement(document, () => firstHeading.isSome());
            },
            expectations(target) {
                // The heading is guaranteed to exist because of the test in Applicability
                const heading = firstHeading.getUnsafe();
                const level = ariaNode
                    .from(heading, device)
                    .attribute("aria-level")
                    .map((level) => Number(level.value))
                    .getOr(0);
                return {
                    1: expectation(level === 1, () => Outcomes.StartWithLevel1Heading(heading, level), () => Outcomes.StartWithHigherLevelHeading(heading, level)),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.StartWithLevel1Heading = (heading, level) => Ok.of(WithFirstHeading.of(`The document starts with a level 1 heading`, heading, level));
    Outcomes.StartWithHigherLevelHeading = (heading, level) => Err.of(WithFirstHeading.of(`The document does not start with a level 1 heading`, heading, level));
})(Outcomes || (Outcomes = {}));
/**
 * @public
 */
export class WithFirstHeading extends Diagnostic {
    static of(message, firstHeading, level) {
        return firstHeading === undefined || level === undefined
            ? Diagnostic.of(message)
            : new WithFirstHeading(message, firstHeading, level);
    }
    _firstHeading;
    _level;
    constructor(message, firstHeading, level) {
        super(message);
        this._firstHeading = firstHeading;
        this._level = level;
    }
    get firstHeading() {
        return this._firstHeading;
    }
    get firstHeadingLevel() {
        return this._level;
    }
    equals(value) {
        return (value instanceof WithFirstHeading &&
            value._message === this._message &&
            value._firstHeading.equals(this._firstHeading) &&
            value._level === this._level);
    }
    hash(hash) {
        super.hash(hash);
        hash.writeNumber(this._level);
        this._firstHeading.hash(hash);
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            firstHeading: this._firstHeading.toJSON(options),
            firstHeadingLevel: this._level,
        };
    }
}
/**
 * @public
 */
(function (WithFirstHeading) {
    /**@public */
    function isWithFirstHeading(value) {
        return value instanceof WithFirstHeading;
    }
    WithFirstHeading.isWithFirstHeading = isWithFirstHeading;
})(WithFirstHeading || (WithFirstHeading = {}));
//# sourceMappingURL=rule.js.map