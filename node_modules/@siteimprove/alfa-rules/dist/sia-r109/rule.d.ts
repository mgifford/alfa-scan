import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import type { Document, Node } from "@siteimprove/alfa-dom";
import type { Hash } from "@siteimprove/alfa-hash";
import { Language } from "@siteimprove/alfa-iana";
import { Option } from "@siteimprove/alfa-option";
import { Err, Ok } from "@siteimprove/alfa-result";
import type { Page } from "@siteimprove/alfa-web";
import { Question } from "../common/act/question.js";
/**
 * This rule always asks for the language of the page, and compares it with
 * the `lang` attribute. This is not a nice experience for the end user and
 * shouldn't be used until backend can automatically determine the answer.
 */
declare const _default: Rule.Atomic<Page, Document, Question.Metadata, Document>;
export default _default;
/**
 * @public
 */
export declare namespace Outcomes {
    const HasCorrectLang: (programmatic: Language, natural: Language) => Ok<Languages>;
    const HasIncorrectLang: (programmatic: Language, natural: Language) => Err<Languages>;
    const HasNoLanguage: (programmatic: Language) => Err<Languages>;
}
/**
 * @public
 */
export declare class Languages extends Diagnostic {
    static of(message: string, programmatic?: Language, natural?: Language): Languages;
    private readonly _programmatic;
    private readonly _natural;
    protected constructor(message: string, programmatic: Language, natural: Option<Language>);
    get programmatic(): Language;
    get natural(): Option<Language>;
    equals(value: Diagnostic): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: Node.SerializationOptions): Languages.JSON;
}
/**
 * @public
 */
export declare namespace Languages {
    interface JSON extends Diagnostic.JSON {
        programmatic: Language.JSON;
        natural: Option.JSON<Language>;
    }
    function isLanguages(value: Diagnostic): value is Languages;
    function isLanguages(value: unknown): value is Languages;
}
//# sourceMappingURL=rule.d.ts.map