import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { Element } from "@siteimprove/alfa-dom";
import { EAA } from "@siteimprove/alfa-eaa";
import { Language } from "@siteimprove/alfa-iana";
import { Option } from "@siteimprove/alfa-option";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Criterion, Technique } from "@siteimprove/alfa-wcag";
import { expectation } from "../common/act/expectation.js";
import { Question } from "../common/act/question.js";
import { Scope, Stability } from "../tags/index.js";
import { withDocumentElement } from "../common/applicability/with-document-element.js";
const { hasAttribute } = Element;
/**
 * This rule always asks for the language of the page, and compares it with
 * the `lang` attribute. This is not a nice experience for the end user and
 * shouldn't be used until backend can automatically determine the answer.
 */
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r109",
    requirements: [Criterion.of("3.1.1"), EAA.of("9.3.1.1"), Technique.of("H57")],
    tags: [Scope.Page, Stability.Experimental],
    evaluate({ document }) {
        let programmaticLanguage;
        return {
            applicability() {
                return withDocumentElement(document, hasAttribute("lang", (lang) => Language.parse(lang)
                    .tee((lang) => {
                    programmaticLanguage = lang;
                })
                    .isOk()));
            },
            expectations(target) {
                return {
                    1: Question.of("document-language", target).map((language) => Language.parse(language).mapOrElse((naturalLanguage) => expectation(programmaticLanguage.primary.equals(naturalLanguage.primary), () => Outcomes.HasCorrectLang(programmaticLanguage, naturalLanguage), () => Outcomes.HasIncorrectLang(programmaticLanguage, naturalLanguage)), (_) => Option.of(Outcomes.HasNoLanguage(programmaticLanguage)))),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.HasCorrectLang = (programmatic, natural) => Ok.of(Languages.of(`The document's \`lang\` attribute (${programmatic}) matches its language (${natural})`, programmatic, natural));
    Outcomes.HasIncorrectLang = (programmatic, natural) => Err.of(Languages.of(`The document's \`lang\` attribute (${programmatic}) does not match its language (${natural})`, programmatic, natural));
    Outcomes.HasNoLanguage = (programmatic) => Err.of(Languages.of("The document has no identifiable natural language", programmatic));
})(Outcomes || (Outcomes = {}));
/**
 * @public
 */
export class Languages extends Diagnostic {
    static of(message, programmatic = Language.of(Language.Primary.of("en")), natural) {
        return new Languages(message, programmatic, Option.from(natural));
    }
    _programmatic;
    _natural;
    constructor(message, programmatic, natural) {
        super(message);
        this._programmatic = programmatic;
        this._natural = natural;
    }
    get programmatic() {
        return this._programmatic;
    }
    get natural() {
        return this._natural;
    }
    equals(value) {
        return (value instanceof Languages &&
            value._message === this._message &&
            value._programmatic.equals(this._programmatic) &&
            value._natural.equals(this._natural));
    }
    hash(hash) {
        super.hash(hash);
        hash.writeString(this._programmatic.primary.name);
        this._natural.forEach((lang) => hash.writeString(lang.primary.name));
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            programmatic: this._programmatic.toJSON(),
            natural: this._natural.toJSON(),
        };
    }
}
/**
 * @public
 */
(function (Languages) {
    /**@public */
    function isLanguages(value) {
        return value instanceof Languages;
    }
    Languages.isLanguages = isLanguages;
})(Languages || (Languages = {}));
//# sourceMappingURL=rule.js.map