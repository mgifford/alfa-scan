import { Diagnostic, Rule } from "@siteimprove/alfa-act";
import { Cache } from "@siteimprove/alfa-cache";
import { Element, Namespace, Node, Query, Text } from "@siteimprove/alfa-dom";
import { None } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Err, Ok } from "@siteimprove/alfa-result";
import { Style } from "@siteimprove/alfa-style";
import { expectation } from "../common/act/expectation.js";
import { BestPractice } from "../requirements/index.js";
import { Scope, Stability } from "../tags/index.js";
const { hasNamespace, hasName } = Element;
const { isText } = Text;
const { or, not } = Predicate;
const { and } = Refinement;
const { hasCascadedStyle, hasComputedStyle, hasSpecifiedStyle, isVisible } = Style;
const { getElementDescendants } = Query;
export default Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r75",
    requirements: [BestPractice.of("font-size-above-minimum")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document }) {
        const visibleTextCache = Cache.empty();
        return {
            applicability() {
                return getElementDescendants(document, Node.fullTree).filter(and(hasNamespace(Namespace.HTML), not(hasName("sup", "sub")), not((node) => visibleTextCache
                    .get(node, () => node
                    .descendants(Node.fullTree)
                    .filter(and(isText, isVisible(device))))
                    .isEmpty()), hasCascadedStyle(`font-size`, () => true, device)));
            },
            expectations(target) {
                const declaration = Style.from(target, device)
                    .cascaded("font-size")
                    // Applicability guarantees there is a cascaded value
                    .getUnsafe().source;
                const texts = visibleTextCache
                    .get(target)
                    .getUnsafe() // Applicability guarantees there's an entry for target
                    .reject((text) => text.data.trim() === "")
                    .every(or(hasSpecifiedStyle("font-size", (_, source) => 
                // We do need to compare with physical identity, not structural
                // identity (.equals) to differentiate, e.g., two
                // "font-size: 100%" declarations
                source !== declaration, device), hasComputedStyle("font-size", (fontSize, _) => fontSize.value >= 9, device)));
                return {
                    1: expectation(texts, () => Outcomes.IsSufficient(declaration), () => Outcomes.IsInsufficient(declaration)),
                };
            },
        };
    },
});
/**
 * @public
 */
export var Outcomes;
(function (Outcomes) {
    Outcomes.IsSufficient = (declaration) => Ok.of(WithDeclaration.of(`The font size is greater than 9 pixels`, declaration));
    Outcomes.IsInsufficient = (declaration) => Err.of(WithDeclaration.of(`The font size is smaller than 9 pixels`, declaration));
})(Outcomes || (Outcomes = {}));
/**
 * @public
 */
export class WithDeclaration extends Diagnostic {
    static of(message, declaration = None) {
        return new WithDeclaration(message, declaration);
    }
    _declaration;
    constructor(message, declaration) {
        super(message);
        this._declaration = declaration;
    }
    get declaration() {
        return this._declaration;
    }
    equals(value) {
        return (value instanceof WithDeclaration &&
            value._message === this.message &&
            value._declaration === this._declaration);
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            declaration: this._declaration.toJSON(),
        };
    }
}
/**
 * @public
 */
(function (WithDeclaration) {
    /**@public */
    function isWithDeclaration(value) {
        return value instanceof WithDeclaration;
    }
    WithDeclaration.isWithDeclaration = isWithDeclaration;
})(WithDeclaration || (WithDeclaration = {}));
//# sourceMappingURL=rule.js.map