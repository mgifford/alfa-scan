import { Array } from "@siteimprove/alfa-array";
import { Equatable } from "@siteimprove/alfa-equatable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import * as earl from "@siteimprove/alfa-earl";
import * as json from "@siteimprove/alfa-json";
import * as sarif from "@siteimprove/alfa-sarif";
/**
 * @public
 */
export declare class Group<T extends Hashable> implements Iterable<T>, Equatable, Hashable, json.Serializable<Group.JSON<T>>, earl.Serializable<Group.EARL>, sarif.Serializable<sarif.Location> {
    static of<T extends Hashable>(members: Iterable<T>): Group<T>;
    private readonly _members;
    protected constructor(members: ReadonlyArray<T>);
    get size(): number;
    [Symbol.iterator](): Iterator<T>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: json.Serializable.Options): Group.JSON<T>;
    toEARL(): Group.EARL;
    toSARIF(): sarif.Location;
}
/**
 * @public
 */
export declare namespace Group {
    type JSON<T> = Array<json.Serializable.ToJSON<T>>;
    interface EARL extends earl.EARL {
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        "@type": ["ptr:Pointer", "ptr:PointersGroup", "ptr:RelatedPointers"];
        "ptr:groupPointer": {
            "@list": Array<earl.EARL>;
        };
    }
    function isGroup<T extends Hashable>(value: unknown): value is Group<T>;
}
//# sourceMappingURL=group.d.ts.map