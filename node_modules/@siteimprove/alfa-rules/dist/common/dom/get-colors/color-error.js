import { Diagnostic } from "@siteimprove/alfa-act";
import { Array } from "@siteimprove/alfa-array";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Serializable } from "@siteimprove/alfa-json";
import { Sequence } from "@siteimprove/alfa-sequence";
/**
 * @public
 */
export class ColorErrors extends Diagnostic {
    static of(messageOrErrors) {
        return typeof messageOrErrors === "string"
            ? Diagnostic.of(messageOrErrors)
            : new ColorErrors("Could not fully resolve colors", Array.copy(messageOrErrors));
    }
    _errors;
    constructor(message, errors) {
        super(message);
        this._errors = errors;
    }
    get errors() {
        return this._errors;
    }
    equals(value) {
        return (value instanceof ColorErrors &&
            value._message === this._message &&
            Array.equals(value._errors, this._errors));
    }
    hash(hash) {
        super.hash(hash);
        this._errors.forEach((error) => error.hash(hash));
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            errors: Array.toJSON(this._errors, options),
        };
    }
}
/**
 * @public
 */
(function (ColorErrors) {
    /**@public */
    function isColorErrors(value) {
        return value instanceof ColorErrors;
    }
    ColorErrors.isColorErrors = isColorErrors;
    function prepend(old, cur) {
        return ColorErrors.of([
            ...cur,
            ...old
                .err()
                .map((old) => old.errors)
                .getOr([]),
        ]);
    }
    ColorErrors.prepend = prepend;
})(ColorErrors || (ColorErrors = {}));
/**
 * @public
 */
export class ColorError extends Diagnostic {
    _element;
    _type;
    _kind;
    constructor(message, element, type, kind) {
        super(message);
        this._element = element;
        this._type = type;
        this._kind = kind;
    }
    get element() {
        return this._element;
    }
    get type() {
        return this._type;
    }
    get kind() {
        return this._kind;
    }
    equals(value) {
        return (value instanceof ColorError &&
            value._message === this._message &&
            value._element.equals(this._element) &&
            value._type === this._type &&
            value._kind === this._kind);
    }
    hash(hash) {
        super.hash(hash);
        this._element.hash(hash);
        hash.writeString(this._kind);
        hash.writeString(this._type);
    }
    toJSON(options) {
        return {
            ...super.toJSON(options),
            element: this._element.toJSON(options),
            type: this._type,
            kind: this._kind,
        };
    }
}
/**
 * @public
 */
(function (ColorError) {
    /**@public */
    function isColorError(value) {
        return value instanceof ColorError;
    }
    ColorError.isColorError = isColorError;
    /**
     * @internal
     * Most color error are just about one CSS property.
     */
    class WithProperty extends ColorError {
        static of(message, diagnostic) {
            return diagnostic !== undefined
                ? new WithProperty(message, diagnostic.type, diagnostic.kind, diagnostic.element, diagnostic.property, diagnostic.value)
                : Diagnostic.of(message);
        }
        _property;
        _value;
        constructor(message, type, kind, element, proprety, value) {
            super(message, element, type, kind);
            this._property = proprety;
            this._value = value;
        }
        get property() {
            return this._property;
        }
        get value() {
            return this._value;
        }
        equals(value) {
            return (super.equals(value) &&
                value instanceof WithProperty &&
                value._property === this._property &&
                Equatable.equals(value._value, this._value));
        }
        toJSON() {
            return {
                ...super.toJSON(),
                property: this._property,
                value: Serializable.toJSON(this._value),
            };
        }
    }
    ColorError.WithProperty = WithProperty;
    /**
     * @public
     */
    (function (WithProperty) {
        function from(type, kind, property, message) {
            return (element, value) => WithProperty.of(message, { type, kind, element, property, value });
        }
        WithProperty.from = from;
        function isWithProperty(value) {
            return value instanceof WithProperty;
        }
        WithProperty.isWithProperty = isWithProperty;
    })(WithProperty = ColorError.WithProperty || (ColorError.WithProperty = {}));
    ColorError.isWithProperty = WithProperty.isWithProperty;
    ColorError.backgroundSize = WithProperty.from("layer", "background-size", "background-size", "A background-size was encountered");
    ColorError.externalBackgroundImage = WithProperty.from("layer", "background-image", "background-image", "A background-image with a url() was encountered");
    ColorError.nonStaticPosition = WithProperty.from("layer", "non-static", "position", "A non-statically positioned element was encountered");
    ColorError.textShadow = WithProperty.from("background", "text-shadow", "text-shadow", "A text-shadow was encountered");
    /**
     * @public
     * This one does not depend on a CSS property, but on some other elements
     */
    class HasInterposedDescendants extends ColorError {
        static of(message, element, positionedDescendants) {
            return element !== undefined && positionedDescendants !== undefined
                ? new HasInterposedDescendants(message, element, Sequence.from(positionedDescendants))
                : Diagnostic.of(message);
        }
        _positionedDescendants;
        constructor(message, element, positionedDescendants) {
            super(message, element, "layer", "interposed-descendant");
            this._positionedDescendants = positionedDescendants;
        }
        get positionedDescendants() {
            return this._positionedDescendants;
        }
        equals(value) {
            return (super.equals(value) &&
                value instanceof HasInterposedDescendants &&
                value._positionedDescendants.equals(this._positionedDescendants));
        }
        toJSON() {
            return {
                ...super.toJSON(),
                positionedDescendants: this._positionedDescendants.toJSON(),
            };
        }
    }
    ColorError.HasInterposedDescendants = HasInterposedDescendants;
    /**
     * @public
     */
    (function (HasInterposedDescendants) {
        function from(offsetParent, positionedDescendants) {
            return HasInterposedDescendants.of("An interposed descendant element was encountered", offsetParent, positionedDescendants);
        }
        HasInterposedDescendants.from = from;
        function isInterposedDescendants(value) {
            return value instanceof HasInterposedDescendants;
        }
        HasInterposedDescendants.isInterposedDescendants = isInterposedDescendants;
    })(HasInterposedDescendants = ColorError.HasInterposedDescendants || (ColorError.HasInterposedDescendants = {}));
    ColorError.interposedDescendants = HasInterposedDescendants.from, ColorError.isInterposedDescendants = HasInterposedDescendants.isInterposedDescendants;
})(ColorError || (ColorError = {}));
//# sourceMappingURL=color-error.js.map