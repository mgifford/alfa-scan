import { Cache } from "@siteimprove/alfa-cache";
import { Percentage, Color, CSS4Color } from "@siteimprove/alfa-css";
import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Err } from "@siteimprove/alfa-result";
import { Context } from "@siteimprove/alfa-selector";
import { Set } from "@siteimprove/alfa-set";
import { Style } from "@siteimprove/alfa-style";
import { ColorError, ColorErrors } from "./color-error.js";
import { Layer } from "./get-layers.js";
const { isVisibleShadow } = Style;
const backgroundCacheWithFakeOpacity = Cache.empty();
const backgroundCacheWithDefaultOpacity = Cache.empty();
/**
 * Get the background colors of an element by :
 * 1. gathering all layers, until a fully opaque one is found.
 * 2. merging them into one composite color
 *
 * @public
 */
export function getBackground(element, device, context = Context.empty(), opacity, ignoredInterposedDescendants = Set.empty()) {
    const textShadow = Style.from(element, device, context).computed("text-shadow").value;
    const cache = opacity === undefined
        ? backgroundCacheWithDefaultOpacity
        : backgroundCacheWithFakeOpacity;
    return cache
        .get(device, Cache.empty)
        .get(context, Cache.empty)
        .get(ignoredInterposedDescendants, Cache.empty)
        .get(element, () => {
        let error = None;
        // If the element has a visible text-shadow, we don't try to guess how it looks.
        if (textShadow.type === "list" &&
            Iterable.some(textShadow, (shadow) => isVisibleShadow(shadow))) {
            error = Option.of(ColorError.textShadow(element, textShadow));
        }
        // We want to gather layers errors even if we've already found one error.
        const layersColors = Layer.getLayers(element, device, context, opacity, ignoredInterposedDescendants);
        return error.isNone() && layersColors.isOk()
            ? layersColors.map((layers) => layers.reduce(Layer.merge, [white]))
            : Err.of(ColorErrors.prepend(layersColors, error));
    });
}
// We make the initial backdrop solid white as this can be assumed
// to be the color of the canvas onto which the other backgrounds
// are rendered.
const white = Color.rgb(Percentage.of(1), Percentage.of(1), Percentage.of(1), Percentage.of(1));
//# sourceMappingURL=get-background.js.map