import { Diagnostic } from "@siteimprove/alfa-act";
import { Array } from "@siteimprove/alfa-array";
import type { Element, Node } from "@siteimprove/alfa-dom";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Result } from "@siteimprove/alfa-result";
import { Sequence } from "@siteimprove/alfa-sequence";
import type { Style } from "@siteimprove/alfa-style";
interface ErrorName {
    layer: "background-size" | "background-image" | "non-static" | "interposed-descendant";
    background: "text-shadow";
}
/**
 * @public
 */
export declare class ColorErrors<out T extends keyof ErrorName = keyof ErrorName> extends Diagnostic {
    static of(message: string): Diagnostic;
    static of<T extends keyof ErrorName = keyof ErrorName>(errors: ReadonlyArray<ColorError<T>>): ColorErrors<T>;
    private readonly _errors;
    protected constructor(message: string, errors: ReadonlyArray<ColorError<T>>);
    get errors(): ReadonlyArray<ColorError<T>>;
    equals(value: ColorErrors): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: Node.SerializationOptions): ColorErrors.JSON<T>;
}
/**
 * @public
 */
export declare namespace ColorErrors {
    interface JSON<T extends keyof ErrorName = keyof ErrorName> extends Diagnostic.JSON {
        errors: Array<ColorError.JSON<T>>;
    }
    function isColorErrors<T extends keyof ErrorName = keyof ErrorName>(value: Diagnostic): value is ColorErrors<T>;
    function isColorErrors<T extends keyof ErrorName = keyof ErrorName>(value: unknown): value is ColorErrors<T>;
    function prepend<T extends keyof ErrorName = keyof ErrorName, T1 extends T = T, T2 extends T = T>(old: Result<unknown, ColorErrors<T1>>, cur: Iterable<ColorError<T2>>): ColorErrors<T>;
}
/**
 * @public
 */
export declare abstract class ColorError<out T extends keyof ErrorName = keyof ErrorName, out K extends ErrorName[T] = ErrorName[T]> extends Diagnostic {
    protected readonly _element: Element;
    protected readonly _type: T;
    protected readonly _kind: K;
    protected constructor(message: string, element: Element, type: T, kind: K);
    get element(): Element;
    get type(): T;
    get kind(): K;
    equals(value: ColorError): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: Node.SerializationOptions): ColorError.JSON<T, K>;
}
/**
 * @public
 */
export declare namespace ColorError {
    interface JSON<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]> extends Diagnostic.JSON {
        element: Element.JSON;
        type: T;
        kind: K;
    }
    function isColorError<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]>(value: Diagnostic): value is ColorError<T, K>;
    function isColorError<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]>(value: unknown): value is ColorError<T, K>;
    /**
     * @internal
     * Most color error are just about one CSS property.
     */
    class WithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow"> extends ColorError<T, K> {
        static of(message: string): Diagnostic;
        static of<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(message: string, diagnostic: {
            type: T;
            kind: K;
            element: Element;
            property: N;
            value: Style.Computed<N>;
        }): WithProperty<T, K, N>;
        private readonly _property;
        private readonly _value;
        protected constructor(message: string, type: T, kind: K, element: Element, proprety: N, value: Style.Computed<N>);
        get property(): N;
        get value(): Style.Computed<N>;
        equals(value: WithProperty<T, K, N>): boolean;
        equals(value: unknown): value is this;
        toJSON(): WithProperty.JSON<T, K, N>;
    }
    /**
     * @public
     */
    namespace WithProperty {
        interface JSON<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow"> extends ColorError.JSON<T, K> {
            property: N;
            value: Serializable.ToJSON<Style.Computed<N>>;
        }
        function from<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(type: T, kind: K, property: N, message: string): (element: Element, value: Style.Computed<N>) => WithProperty<T, K, N>;
        function isWithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(value: Diagnostic): value is WithProperty<T, K, N>;
        function isWithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(value: unknown): value is WithProperty<T, K, N>;
    }
    const isWithProperty: typeof WithProperty.isWithProperty;
    const backgroundSize: (element: Element, value: import("@siteimprove/alfa-css").List<import("@siteimprove/alfa-css").Keyword<"cover"> | import("@siteimprove/alfa-css").Keyword<"contain"> | import("@siteimprove/alfa-css").Tuple<[import("@siteimprove/alfa-css").LengthPercentage.PartiallyResolved | import("@siteimprove/alfa-css").Keyword<"auto">, import("@siteimprove/alfa-css").LengthPercentage.PartiallyResolved | import("@siteimprove/alfa-css").Keyword<"auto">]>>) => WithProperty<"layer", "background-size", "background-size">;
    const externalBackgroundImage: (element: Element, value: import("@siteimprove/alfa-css").List<import("@siteimprove/alfa-css").Image.PartiallyResolved | import("@siteimprove/alfa-css").Keyword<"none">>) => WithProperty<"layer", "background-image", "background-image">;
    const nonStaticPosition: (element: Element, value: import("@siteimprove/alfa-css").Keyword.ToKeywords<"fixed" | "relative" | "static" | "absolute" | "sticky">) => WithProperty<"layer", "non-static", "position">;
    const textShadow: (element: Element, value: import("@siteimprove/alfa-css").Keyword<"none"> | import("@siteimprove/alfa-css").List<import("@siteimprove/alfa-css").Shadow.Canonical>) => WithProperty<"background", "text-shadow", "text-shadow">;
    /**
     * @public
     * This one does not depend on a CSS property, but on some other elements
     */
    class HasInterposedDescendants extends ColorError<"layer", "interposed-descendant"> {
        static of(message: string): Diagnostic;
        static of(message: string, element: Element, positionedDescendants: Iterable<Element>): HasInterposedDescendants;
        private readonly _positionedDescendants;
        protected constructor(message: string, element: Element, positionedDescendants: Sequence<Element>);
        get positionedDescendants(): Iterable<Element>;
        equals(value: HasInterposedDescendants): boolean;
        equals(value: unknown): value is this;
        toJSON(): HasInterposedDescendants.JSON;
    }
    /**
     * @public
     */
    namespace HasInterposedDescendants {
        interface JSON extends ColorError.JSON<"layer", "interposed-descendant"> {
            positionedDescendants: Sequence.JSON<Element>;
        }
        function from(offsetParent: Element, positionedDescendants: Iterable<Element>): HasInterposedDescendants;
        function isInterposedDescendants(value: Diagnostic): value is HasInterposedDescendants;
        function isInterposedDescendants(value: unknown): value is HasInterposedDescendants;
    }
    const interposedDescendants: typeof HasInterposedDescendants.from, isInterposedDescendants: typeof HasInterposedDescendants.isInterposedDescendants;
}
export {};
//# sourceMappingURL=color-error.d.ts.map