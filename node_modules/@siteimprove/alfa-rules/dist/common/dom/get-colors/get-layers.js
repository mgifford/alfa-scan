import { Array } from "@siteimprove/alfa-array";
import { Cache } from "@siteimprove/alfa-cache";
import { Color, CSS4Color } from "@siteimprove/alfa-css";
import { Element, Node } from "@siteimprove/alfa-dom";
import { Err, Result } from "@siteimprove/alfa-result";
import { Context } from "@siteimprove/alfa-selector";
import { Set } from "@siteimprove/alfa-set";
import { Style } from "@siteimprove/alfa-style";
import { getInterposedDescendant } from "../get-interposed-descendant.js";
import { ColorError, ColorErrors } from "./color-error.js";
const { isElement } = Element;
const { hasTransparentBackground, isPositioned } = Style;
/**
 * @public
 */
export class Layer {
    static of(colors, opacity) {
        return new Layer(Array.from(colors), opacity);
    }
    _colors;
    _opacity;
    constructor(colors, opacity) {
        this._colors = colors;
        this._opacity = opacity;
    }
    get colors() {
        return this._colors;
    }
    get opacity() {
        return this._opacity;
    }
}
/**
 * @public
 */
(function (Layer) {
    const layersCacheWithFakeOpacity = Cache.empty();
    const layersCacheWithDefaultOpacity = Cache.empty();
    /**
     * Gather all background layers of an element.
     * The layers can be set both by the element's own background property, and
     * by its ancestors, depending on transparency.
     * Since we do not have layout information, we simply assume that the DOM tree
     * ancestry mimics the actual layout of boxes.
     */
    function getLayers(element, device, context = Context.empty(), 
    // Possible override of the element's opacity.
    opacity, ignoredInterposedDescendants = Set.empty()) {
        const cache = opacity === undefined
            ? layersCacheWithDefaultOpacity
            : layersCacheWithFakeOpacity;
        return cache
            .get(device, Cache.empty)
            .get(context, Cache.empty)
            .get(ignoredInterposedDescendants, Cache.empty)
            .get(element, () => {
            const style = Style.from(element, device, context);
            const currentLayers = getCurrentLayers(element, device, context, opacity);
            const layers = currentLayers.getOr([]);
            const errors = currentLayers.getErrOr([]);
            // If the current layer is fully opaque, no need to go further
            if (errors.length === 0 &&
                layers.length > 0 &&
                layers.every((layer) => layer.opacity === 1 &&
                    layer.colors.every((color) => color.alpha.value === 1))) {
                return Result.of(layers);
            }
            // If the current element is positioned,
            // we don't know exactly where it stands and bail out.
            if (isPositioned(device, "absolute", "fixed")(element)) {
                errors.push(ColorError.nonStaticPosition(element, style.computed("position").value));
            }
            // If the current element has interposed descendants that:
            // 1. have non-transparent background; and
            // 2. should not be ignored,
            // we don't know exactly where they are and bail out.
            const interposedDescendants = getInterposedDescendant(device, element)
                .reject(hasTransparentBackground(device))
                .reject(ignoredInterposedDescendants.has.bind(ignoredInterposedDescendants));
            if (!interposedDescendants.isEmpty()) {
                errors.push(ColorError.interposedDescendants(element, interposedDescendants));
            }
            // If the background layer does not have a lower layer that is fully opaque,
            // we need to also locate the layers sitting behind, i.e. one the parent.
            for (const parent of element.parent(Node.flatTree).filter(isElement)) {
                const layersColors = getLayers(parent, device, context, 
                // The opacity override only applies to the last layer, so it is not
                // used in the recursive calls
                undefined, ignoredInterposedDescendants);
                return errors.length === 0
                    ? layersColors.map((parentLayers) => parentLayers.concat(layers))
                    : Err.of(ColorErrors.prepend(layersColors, errors));
            }
            // If there is no parent, this means we're at the root. In that case,
            // we simply return the layers we've found so far.
            return errors.length === 0
                ? Result.of(layers)
                : Err.of(ColorErrors.of(errors));
        });
    }
    Layer.getLayers = getLayers;
    /**
     * Merge colors in a layer with colors in an existing backdrop.
     */
    function merge(backdrops, layer) {
        return layer.colors.reduce((layers, color) => layers.concat(backdrops.map((backdrop) => Color.composite(color, backdrop, layer.opacity))), []);
    }
    Layer.merge = merge;
    /**
     * Get the layers defined on a element (in its background property).
     *
     * @private
     */
    function getCurrentLayers(element, device, context = Context.empty(), 
    // Possible override of the element's opacity.
    opacity) {
        const style = Style.from(element, device, context);
        const backgroundColor = style.used("background-color").value;
        const backgroundImage = style.computed("background-image").value;
        const backgroundSize = style.computed("background-size").value;
        opacity = opacity ?? style.computed("opacity").value.value;
        const layers = [];
        const errors = [];
        layers.push(Layer.of([backgroundColor], opacity));
        for (const image of backgroundImage) {
            if (image.type === "keyword") {
                continue;
            }
            // We currently have no way of extracting colors from images, so we simply
            // bail out if we encounter a background image.
            if (image.image.type === "url") {
                // If the URL is empty, it will be discarded by the browser and no image
                // will be displayed, so we ignore it.
                if (image.image.url !== "") {
                    errors.push(ColorError.externalBackgroundImage(element, backgroundImage));
                }
                continue;
            }
            // If there is a background-size, we currently have no way of guessing
            // whether it is large enough to go under the text or not.
            // So we simply bail out.
            if (!backgroundSize.equals(style.initial("background-size").value)) {
                errors.push(ColorError.backgroundSize(element, backgroundSize));
                continue;
            }
            // For each gradient, we extract all color stops into a background layer of
            // their own. As gradients need a start and an end point, there will always
            // be at least two color stops.
            const stops = [];
            for (const item of image.image.items) {
                if (item.type === "stop") {
                    stops.push(Color.resolve({
                        currentColor: style.used("color").value,
                    })(item.color));
                }
            }
            layers.push(Layer.of(stops, opacity));
        }
        return errors.length === 0 ? Result.of(layers) : Err.of(errors);
    }
})(Layer || (Layer = {}));
//# sourceMappingURL=get-layers.js.map