import { Diagnostic } from "@siteimprove/alfa-act";
import type { CSS4Color } from "@siteimprove/alfa-css";
import type { Equatable } from "@siteimprove/alfa-equatable";
import type { Serializable } from "@siteimprove/alfa-json";
import type { Node } from "@siteimprove/alfa-dom";
import type { Comparable } from "@siteimprove/alfa-comparable";
import { Comparison } from "@siteimprove/alfa-comparable";
import type { Hash, Hashable } from "@siteimprove/alfa-hash";
import type * as json from "@siteimprove/alfa-json";
type Name = ["container", "link"] | ["foreground", "background"];
type FirstColor<N extends Name> = N[0];
type SecondColor<N extends Name> = N[1];
/**
 * @public
 */
export declare class Contrast<N extends Name = Name> extends Diagnostic {
    static of<N extends Name = Name>(message: string, threshold?: number, pairings?: Iterable<Contrast.Pairing<N>>): Contrast<N>;
    private readonly _threshold;
    private readonly _pairings;
    protected constructor(message: string, threshold: number, pairings: Array<Contrast.Pairing<N>>);
    get threshold(): number;
    get pairings(): Iterable<Contrast.Pairing<N>>;
    equals(value: Contrast): boolean;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    toJSON(options?: Node.SerializationOptions): Contrast.JSON<N>;
}
/**
 * @public
 */
export declare namespace Contrast {
    export interface JSON<N extends Name> extends Diagnostic.JSON {
        threshold: number;
        pairings: Array<Pairing.JSON<N>>;
    }
    export function isContrast<N extends Name>(value: Diagnostic): value is Contrast<N>;
    export function isContrast<N extends Name>(value: unknown): value is Contrast<N>;
    export class Pairing<N extends Name = Name> implements Equatable, Serializable, Hashable, Comparable<Pairing<N>> {
        static of<N extends Name = Name>(color1: [FirstColor<N>, CSS4Color], color2: [SecondColor<N>, CSS4Color], contrast: number): Pairing<N>;
        private readonly _color1;
        private readonly _color2;
        private readonly _contrast;
        protected constructor(color1: Color<FirstColor<N>>, color2: Color<SecondColor<N>>, contrast: number);
        hash(hash: Hash): void;
        get color1(): Color<FirstColor<N>>;
        get color2(): Color<SecondColor<N>>;
        get contrast(): number;
        equals(value: unknown): value is this;
        compare(value: Pairing<N>): Comparison;
        toJSON(): Pairing.JSON<N>;
    }
    export namespace Pairing {
        interface JSON<N extends Name> {
            [key: string]: json.JSON;
            color1: Color.JSON<FirstColor<N>>;
            color2: Color.JSON<SecondColor<N>>;
            contrast: number;
        }
    }
    class Color<N extends FirstColor<Name> | SecondColor<Name>> implements Equatable, Serializable, Hashable {
        static of<N extends FirstColor<Name> | SecondColor<Name>>(name: N, value: CSS4Color): Color<N>;
        private readonly _name;
        private readonly _value;
        protected constructor(name: N, value: CSS4Color);
        hash(hash: Hash): void;
        get name(): N;
        get value(): CSS4Color;
        equals(value: unknown): value is this;
        toJSON(): Color.JSON<N>;
    }
    namespace Color {
        interface JSON<N extends FirstColor<Name> | SecondColor<Name>> {
            [key: string]: json.JSON;
            name: N;
            value: CSS4Color.JSON;
        }
    }
    export {};
}
export {};
//# sourceMappingURL=contrast.d.ts.map