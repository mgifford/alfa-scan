import type { Callback } from "@siteimprove/alfa-callback";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type { Thunk } from "@siteimprove/alfa-thunk";
import type * as json from "@siteimprove/alfa-json";
import type { Result } from "./result.js";
/**
 * @public
 */
export declare class Err<E> implements Result<never, E> {
    static of<E>(error: E): Err<E>;
    private readonly _error;
    protected constructor(error: E);
    isOk(): this is never;
    isErr(): this is Err<E>;
    map(): Err<E>;
    mapErr<F>(mapper: Mapper<E, F>): Err<F>;
    mapOrElse<U>(ok: unknown, err: Mapper<E, U>): U;
    forEach(callback: Callback<never>): void;
    forEachErr(callback: Callback<E>): void;
    apply(): Err<E>;
    flatMap(): Err<E>;
    flatten<T, E>(this: Result<never, E>): Result<T, E>;
    reduce<U>(reducer: unknown, accumulator: U): U;
    includes(): this is never;
    includesErr(error: E): boolean;
    some(): this is never;
    someErr<F extends E>(refinement: Refinement<E, F>): this is Err<F>;
    someErr(predicate: Predicate<E>): boolean;
    none(): this is Err<E>;
    noneErr<F extends E>(refinement: Refinement<E, F>): this is Result<never, Exclude<E, F>>;
    noneErr(predicate: Predicate<E>): boolean;
    every(): this is Err<E>;
    everyErr<F extends E>(refinement: Refinement<E, F>): this is Result<never, F>;
    everyErr(predicate: Predicate<E>): boolean;
    and(): Err<E>;
    andThen(): Err<E>;
    or<U, F>(result: Result<U, F>): Result<U, F>;
    orElse<U, F>(result: Thunk<Result<U, F>>): Result<U, F>;
    /**
     * @internal
     */
    getUnsafe(message?: string): never;
    /**
     * @internal
     */
    getErrUnsafe(): E;
    getErr(): E;
    getOr<U>(value: U): U;
    getOrElse<U>(value: Callback<E, U>): U;
    getErrOr(): E;
    getErrOrElse(): E;
    ok(): None;
    err(): Option<E>;
    tee(): Err<E>;
    teeErr(callback: Callback<E>): Err<E>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Generator<never, void, unknown>;
    toJSON(options?: Serializable.Options): Err.JSON<E>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Err {
    interface JSON<E> {
        [key: string]: json.JSON;
        type: "err";
        error: Serializable.ToJSON<E>;
    }
    function isErr<T, E>(value: Iterable<T>): value is Err<E>;
    function isErr<E>(value: unknown): value is Err<E>;
}
//# sourceMappingURL=err.d.ts.map