import type { Callback } from "@siteimprove/alfa-callback";
import type { Hash } from "@siteimprove/alfa-hash";
import { Serializable } from "@siteimprove/alfa-json";
import type { Mapper } from "@siteimprove/alfa-mapper";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import type { Reducer } from "@siteimprove/alfa-reducer";
import type { Refinement } from "@siteimprove/alfa-refinement";
import type * as json from "@siteimprove/alfa-json";
import type { Result } from "./result.js";
/**
 * @public
 */
export declare class Ok<T> implements Result<T, never> {
    static of<T>(value: T): Ok<T>;
    private readonly _value;
    protected constructor(value: T);
    isOk(): this is Ok<T>;
    isErr(): this is never;
    map<U>(mapper: Mapper<T, U>): Ok<U>;
    mapErr(): Ok<T>;
    mapOrElse<U>(ok: Mapper<T, U>): U;
    forEach(callback: Callback<T>): void;
    forEachErr(callback: Callback<never>): void;
    apply<E, U>(mapper: Result<Mapper<T, U>, E>): Result<U, E>;
    flatMap<U, F>(mapper: Mapper<T, Result<U, F>>): Result<U, F>;
    flatten<T, E>(this: Ok<Result<T, E>>): Result<T, E>;
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    includes(value: T): boolean;
    includesErr(): this is never;
    some<U extends T>(refinement: Refinement<T, U>): this is Ok<U>;
    some(predicate: Predicate<T>): boolean;
    someErr(): this is never;
    none<U extends T>(refinement: Refinement<T, U>): this is Result<Exclude<T, U>, never>;
    none(predicate: Predicate<T>): boolean;
    noneErr(): this is this;
    every<U extends T>(refinement: Refinement<T, U>): this is Result<U, never>;
    every(predicate: Predicate<T>): boolean;
    everyErr(): this is this;
    and<U, F>(result: Result<U, F>): Result<U, F>;
    andThen<U, F>(result: Mapper<T, Result<U, F>>): Result<U, F>;
    or(): Ok<T>;
    orElse(): Ok<T>;
    get(): T;
    /**
     * @internal
     */
    getUnsafe(): T;
    /**
     * @internal
     */
    getErrUnsafe(message?: string): never;
    getOr(): T;
    getOrElse(): T;
    getErrOr<F>(error: F): F;
    getErrOrElse<F>(error: Callback<T, F>): F;
    ok(): Option<T>;
    err(): None;
    tee(callback: Callback<T>): Ok<T>;
    teeErr(): Ok<T>;
    equals(value: unknown): value is this;
    hash(hash: Hash): void;
    [Symbol.iterator](): Generator<T, void, unknown>;
    toJSON(options?: Serializable.Options): Ok.JSON<T>;
    toString(): string;
}
/**
 * @public
 */
export declare namespace Ok {
    interface JSON<T> {
        [key: string]: json.JSON;
        type: "ok";
        value: Serializable.ToJSON<T>;
    }
    function isOk<T>(value: Iterable<T>): value is Ok<T>;
    function isOk<T>(value: unknown): value is Ok<T>;
}
//# sourceMappingURL=ok.d.ts.map